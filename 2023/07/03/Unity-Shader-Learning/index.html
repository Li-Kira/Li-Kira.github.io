<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="LiKira">





<title>Unity Shader Learning | Portfolio &amp; Blog - LiKira</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">LiKira&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">LiKira&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Unity Shader Learning</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">LiKira</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 3, 2023&nbsp;&nbsp;20:36:02</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Unity/">Unity</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p>参考书籍：冯乐乐 - 《Unity Shader入门精要》</p>
</blockquote>
<h2 id="1-渲染流水线"><a href="#1-渲染流水线" class="headerlink" title="1 - 渲染流水线"></a>1 - 渲染流水线</h2><p>在《Render-Time Rendering，Third Edition》一书中，提出将一个渲染流程分为3各阶段：<strong>应用阶段（Application Stage）、几何阶段（Geometry Stage）、光栅化阶段（Rasterizer Stage）</strong>。</p>
<h3 id="1-1-应用阶段"><a href="#1-1-应用阶段" class="headerlink" title="1.1 - 应用阶段"></a>1.1 - 应用阶段</h3><p><strong>应用阶段（在CPU上）：</strong></p>
<ul>
<li><p>将数据加载到显存</p>
</li>
<li><p>设置渲染状态</p>
<blockquote>
<p><strong>渲染状态：</strong>定义了场景中的网格是怎么被渲染的，使用了什么顶点、片元着色器，光源属性和材质等。</p>
</blockquote>
</li>
<li><p>Draw Call</p>
<blockquote>
<p><strong>Draw Call：</strong>CPU告诉GPU如何去进行渲染的指令，即根据渲染状态和所有输入的顶点数据。</p>
</blockquote>
</li>
</ul>
<h3 id="1-2-几何阶段"><a href="#1-2-几何阶段" class="headerlink" title="1.2 - 几何阶段"></a>1.2 - 几何阶段</h3><p><strong>几何阶段：</strong>顶点数据通过顶点着色器等一系列着色器进行空间变换、顶点着色，最终经过裁剪映射到屏幕空间。</p>
<ul>
<li><p><strong>顶点着色器：</strong>最主要的工作是坐标变换、逐顶点光照。常用于实现顶点动画。一个最基本的顶点着色器需要完成工作是将顶点坐标转换到齐次剪裁空间中。</p>
</li>
<li><p><strong>剪裁：</strong>剔除不在视野范围的物体数据。</p>
</li>
<li><p><strong>屏幕映射：</strong>将每个图元的x和y坐标转换到屏幕坐标系下。</p>
<blockquote>
<p>屏幕坐标系在<strong>OpenGL</strong>和<strong>DirectX</strong>中存在差异，<strong>OpenGL</strong>中是数学中常用的由左向右，由下向上的坐标系，<strong>DirectX</strong>则是由左往右，由上往下，符合人类的阅读顺序的坐标系。</p>
<p>如果发现得到的图像是反的，那么有可能是这个原因造成的。</p>
</blockquote>
</li>
</ul>
<p><img src="/image/UnityShaderLearning/image-20230630211935996.png" alt="image-20230630211935996"></p>
<h3 id="1-3-光栅化阶段"><a href="#1-3-光栅化阶段" class="headerlink" title="1.3 - 光栅化阶段"></a>1.3 - 光栅化阶段</h3><p><strong>光栅化阶段：</strong>计算每个图元覆盖了哪些像素，为这些像素计算它们的颜色。</p>
<ul>
<li><p><strong>三角形设置：</strong>计算光栅化一个三角网格所需的信息。</p>
</li>
<li><p><strong>三角形遍历：</strong>检查每一个像素是否被一个三角网格覆盖，如果是就会生成一个片元。</p>
<blockquote>
<p>片元不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。包括屏幕坐标，深度信息，以及其他从几何阶段输出的顶点信息例如：法线、纹理坐标等。</p>
</blockquote>
</li>
<li><p><strong>片元着色器：</strong>这个阶段可以完成许多渲染技术，其中最重要的就是纹理采样。</p>
</li>
<li><p><strong>逐片元操作：</strong>决定每个片元的可见性，涉及很多测试工作：例如<strong>深度测试</strong>、<strong>模板测试</strong>。如果一个片元通过了所有的测试，那么就将这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行混合。</p>
<blockquote>
<p>理解模板测试和深度就能够理解之后章节提到的渲染队列，尤其是处理透明效果时出现的问题。如果一个片元通过了模板测试，那么他会进行下一个深度测试。</p>
<ul>
<li><strong>模板测试：</strong>通常用于限制渲染的范围。</li>
<li><strong>深度测试：</strong>显示出离摄像机最近的物体，剔除其他被遮挡的部分。</li>
<li><strong>合并：</strong>如果一个片元通过了模板测试和深度测试，那么就可以进行合并。对于半透明的物体，需要混合操作让这个物体看起来是透明的。<strong>混合</strong>类似于Photoshop中的图层混合模式，会根据透明通道的值进行相加、相减、相乘等。</li>
<li>此外，在Unity的渲染流水线中，<strong>深度测试</strong>是在片元着色器之前的，这种技术也称为<strong>Early-Z</strong>技术，通过尽可能地早知道哪些片元是会被舍弃的，提高了GPU的性能。</li>
</ul>
</blockquote>
</li>
</ul>
<p>当图元经过了光栅化阶段的计算和测试后，就会显示到我们的屏幕上。我们的屏幕上显示的就是颜色缓冲区中的颜色值，为了避免我们看到那些正在光栅化的图元，GPU会使用<strong>双重缓冲（Double Buffering）</strong>策略。即对于场景的渲染是在幕后的<strong>后置缓冲（Back Buffer）</strong>中进行的，当场景被渲染到后置缓冲中，GPU就会交换后置缓冲和<strong>前置缓冲（Front Buffer）</strong>中的内容，由此来保证我们看到的图像总是连续的。</p>
<h3 id="1-4-Draw-Call"><a href="#1-4-Draw-Call" class="headerlink" title="1.4 - Draw Call"></a>1.4 - Draw Call</h3><p><strong>Draw Call：</strong>Draw Call是CPU调用图像接口命令，如OpenGL或者DirectX中的相关命令，以指示GPU进行渲染的操作。</p>
<ol>
<li><p>CPU和GPU之间如何实现并行工作？</p>
<p>使用命令缓冲区，其中包含的命令有很多，除了Draw Call以外还有改变渲染状态等。</p>
</li>
<li><p>为什么Draw Call多了会影响帧率？</p>
<p>分配内存、创建元数据这些操作多了会造成很多额外的性能开销，如果复制了很多小文件，那么这种性能开销会很大。</p>
</li>
<li><p>如何减少Draw Call？</p>
<p>减少Draw Call的方法有很多，比如：<strong>批处理</strong></p>
<blockquote>
<p><strong>批处理</strong>是将很多的Draw Call合并成一个大的Draw Call，通过<strong>合并网格</strong>，适用于静态的物体，如将不会移动的地面合并。当然也可以对动态物体进行批处理，但是这些物体是不断移动的，因此每一帧都需要进行合并，这也会造成一定的性能开销。</p>
<p>为了减少Draw Call，需要注意：</p>
<ul>
<li>尽量避免使用大量很小的网格，如果不可避免，那么可以考虑合并他们</li>
<li>尽量避免使用过多的材质，在不同的网格之间使用相同的材质。</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="1-5-Shader在渲染流水线中扮演的角色"><a href="#1-5-Shader在渲染流水线中扮演的角色" class="headerlink" title="1.5 - Shader在渲染流水线中扮演的角色"></a>1.5 - Shader在渲染流水线中扮演的角色</h3><ul>
<li>Shader是GPU流水线上的一些可高度编程的阶段，由Shader编译出来的代码最终会运行在GPU上。</li>
<li>有一些特定的着色器：顶点着色器、片元着色器</li>
<li>依靠Shader我们可以控制渲染流水线上的细节，如使用<strong>顶点着色器</strong>来进行<strong>顶点变换</strong>或者<strong>传递数据</strong>，使用<strong>片元着色器</strong>来进行<strong>逐像素的渲染</strong>。</li>
</ul>
<h2 id="2-Unity-Shader基础"><a href="#2-Unity-Shader基础" class="headerlink" title="2 - Unity Shader基础"></a>2 - Unity Shader基础</h2><h3 id="2-1-Unity-Shader-概述"><a href="#2-1-Unity-Shader-概述" class="headerlink" title="2.1 - Unity Shader 概述"></a>2.1 - Unity Shader 概述</h3><blockquote>
<p><strong>参考资料</strong></p>
<p>Writing Your First Shader In Unity - Rendering In Unity：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ZNvEM76Zi-c&amp;list=PLX2vGYjWbI0RS_lkb68ApE2YPcZMC4Ohz&amp;index=2">https://www.youtube.com/watch?v=ZNvEM76Zi-c&amp;list=PLX2vGYjWbI0RS_lkb68ApE2YPcZMC4Ohz&amp;index=2</a></p>
</blockquote>
<p><img src="/image/UnityShaderLearning/image-20230628171902384.png" alt="image-20230628171902384"></p>
<p>一个完整的渲染过程需要包括以下资产：<strong>3D模型</strong>、<strong>材质</strong>以及<strong>Shader</strong></p>
<ul>
<li>其中，<strong>3D模型</strong>包含<strong>顶点</strong>、<strong>顶点颜色</strong>、<strong>UV数据</strong>以及<strong>法线</strong>。</li>
<li>在Unity中，要渲染的游戏对象带有添加了<strong>材质</strong>的<strong>Mesh Render</strong>渲染器，<strong>材质</strong>声明了使用的Shader、纹理贴图、颜色以及属性信息。</li>
<li><strong>Shader</strong>使用来自<strong>3D模型</strong>和<strong>材质</strong>中的信息，使用<strong>CG/HLSL</strong>代码在屏幕上绘制像素。</li>
</ul>
<p><img src="/image/UnityShaderLearning/image-20230628173214190.png" alt="image-20230628173214190"></p>
<ul>
<li><strong>Shader</strong>是一种计算机程序，在渲染过程中用于进行着色：在图像中产生适当的光亮、暗淡和颜色，或者在现代也用于产生特殊的平面效果或进行视频后期处理（如图像效果）。</li>
<li><strong>Shader</strong>是一个专门在GPU上运行的程序。它最终用于绘制你的3D模型的三角面。</li>
</ul>
<p>一个<strong>Unity Shader</strong>的基本结构如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">    	//属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">       //显卡A使用的子着色器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-SubShader"><a href="#2-2-SubShader" class="headerlink" title="2.2 - SubShader"></a>2.2 - SubShader</h3><p>Unity可以包含多个<strong>SubShader</strong>语义，但至少要有一个。<strong>SubShader</strong>定义了一些列的<strong>Pass</strong>以及状态（**[RenderSetup]<strong>）、标签（</strong>[Tag]<strong>）的设置。如果</strong>Pass**的数目过多，会造成性能的下降。</p>
<blockquote>
<p>Unity会选择<strong>第一个</strong>能够在目标平台上运行的SubShader，如果都不支持的话就会使用<strong>Fallback</strong>语义中指定的Unity Shader。这样做的好处是能够在新旧的显卡上面呈现不同计算复杂度的画面。</p>
</blockquote>
<p>以下是<strong>SubShader</strong>语义块包含的内容：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShder&#123;</span><br><span class="line">	[Tags]			//可选</span><br><span class="line">	[RenderSetup]  	//可选</span><br><span class="line">	Pass&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	//Other Pass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-2-1-状态设置"><a href="#2-2-1-状态设置" class="headerlink" title="2.2.1 - 状态设置"></a>2.2.1 - 状态设置</h4><ul>
<li><strong>状态设置：</strong>ShaderLab提供的一系列渲染状态的设置指令，例如是否开启混合/深度测试。</li>
</ul>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>设置指令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Cull</td>
<td>Cull Back| Front |Off</td>
<td>设置剔除指令，剔除背面/正面/关闭剔除</td>
</tr>
<tr>
<td>ZTest</td>
<td>ZTest Less Greater | LEqual | GEqual | NotEqual | Always</td>
<td>设置深度测试时使用的函数</td>
</tr>
<tr>
<td>ZWrite</td>
<td>ZWrite On | Off</td>
<td>开启/关闭深度写入</td>
</tr>
<tr>
<td>Blend</td>
<td>Blend SrcFactor DstFactor</td>
<td>开启并设置混合模式</td>
</tr>
</tbody></table>
<blockquote>
<p>当在SubShader中设置了上面的渲染状态之后，会应用到<strong>所有的Pass中</strong>，如果不想这样，那么可以在Pass中单独设置。</p>
</blockquote>
<ul>
<li><p><code>ZWrite off</code>：这是深度写入（Z写入）的设置。将其设置为<code>off</code>表示在渲染此Shader时不会写入深度缓冲区。这意味着该对象将不会对后续的渲染产生深度测试的影响，而是始终绘制在已经渲染的像素之上，不考虑深度。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-ZWrite.html">https://docs.unity3d.com/Manual/SL-ZWrite.html</a></p>
</blockquote>
</li>
<li><p><code>Blend SrcAlpha OneMinusSrcAlpha</code>：这是混合（Blending）的设置。它指定了使用源颜色的alpha通道和目标颜色的反相alpha通道进行混合。具体来说，<code>SrcAlpha</code>表示使用源颜色的alpha通道作为混合因子，<code>OneMinusSrcAlpha</code>表示使用目标颜色的反相alpha通道作为混合因子。这种混合方式常用于实现半透明效果，源颜色会根据其alpha值与背景进行混合，产生透明效果。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/530/Documentation/Manual/SL-Blend.html">https://docs.unity3d.com/530/Documentation/Manual/SL-Blend.html</a></p>
</blockquote>
</li>
</ul>
<h4 id="2-2-2-标签"><a href="#2-2-2-标签" class="headerlink" title="2.2.2 - 标签"></a>2.2.2 - 标签</h4><ul>
<li><strong>标签：</strong>SubShader的标签（**[Tag]<strong>）是一个键值对，它用来告诉Unity希望</strong>怎样<strong>以及</strong>何时**渲染这个对象。</li>
</ul>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Queue</td>
<td>控制渲染顺序</td>
<td>Tags { “Queue”=”Transparent” }</td>
</tr>
<tr>
<td>RenderType</td>
<td>对着色器进行分类,例如用来区别透明和不透明着色器</td>
<td>Tags { “RenderType”=”Opaque” }</td>
</tr>
<tr>
<td>DisableBatching</td>
<td>一些SubShader在只要批处理会出现问题，例如使用了模型空间下的坐标进行顶点动画。这时可以通过此标签来取消该SubShader对于批处理的使用。</td>
<td>Tags { “DisableBatching”=”True” }</td>
</tr>
<tr>
<td>ForceNoShadowCasting</td>
<td>控制该物体是否会投射阴影</td>
<td>Tags { “ForceNoShadowCasting”=”True” }</td>
</tr>
<tr>
<td>IgnoreProjector</td>
<td>如果该标签为**”True”<strong>，那么该物体不会受</strong>Projector<strong>的影响，通常用于</strong>半透明物体**。</td>
<td>Tags { “IgnoreProjector”=”True” }</td>
</tr>
<tr>
<td>CanUseSpriteAtlas</td>
<td>当该对象是Sprite时，将该标签设置为**”False”**</td>
<td>Tags { “CanUseSpriteAtlas”=”False” }</td>
</tr>
<tr>
<td>PreviewType</td>
<td>指明材质面板该如何预览该材质，例如”Plane“、”Skybox“</td>
<td>Tags { “PreviewType”=”Plane” }</td>
</tr>
</tbody></table>
<h4 id="2-2-3-Pass"><a href="#2-2-3-Pass" class="headerlink" title="2.2.3 - Pass"></a>2.2.3 - Pass</h4><ul>
<li><strong>Pass语义块</strong></li>
</ul>
<p>以下是<strong>Pass</strong>语义块包含的内容：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	[Name]</span><br><span class="line">	[Tag]</span><br><span class="line">	[RenderSetup]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们可以在<strong>Pass</strong>中定义该<strong>Pass</strong>的名称，例如：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name ”MyPassName“</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在<strong>ShaderLab</strong>中，我们可以使用<code>UsePass</code>命令来直接使用其他Unity Shader中的<strong>Pass</strong></p>
<p>例如：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass ”MyShader/MYPASSNAME&quot;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Unity内部会将所有的<strong>Pass</strong>的名称转换成<strong>大写字母</strong>的表示，因此，在使用UsePass命令的时候必须使用大写形式的名字。</p>
</blockquote>
<p>SubShader中的状态设置同样使用与Pass，在Pass中我们还可以使用固定管线的着色器。</p>
<p>在Pass中同样可以设置标签，但是不同于SubShader中的标签。</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>LightMode</td>
<td>定义该Pass在Unity渲染流水线中的角色</td>
<td>Tags { “LightMode”=”ForwardBase” }</td>
</tr>
<tr>
<td>RequireOptions</td>
<td>当满足某些特定条件时才渲染该Pass</td>
<td>Tags { “RequireOptions”=”SoftVegetation” }</td>
</tr>
</tbody></table>
<p>除了上面定义的Pass之外，Unity Shader还支持一些特殊的Pass：</p>
<ul>
<li><strong>UsePass：</strong>可以使用指令来复用其他Shader中的Pass</li>
<li><strong>GrabPass：</strong>负责抓取屏幕并将结果存储在一张纹理中，一边用于后续的Pass处理。</li>
</ul>
<h4 id="2-2-4-Fallback"><a href="#2-2-4-Fallback" class="headerlink" title="2.2.4 - Fallback"></a>2.2.4 - Fallback</h4><p>在各个SubShader语义块之后的，可以是一个Fallback指令，它用于告诉Unity，如果上面的SubShader都无法在这张显卡上运行，那就是用这个最低级的Shader。</p>
<p>它的语句如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fakkback “Name”</span><br><span class="line">Fallback off</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>另外，在渲染阴影纹理时，Unity会在每个Unity Shader中寻找一个阴影投射的Pass，通常情况下，我们不需要专门实现一个Pass，因为Fallback使用的内置Shader会包含这样一个通用的Pass，因此，对每个Unity Shder正确设置一个Fallback是非常重要的。</p>
</blockquote>
<h4 id="2-2-5-其他语义"><a href="#2-2-5-其他语义" class="headerlink" title="2.2.5 - 其他语义"></a>2.2.5 - 其他语义</h4><p>除了上面的语义之外，Unity还包含以下不常用的语义：</p>
<ul>
<li>CustomEditor：自定义材质面板的编辑画面，用来扩展编辑界面</li>
<li>Category：对Unity Shader中的命令进行分组</li>
</ul>
<h3 id="2-3-Unity中的几种着色器类型"><a href="#2-3-Unity中的几种着色器类型" class="headerlink" title="2.3 - Unity中的几种着色器类型"></a>2.3 - Unity中的几种着色器类型</h3><p>以下是Unity中内置的几种着色器：</p>
<ul>
<li><p><strong>表面着色器（Surface Shaders）</strong>采用了代码生成的方法，相比使用低级顶点/像素着色器程序，更容易编写光照着色器。使用基于物理的渲染方法。</p>
<blockquote>
<p>表面着色器是顶点/片元着色器的更高一层的抽象，Unity为我们处理了很多光照细节，我们不需要在计算这些。</p>
<p>以下是一个表面着色器的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/TestSurfaceShader&quot;</span><br><span class="line">&#123;</span><br><span class="line"> Properties</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> SubShader</span><br><span class="line"> &#123;</span><br><span class="line">     Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">     LOD 200</span><br><span class="line"></span><br><span class="line">     CGPROGRAM</span><br><span class="line">     #pragma surface surf Standard fullforwardshadows</span><br><span class="line">     #pragma target 3.0</span><br><span class="line"></span><br><span class="line">     struct Input</span><br><span class="line">     &#123;</span><br><span class="line">         float2 uv_MainTex;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     half _Glossiness;</span><br><span class="line">     half _Metallic;</span><br><span class="line">     fixed4 _Color;</span><br><span class="line"></span><br><span class="line">     UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">     UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">     void surf (Input IN, inout SurfaceOutputStandard o)</span><br><span class="line">     &#123;</span><br><span class="line">         fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">         o.Albedo = c.rgb;</span><br><span class="line">         o.Metallic = _Metallic;</span><br><span class="line">         o.Smoothness = _Glossiness;</span><br><span class="line">         o.Alpha = c.a;</span><br><span class="line">     &#125;</span><br><span class="line">     ENDCG</span><br><span class="line"> &#125;</span><br><span class="line"> FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表面着色器不关心<strong>Pass</strong>，只要使用纹理去填充颜色、法线纹理去填充法线，使用Lambert光照模型，其他的都交给Unity，</p>
<p>Unity还是会把它转换成一个包含多个Pass的顶点/片元着色器。</p>
</blockquote>
</li>
<li><p><strong>无光照着色器（Unlit Shaders）</strong>不与Unity的光源进行交互，适用于特殊效果，灵活性较高。</p>
</li>
<li><p><strong>图像效果着色器（Image Effect Shaders）</strong>通常是一种后期处理效果，它读取源图像，对其进行一些计算，并将结果渲染到提供的目标图像中（例如使用Graphics.Blit）。</p>
</li>
<li><p><strong>计算着色器（Compute Shaders）</strong>是在显卡上运行的程序，独立于正常的渲染流程。它们可用于大规模<strong>并行</strong>的GPU算法，或者加速游戏渲染的某些部分。旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算。</p>
</li>
</ul>
<h2 id="3-Shader-相关数学基础"><a href="#3-Shader-相关数学基础" class="headerlink" title="3 - Shader 相关数学基础"></a>3 - Shader 相关数学基础</h2><h3 id="3-1-笛卡尔坐标系"><a href="#3-1-笛卡尔坐标系" class="headerlink" title="3.1 - 笛卡尔坐标系"></a>3.1 - 笛卡尔坐标系</h3><p>三维中的笛卡尔坐标系并不都是等价的，如果他们具有相同的<strong>旋向性</strong>，那么我们可以通过旋转的方式让他们的坐标轴重合。如果他们具有不同的旋向性，例如下图的左手坐标系和右手坐标系，那么就无法通过旋转的方式让他们的坐标系重合。</p>
<p><img src="/image/UnityShaderLearning/image-20230703103234130.png" alt="image-20230703103234130"></p>
<p>食指朝上，<strong>向上</strong>的方向就是<strong>y轴的正方向</strong>，中指朝前，<strong>向前</strong>的方向就是<strong>z轴的正方向</strong>，剩下的<strong>拇指的方向</strong>就是<strong>x轴的正方向。</strong></p>
<p>在<strong>模型空间</strong>和<strong>世界空间</strong>中，Unity使用的是<strong>左手坐标系</strong>。蓝色代表z轴，绿色代表y轴，红色代表x轴。</p>
<p>但是对于观察空间来说，Unity使用的是<strong>右手坐标系</strong>。</p>
<blockquote>
<p>观察空间是以摄像机为原点的坐标系，摄像机的前向是z轴的负方向，z轴越小，物体深度越大，离摄像机月远。</p>
</blockquote>
<p><img src="/image/UnityShaderLearning/image-20230703105207299.png" alt="image-20230703105207299"></p>
<h2 id="4-Unity-Shader"><a href="#4-Unity-Shader" class="headerlink" title="4 - Unity Shader"></a>4 - Unity Shader</h2><h3 id="4-1-基本的Shader结构"><a href="#4-1-基本的Shader结构" class="headerlink" title="4.1- 基本的Shader结构"></a>4.1- 基本的Shader结构</h3><h4 id="4-1-1-基本Shader代码包含的内容"><a href="#4-1-1-基本Shader代码包含的内容" class="headerlink" title="4.1.1 - 基本Shader代码包含的内容"></a>4.1.1 - 基本Shader代码包含的内容</h4><p>基本的一个Unlit Shader代码包含以下内容：</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Test&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br></pre></td></tr></table></figure>

<p>他们将告诉Unity，哪个函数包含了顶点着色器的代码，哪个函数包含了片元着色器的代码。</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>vert函数的输入<strong>v</strong>包含了这个顶点的<strong>位置和UV</strong>，他们是由<strong>POSITION</strong>和<strong>TEXCOORD0</strong>指定的，他们都是<strong>CG/HLSL</strong>中的<strong>语义</strong>。</p>
<p><strong>POSITION</strong>告诉Unity，把模型的顶点坐标填充到<strong>appdata</strong>中的参数<strong>vertex</strong>中，<strong>SV_POSITION</strong>告诉Unity，<strong>v2f</strong>中的<strong>vertex</strong>就是<strong>裁剪空间</strong>中的顶点坐标。</p>
<p><strong>v2f</strong>的含义是把顶点着色器的数据传输到片元着色器中：Vertex to Fragment。</p>
</blockquote>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// sample the texture</span></span><br><span class="line"> fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line"> <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>冒号（:）后面的**”SV_Target”<strong>表示此函数的返回值将被写入到指定的</strong>渲染目标（Render Target）<strong>中。在这种情况下，它指示将片段着色器（frag）的输出颜色写入到默认的渲染目标（通常是屏幕上的像素缓冲区）中。这里返回了一个表示</strong>纹理颜色<strong>的</strong>fixed4**类型的变量</li>
<li>在Unity的着色器中，片段着色器负责计算每个像素的颜色输出。通过使用**”SV_Target”**语义，我们可以指定将这个输出颜色写入到哪个渲染目标中，从而控制着色器的渲染结果在场景中的影响位置。</li>
<li>需要注意的是，这段代码中使用了默认的”SV_Target”语义，这意味着输出颜色将直接写入默认的渲染目标。在特定的渲染管线或自定义渲染流程中，可以使用其他语义来指定不同的渲染目标。</li>
</ul>
</blockquote>
<h4 id="4-1-2-获取模型数据"><a href="#4-1-2-获取模型数据" class="headerlink" title="4.1.2 - 获取模型数据"></a>4.1.2 - 获取模型数据</h4><p>我们可以使用纹理坐标来访问纹理，法线可以用于计算光照。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct appdata &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过声明一个新的结构体<strong>appdata</strong>，它包含了顶点着色器需要的模型数据。</p>
<p>对应顶点着色器的输出，Unity支持的语义有：<strong>POSITION</strong>, <strong>TANGENT</strong> , <strong>NORMAL</strong>，<strong>TEXCOORD0</strong>,<strong>TEXCOORD1</strong>, <strong>TEXCOORD2</strong>， <strong>TEXCOORD3</strong>,<strong>COLOR</strong>等</p>
<p>填充到<strong>POSITION</strong>、<strong>NORMAL</strong>、<strong>TEXCOORD0</strong>中的数据是由<strong>材质</strong>的<strong>Mesh Render</strong>组件提供的。</p>
<p>在调用<strong>Draw Call</strong>的时候，<strong>Mesh Render</strong>会将他负责渲染的模型数据发送给Unity Shader。</p>
<p>一个模型通常包含一组<strong>三角面片</strong>，每个三角面由3个顶点构成，而每个顶点又包含了一些数据，如：<strong>顶点位置、法线、切线、纹理位置、顶点颜色等。</strong></p>
</blockquote>
<h4 id="4-1-3-顶点着色器与片元着色器之间的通信"><a href="#4-1-3-顶点着色器与片元着色器之间的通信" class="headerlink" title="4.1.3 - 顶点着色器与片元着色器之间的通信"></a>4.1.3 - 顶点着色器与片元着色器之间的通信</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    fixed3 color : COLOR0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>v2f用于在顶点着色器与片元着色器之间传递信息。</p>
<p>我们使用了<strong>SV_POSITION</strong>和<strong>COLOR0</strong>语义，顶点着色器的输出结构中，必须包含一个变量，它的语义是<strong>SV_POSITION</strong>。<strong>COLOR0</strong>语义中的数据可以由用户自行定义，但一般都是存储颜色，例如逐顶点的漫反射颜色或逐顶点的高光反射颜色。类似的语义还有<strong>COLOR0</strong>。</p>
<p>顶点着色器是逐顶点调用的，而片元着色器是逐片元调用的，片元着色器的输入实际上是把顶点着色器的输入进行插值后得到的结果。</p>
</blockquote>
<h4 id="4-1-4-属性"><a href="#4-1-4-属性" class="headerlink" title="4.1.4 - 属性"></a>4.1.4 - 属性</h4><p>Shader Lab中的属性类型和CG之间变量类型之间的匹配关系：</p>
<table>
<thead>
<tr>
<th align="center">Shader Lab属性类型</th>
<th align="center">CG变量类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Color，Vector</td>
<td align="center">float4，half4，fixed4</td>
</tr>
<tr>
<td align="center">Range，Float</td>
<td align="center">float，half，fixed</td>
</tr>
<tr>
<td align="center">2D</td>
<td align="center">sample2D</td>
</tr>
<tr>
<td align="center">Cube</td>
<td align="center">sampleCube</td>
</tr>
<tr>
<td align="center">3D</td>
<td align="center">sample3D</td>
</tr>
</tbody></table>
<h3 id="4-2-Unity内置文件和变量"><a href="#4-2-Unity内置文件和变量" class="headerlink" title="4.2 - Unity内置文件和变量"></a>4.2 - Unity内置文件和变量</h3><p>为了方便开发，Unity提供了很多内置文件，包含许多提前定义的函数、变量、宏等。</p>
<blockquote>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;UnityCG.cginc&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们可以前往官网下载，选择下载Built-in Shader。</p>
<blockquote>
<p>下载地址：<a target="_blank" rel="noopener" href="https://unity.com/releases/editor/archive">https://unity.com/releases/editor/archive</a></p>
</blockquote>
<p>以下是下载的Shader中<strong>CGIncludes</strong>文件夹中中主要包含的文件以及它们的主要用处：</p>
<table>
<thead>
<tr>
<th align="center">文件名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UnityCG.cginc</td>
<td align="center">包含了最常使用的帮助函数、宏和结构体等</td>
</tr>
<tr>
<td align="center">UnityShader Variables.cginc</td>
<td align="center">在编译Unity Shader 时，会被自动包含进来。包含了许多内置的全局变量，如UNITY_MATRIX MVP等</td>
</tr>
<tr>
<td align="center">Lighting.cginc</td>
<td align="center">包含了各种内置的光照模型，如果编写的是Surface Shader的话，会自动包含进来</td>
</tr>
<tr>
<td align="center">HLSLSupport.cginc</td>
<td align="center">在编译Unity Shader时，会被自动包含进来。声明了很多用于跨平台编译的宏和定义</td>
</tr>
</tbody></table>
<p><strong>UnityCG.cginc</strong>是我们最常接触的文件，我们可以直接使用其中预定义的<strong>结构体</strong>作为顶点着色器的输入和输出。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>包含的变量</th>
</tr>
</thead>
<tbody><tr>
<td>appdata_base</td>
<td>可用于顶点着色器的输入</td>
<td>顶点位置、顶点法线、第一组纹理坐标</td>
</tr>
<tr>
<td>appdata_tan</td>
<td>可用于顶点着色器的输入</td>
<td>顶点位置、顶点切线、顶点法线、第一组纹理坐标</td>
</tr>
<tr>
<td>appdata_full</td>
<td>可用于顶点着色器的输入</td>
<td>顶点位置、顶点切线、顶点法线、四组(或更多）纹理坐标</td>
</tr>
<tr>
<td>appdata_img</td>
<td>可用于顶点着色器的输入</td>
<td>顶点位置、第一组纹理坐标</td>
</tr>
<tr>
<td>v2f_img</td>
<td>可用于顶点着色器的输出</td>
<td>裁剪空间中的位置、纹理坐标</td>
</tr>
</tbody></table>
<p><strong>UnityCG.cginc</strong>，还提供了许多常见的帮助函数以及用于访问时间、光照、雾效和环境光等目的的变量。</p>
<h3 id="4-3-Unity支持的语义"><a href="#4-3-Unity支持的语义" class="headerlink" title="4.3 - Unity支持的语义"></a>4.3 - Unity支持的语义</h3><p>从<strong>应用阶段</strong>传递模型数据给<strong>顶点着色器</strong>时Unity支持的语义：</p>
<table>
<thead>
<tr>
<th align="center">语义</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">POSITION</td>
<td align="center">模型空间中的顶点位置，通常是float4类型</td>
</tr>
<tr>
<td align="center">NORMAL</td>
<td align="center">顶点法线，通常是float3类型</td>
</tr>
<tr>
<td align="center">TANGENT</td>
<td align="center">顶点切线，通常是float4类型</td>
</tr>
<tr>
<td align="center">TEXCOORDn，如TEXCOORD0、TEXCOORD1</td>
<td align="center">该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依此类推。通常是float2或float4类型</td>
</tr>
<tr>
<td align="center">COLOR</td>
<td align="center">顶点颜色，通常是 fixed4或float4类型</td>
</tr>
</tbody></table>
<blockquote>
<p>其中 TEXCOORDn 中n的数目是和 Shader Model有关的,例如一般在 Shader Model 2（即Unity默认编译到的Shader Model 版本）和Shader Model 3中，n等于8，而在Shader Model 4和Shader Model 5中，n等于16。通常情况下，一个模型的纹理坐标组数一般不超过2，即我们往往只使用TEXCOORDO和 TEXCOORD1。在Unity内置的数据结构体appdata_full 中，它最多使用了6个坐标纹理组。</p>
</blockquote>
<p>从<strong>顶点着色器</strong>传递模型数据给<strong>片元着色器</strong>时Unity支持的语义：</p>
<table>
<thead>
<tr>
<th align="center">语义</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SV_POSITION</td>
<td align="center">裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于DirectX 9中的POSITION，但最好使用SV_POSITION</td>
</tr>
<tr>
<td align="center">COLOR 0</td>
<td align="center">通常用于输出第一组顶点颜色，但不是必需的</td>
</tr>
<tr>
<td align="center">COLOR 1</td>
<td align="center">通常用于输出第二组顶点颜色，但不是必需的</td>
</tr>
<tr>
<td align="center">TEXCOORD0～TEXCOORD7</td>
<td align="center">通常用于输出纹理坐标,但不是必需的</td>
</tr>
</tbody></table>
<blockquote>
<p>上面的语义中，除了SV_POSITION是有特别含义外，其他语义对变量的含义没有明确要求,<br>也就是说，我们可以存储任意值到这些语义描述变量中。通常，如果我们需要把一些自定义的数据从顶点着色器传递给片元着色器，一般选用TEXCOORDO等。</p>
</blockquote>
<p>片元着色器输出时Unity支持的语义：</p>
<table>
<thead>
<tr>
<th align="center">语义</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SV_Target</td>
<td align="center">输出值将会存储到渲染目标（render target）中。等同于DirectX 9中的COLOR语义，但最好使用SV_Target</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，一个语义可以使用的寄存器只能处理<strong>4个</strong>浮点值（float）。因此,如果我们想要定义矩阵类型，如 <strong>float3×4</strong>、<strong>float4×4</strong>等变量就需要使用更多的空间。一种方法是，把这些变量拆分成多个变量，例如对于<strong>float4×4</strong>的矩阵类型，我们可以<strong>拆分成4个float4类型的变量</strong>,每个变量存储了矩阵中的一行数据。</p>
</blockquote>
<h3 id="4-4-Debug"><a href="#4-4-Debug" class="headerlink" title="4.4 - Debug"></a>4.4 - Debug</h3><ul>
<li>使用假彩色图片</li>
<li>使用Visual Studio中的Graphics Debugger</li>
<li>使用Unity中的<strong>帧调试器</strong></li>
</ul>
<h4 id="4-4-1-帧调试器"><a href="#4-4-1-帧调试器" class="headerlink" title="4.4.1 - 帧调试器"></a>4.4.1 - 帧调试器</h4><p>Unity中的帧调试器可以让我们看到游戏图像中的某一帧是如何一步步渲染出来的。</p>
<p>可以从<code>Window -&gt; Analysis -&gt; Frame Debugger</code>打开帧调试器。</p>
<blockquote>
<p>帧调试器可以用于查看渲染该帧时进行的各种<strong>渲染事件（event)<strong>，这些事件包含了</strong>Draw Call序列</strong>，也包括了类似清空帧缓存等操作。帧调试器窗口大致可分为3个部分:最上面的区域可以开启/关闭(单击 Enable 按钮）帧调试功能，当开启了帧调试时，通过移动窗口最上方的滑动条(或单击前进和后退按钮)，我们可以重放这些渲染事件;<br>左侧的区域显示了所有事件的树状图,在这个树状图中,每个叶子节点就是一个事件,而每个父节点的右侧显示了该节点下的事件数目。我们可以从事件的名字了解这个事件的操作，例如以 Draw开头的事件通常就是一个Draw Call;当单击了某个事件时，在右侧的窗口中就会显示出该事件的细节，例如几何图形的细节以及使用了哪个Shader等。同时在Game视图中我们也可以看到它的效果。如果该事件是一个 Draw Call并且对应了场景中的一个GameObject,那么这个GameObject也会在Hierarchy视图中被高亮显示出来。</p>
</blockquote>
<blockquote>
<p>如果被选中的Draw Call是对一个渲染纹理（RenderTexture）的渲染操作，那么这个渲染纹理就会显示在 Game视图中。而且，此时右侧面板上方的工具栏中也会出现更多的选项，例如在Game视图中单独显示R、G、B和A通道。<br>Unity提供的帧调试器实际上并没有实现一个真正的<strong>帧拾取（frame capture）</strong>功能，而是仅仅使用<strong>停止渲染</strong>的方法来查看渲染事件的结果。例如，如果我们想要查看第4个Draw Call 的结果，那么帧调试器就会在第4个 Draw Call 调用完毕后停止渲染。这种方法虽然简单，但得到的信息也很有限。如果想要获取更多的信息,还是需要使用外部工具，例如VisualStudio 插件，或者 Intel GPA、RenderDoc、NVIDIA NSight、AMD GPU PerfStudio等工具。</p>
</blockquote>
<h3 id="4-5-小心：渲染平台的差异"><a href="#4-5-小心：渲染平台的差异" class="headerlink" title="4.5 - 小心：渲染平台的差异"></a>4.5 - 小心：渲染平台的差异</h3><h4 id="4-5-1-渲染纹理的坐标差异"><a href="#4-5-1-渲染纹理的坐标差异" class="headerlink" title="4.5.1 - 渲染纹理的坐标差异"></a>4.5.1 - 渲染纹理的坐标差异</h4><p>OpenGL和DirectX的屏幕空间坐标存在差异，但是Unity会在背后为我们处理，翻转屏幕图像纹理，以达到在不同平台的一致性。</p>
<ul>
<li><p>有一种情况下Unity不会为我们进行这个反转操作，这种情况是我们开启了抗锯齿。</p>
<p>在<code>Edit -&gt; Project Settings -&gt; Quality -&gt; Anti Aliasing</code>中开启</p>
</li>
</ul>
<blockquote>
<p>在这种种情况下，Unity 首先渲染得到屏幕图像，再由<strong>硬件进行抗锯齿处理</strong>后，得到一张渲染纹理来供我们进行后续处理。此时，在 DirectX平台下，我们得到的输入屏幕图像并不会被Unity翻转，也就是说，此时对屏幕图像的采样坐标是需要符合 DirectX平台规定的。如果我们的屏幕特效只需要处理一张渲染图像，我们仍然不需要在意纹理的翻转问题，这是因为在我们调用<code>Graphics.Blt</code>函数时，Unity已经为我们对屏幕图像的采样坐标进行了处理，我们只需要按正常的采样过程处理屏幕图像即可。但如果我们需要同时处理多张渲染图像(前提是开启了抗锯齿)，例如需要同时处理屏幕图像和法线纹理，这些图像在竖直方向的朝向就可能是不同的(只有在 DirectX这样的平台上才有这样的问题)。这种时候，我们就需要自己在顶点着色器中翻转某些渲染纹理（例如深度纹理或其他由脚本传递过来的纹理）的纵坐标，使之都符合DirectX平台的规则。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if UNITY_UV_STARTS_AT_TOP</span><br><span class="line">if(_MainTex_TexelSize.y &lt; 0)</span><br><span class="line">	uv.y= 1-uv.y;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>其中，<strong>UNITY_UV_STARTS_AT_TOP</strong> 用于判断当前平台是否是DirectX类型的平台，而当在这样的平台下开启了抗锯齿后，主纹理的纹素大小在竖直方向上会变成负值，以方便我们对主纹理进行正确的采样。因此，我们可以通过判断 <code>MainTex_TexelSize.x</code>是否小于0来检验是否开启了抗锯齿。如果是，我们就需要对除主纹理外的其他纹理的采样坐标进行竖直方向上的翻转。</p>
</blockquote>
<blockquote>
<p>在本书资源的项目中，我们开启了抗锯齿选项。在第12章中，我们将学习一些基本的<strong>屏幕后处理效果</strong>。这些效果大多使用了单张屏幕图像进行处理，因此我们不需要考虑平台差异化的问题，因为Unity已经在背后为我们处理过了。但在12.5节中，我们<strong>需要在一个Pass 中同时处理屏幕图像和提取得到的亮部图像来实现Bloom效果。由于需要同时处理多张纹理，因此在 DirectX这样的平台下如果开启了抗锯齿，主纹理和亮部纹理在竖直方向上的朝向就是不同的，我们就需要对亮部纹理的采样坐标进行翻转。</strong>在第13章中，<strong>我们需要同时处理屏幕图像和深度/法线纹理来实现一些特殊的屏幕效果，在这些处理过程中，我们也需要进行</strong><br><strong>一些平台差异化处理。</strong>在15.3节中,尽管我们也在一个 Pass中同时处理了屏幕图像、深度纹理和一张噪声纹理，但我们只对深度纹理的采样坐标进行了平台差异化处理，而没有对噪声纹理进行处理。这是因为，类似噪声纹理的装饰性纹理，它们在竖直方向上的朝向并不是很重要，即便翻转了效果往往也是正确的，因此我们可以不对这些纹理进行平台差异化处理。</p>
</blockquote>
<p>除此之外，还有Shader语法和语义的差异。</p>
<h4 id="4-5-2-语法差异"><a href="#4-5-2-语法差异" class="headerlink" title="4.5.2 - 语法差异"></a>4.5.2 - 语法差异</h4><ul>
<li><p>在表面着色器的顶点函数中，用了一个没有初始化的out修饰符参数</p>
<blockquote>
<p>可以使用以下代码对这些参数进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void vert (inout appdata full v, out Input o)&#123;</span><br><span class="line">//使用Unity内置的UNITY_INITIALIZE_OUTPUT宏对输出结构体o进行初始化</span><br><span class="line">	UNITY_INITIALIZE__OUTPUT ( Input, o);</span><br><span class="line">//.…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>DirectX 9/11 不支持在顶点着色器中使用<strong>tex2D函数</strong>，因为在这个阶段Shader无法得到UV的偏导，而<strong>tex2D函数</strong>需要得到这个骗到，因此我们需要使用<strong>tex2Dlod函数</strong>来替代</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tex2Dlod(tex, float4(uv, 0,0)).</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h4 id="4-5-3-语义差异"><a href="#4-5-3-语义差异" class="headerlink" title="4.5.3 - 语义差异"></a>4.5.3 - 语义差异</h4><p>我们应该遵循以下语义来描述Shader的输入和输出变量</p>
<ul>
<li>使用<strong>SV_POSITION</strong>来描述顶点着色器输出的顶点位置。一些Shader使用了 <strong>POSITION</strong> 语义，但这些Shader无法在索尼PS4平台上或使用了细分着色器的情况下正常工作。</li>
<li>使用<strong>SV_Target</strong>来描述片元着色器的输出颜色。一些Shader使用了<strong>COLOR</strong>或者<strong>COLOR0</strong>语义,同样的,这些Shader无法在索尼PS4上正常工作。</li>
</ul>
<h3 id="4-6-Shader简洁之道"><a href="#4-6-Shader简洁之道" class="headerlink" title="4.6 - Shader简洁之道"></a>4.6 - Shader简洁之道</h3><ul>
<li>根据平台选择合适的精度</li>
<li>规范语法</li>
<li>避免不必要的计算</li>
<li>慎用分支和循环语句</li>
<li>不要除以0</li>
</ul>
<h4 id="4-6-1-精度的选择"><a href="#4-6-1-精度的选择" class="headerlink" title="4.6.1- 精度的选择"></a>4.6.1- 精度的选择</h4><p>在CG/HLSL中，以下几种精度数值：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">精度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">最高精度的浮点值。通常使用32位来存储</td>
</tr>
<tr>
<td align="center">half</td>
<td align="center">中等精度的浮点值。通常使用16位来存储，精度范围是-60000～+60 000</td>
</tr>
<tr>
<td align="center">fixed</td>
<td align="center">最低精度的浮点值。通常使用11位来存储，精度范围是-2.0～+2.0</td>
</tr>
</tbody></table>
<ul>
<li>大多数现代的桌面GPU 会把所有计算都按最高的浮点精度进行计算，也就是说，float、half、 fixed在这些平台上实际是等价的。这意味着,我们在PC上很难看出因为 half和fixed精度而带来的不同。</li>
<li>但在移动平台的GPU上，它们的确会有不同的精度范围，而且不同精度的浮点值的运算速度也会有所差异。因此，我们应该确保在真正的移动平台上验证我们的Shader 。</li>
<li>fixed精度实际上只在一些较旧的移动平台上有用，在大多数现代的GPU上，它们内部把fixed和 half当成同等精度来对待。</li>
</ul>
<p>尽管有上面的不同,但一个基本建议是，尽可能使用精度较低的类型,因为这可以优化 Shader的性能，这一点在<strong>移动平台</strong>上尤其重要。从它们大体的值域范围来看，我们可以使用<strong>fixed</strong>类型来存储<strong>颜色</strong>和<strong>单位矢量</strong>，如果要存储更大范围的数据可以选择<strong>half</strong>类型，<strong>最差情况</strong>下再选择使用float。如果我们的目标平台是移动平台，一定要确保在真实的手机上测试我们的Shader，这一点非常重要。</p>
<h4 id="4-6-2-避免不必要的计算"><a href="#4-6-2-避免不必要的计算" class="headerlink" title="4.6.2 - 避免不必要的计算"></a>4.6.2 - 避免不必要的计算</h4><p>当出现以下报错时：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temporary register limit of 8 exceeded</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arithmetic instruction limit of 64 exceeded; 65 arithmetic instructions needed to compileprogram</span><br></pre></td></tr></table></figure>
</blockquote>
<p>出现这些错误信息大多是因为我们在Shader中进行了过多的运算，使得需要的临时寄存器数目或指令数目超过了当前可支持的数目。需要知道的是，不同的<strong>Shader Target</strong>、<strong>不同的着色器阶段</strong>，我们可使用的临时寄存器和指令数目都是不同的。<br>通常，我们可以通过指定更高等级的 <strong>Shader Target</strong>来消除这些错误。</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#pragma target 2.0</td>
<td align="center">默认的 Shader Target等级。相当于Direct3D9上的Shader Model 2.0</td>
</tr>
<tr>
<td align="center">#pragma target 3.0</td>
<td align="center">相当于 Direct3D 9上的 Shader Model 3.0</td>
</tr>
<tr>
<td align="center">#pragma target 4.0</td>
<td align="center">相当于Direct3D 10上的Shader Model 4.0。目前只在 DirectX 11和 XboxOne/PS4平台上提供了</td>
</tr>
<tr>
<td align="center">#pragma target 5.0</td>
<td align="center">相当于Direct3D 11上的Shader Model 5.0。目前只在 DirectX 11和XboxOne/PS4平台上提供了</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，所有类似OpenGL 的平台（包括移动平台）被当成是支持到Shader Model 3.0的。而WP8/WinRT平台则只支持到Shader Model 2.0。</p>
<ul>
<li><p>什么是 Shader Model 呢?</p>
</li>
<li><p>Shader Model是由微软提出的一套规范,通俗地理解就是它们决定了Shader中各个<strong>特性(feature)<strong>的</strong>能力(capability)<strong>。这些特性和能力体现在Shader能使用的运算指令数目、寄存器个数等各个方面。</strong>Shader Model等级越高，Shader的能力就越大。</strong></p>
</li>
</ul>
<p>虽然更高等级的Shader Target可以让我们使用更多的临时寄存器和运算指令，但一个更好的方法是尽可能减少Shader 中的运算，或者通过预计算的方式来提供更多的数据。</p>
</blockquote>
<h4 id="4-6-3-慎用分支和循环语句"><a href="#4-6-3-慎用分支和循环语句" class="headerlink" title="4.6.3- 慎用分支和循环语句"></a>4.6.3- 慎用分支和循环语句</h4><p>如果我们在Shader中使用了大量的流程控制语句，那么这个 Shader的性能可能会成倍下降。一个解决方法是，<strong>我们应该尽量把计算向流水线上端移动</strong>，例如把放在<strong>片元着色器中的计算放到顶点着色器中</strong>，或者<strong>直接在CPU中进行预计算，再把结果传递给Shader</strong>。当然，有时我们不可避免地要使用分支语句来进行运算,那么一些建议是:</p>
<ul>
<li>分支判断语句中使用的条件变量最好是常数，即在Shader运行过程中不会发生变化;</li>
<li>每个分支中包含的操作指令数尽可能少;</li>
<li>分支的嵌套层数尽可能少。</li>
</ul>
<h2 id="5-Unity-中的基础光照"><a href="#5-Unity-中的基础光照" class="headerlink" title="5 - Unity 中的基础光照"></a>5 - Unity 中的基础光照</h2><blockquote>
<p>如何决定一个像素的颜色，从宏观上看，渲染包含两大部分：</p>
<ul>
<li>决定一个像素的可见性</li>
<li>决定这个像素上的光照计算</li>
</ul>
<p>光照模型就是用于决定这个像素上的光照计算</p>
</blockquote>
<h3 id="5-1-模拟现实中的光照环境"><a href="#5-1-模拟现实中的光照环境" class="headerlink" title="5.1 - 模拟现实中的光照环境"></a>5.1 - 模拟现实中的光照环境</h3><p>要模拟真实的光照环境，需要考虑一下三种物理现象：</p>
<ul>
<li>光线从<strong>光源</strong>中被发射出来</li>
<li>光线与场景中的物体相交，一部分被<strong>吸收</strong>，一部分被<strong>散射</strong></li>
<li>摄像机吸收光线，产生了图像</li>
</ul>
<h4 id="5-1-1-光源"><a href="#5-1-1-光源" class="headerlink" title="5.1.1 - 光源"></a>5.1.1 - 光源</h4><p>在光学中，我们使用<strong>辐照度（irradiance）</strong>来量化光。计算物体表明的辐照度可以使用<strong>光源方向l</strong>和<strong>表面法线n</strong>之间的夹角的<strong>余弦值</strong>来得到。</p>
<h4 id="5-1-2-吸收和散射"><a href="#5-1-2-吸收和散射" class="headerlink" title="5.1.2 - 吸收和散射"></a>5.1.2 - 吸收和散射</h4><p>光线由光源发射出来后，就会与一些物体相交。通常，相交的结果有两个:<strong>散射(scattering)<strong>和</strong>吸收（absorption)</strong><br><strong>散射</strong>只改变光线的<strong>方向</strong>，但不改变光线的密度和颜色。而<strong>吸收</strong>只改变光线<strong>的密度和颜色</strong>，但不改变光线的方向。</p>
<blockquote>
<p>光线在物体表面经过散射后,有两种方向:一种将会散射到物体内部，这种现象被称为<strong>折射（refraction）</strong>或<strong>透射（transmission)</strong>;另一种将会散射到外部，这种现象被称为**反射（reflection)**。</p>
<p>对于不透明物体，折射进入物体内部的光线还会继续与内部的颗粒进行相交,其中一些光线最后会重新发射出物体表面，而另一些则被物体吸收。那些从物体表面重新发射出的光线将具有和入射光线不同的方向分布和颜色。</p>
</blockquote>
<p>为了区分两种不同的散射方向，我们在<strong>光照模型</strong>中使用了不同的部分来计算它们:<strong>高光反射(specular)<strong>部分表示物体表面是如何反射光线的，而</strong>漫反射（diffuse）</strong>部分则表示有多少光线会被折射、吸收和散射出表面。</p>
<h4 id="5-1-3-着色"><a href="#5-1-3-着色" class="headerlink" title="5.1.3 - 着色"></a>5.1.3 - 着色</h4><p>着色指的是根据材质属性、光源信息，使用一个等式去计算某个观察方向的出射度的过程，也成为光照模型。</p>
<h4 id="5-1-3-BRDF光照模型"><a href="#5-1-3-BRDF光照模型" class="headerlink" title="5.1.3 - BRDF光照模型"></a>5.1.3 - BRDF光照模型</h4><p>当光线从某个点照射到一个表面时，有多少光线被反射，反射的方向有哪些，<strong>BRDF（Bidirectional Reflectance Distribution Function）</strong>光照模型就是用来回答这些问题的。</p>
<p>在图形学中，BRDF 大多使用一个数学公式来表示，并且提供了一些参数来调整材质属性。通俗来讲，当给定入射光线的方向和辐照度后，BRDF可以给出在某个出射方向上的</p>
<h3 id="5-2-标准光照模型"><a href="#5-2-标准光照模型" class="headerlink" title="5.2 - 标准光照模型"></a>5.2 - 标准光照模型</h3><h4 id="5-2-1-Phong光照模型"><a href="#5-2-1-Phong光照模型" class="headerlink" title="5.2.1 - Phong光照模型"></a>5.2.1 - Phong光照模型</h4><ul>
<li><p><strong>自发光：</strong>这个部分用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。</p>
<blockquote>
<p>需要注意的是，如果没有使用**全局光照(global illumination)**技术，这些自发光的表面并不会真的照亮周围的物体，而是它本身看起来更亮了而已。</p>
</blockquote>
</li>
<li><p><strong>高光反射：</strong>这个部分用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。</p>
</li>
<li><p><strong>漫反射：</strong>这个部分用于描述，当光线从光源照射到模型表面时,该表面会向每个方向散射多少辐射量。</p>
<blockquote>
<p>漫反射符合兰伯特定律：反射光线的强度与表面法线和光源方向之间的夹角的余弦值成正比</p>
<p>需要注意的是，我们需要防止法线和光源方向点乘的结果为负值，为此，我们使用取最大值的函数来将其截取到0，这可以防止物体被从后面来的光源照亮。</p>
</blockquote>
</li>
<li><p><strong>环境光：</strong>它用于描述其他所有的间接光照。</p>
</li>
</ul>
<h4 id="5-2-2-Blinn-Phong光照模型"><a href="#5-2-2-Blinn-Phong光照模型" class="headerlink" title="5.2.2 - Blinn-Phong光照模型"></a>5.2.2 - Blinn-Phong光照模型</h4><p>Blinn提出了简单的修改办法来得到类似的高光反射效果。在硬件实现时，如果摄像机和光源距离模型足够远的话，Blinn模型会快于Phong模型。</p>
<p>需要注意的是，这两种光照模型都是经验模型。</p>
<h4 id="5-2-3-逐像素还是逐顶点光照"><a href="#5-2-3-逐像素还是逐顶点光照" class="headerlink" title="5.2.3 - 逐像素还是逐顶点光照"></a>5.2.3 - 逐像素还是逐顶点光照</h4><p>以上的光照模型可以在<strong>顶点着色器</strong>中计算，称为逐<strong>顶点光照（per-vertex lighting）</strong>，也可以在<strong>片元着色器</strong>中计算，称为<strong>逐像素光照（per-pixel lighting</strong>）。</p>
<blockquote>
<p>在<strong>逐像素光照</strong>中，我们会以每个像素为基础，得到它的法线(可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的)，然后进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong shading)</strong>,也被称为Phong插值或法线插值着色技术。这不同于我们之前讲到的Phong光照模型。</p>
</blockquote>
<blockquote>
<p>与之相对的是<strong>逐顶点光照</strong>，也被称为<strong>高洛德着色（Gouraud shading)<strong>。在逐顶点光照中，我们在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。由于顶点数目往往远小于像素数目，</strong>因此逐顶点光照的计算量往往要小于逐像素光照</strong>。但是，由于逐顶点光照依赖于线性插值来得到像素光照，因此，当光照模型中有<strong>非线性的计算（例如计算高光反射时）时，逐顶点光照就会出问题</strong>。在后面的章节中，我们将会看到这种情况。而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。</p>
</blockquote>
<p>但这种模型有很多局限性。首先，有很多重要的物理现象无法用Blinn-Phong模型表现出来，例如<strong>菲涅耳反射（Fresnel reflection)<strong>。其次，</strong>Blinn-Phong模型</strong>是<strong>各项同性(isotropic）</strong>的，也就是说，当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。但有些表面是具有<strong>各向异性(anisotropic）</strong>反射性质的，例如拉丝金属、毛发等。</p>
<h3 id="5-3-Unity中的环境光和自发光"><a href="#5-3-Unity中的环境光和自发光" class="headerlink" title="5.3 - Unity中的环境光和自发光"></a>5.3 - Unity中的环境光和自发光</h3><p>在标准光照模型中，环境光和自发光的计算是最简单的。</p>
<ul>
<li>在Unity 中,场景中的<strong>环境光</strong>可以在<code>Window -&gt;Lighting -&gt;Ambient SourcelAmbient ColorlAmbientIntensity</code>中控制</li>
<li>在 Shader中,我们只需要通过Unity 的内置变量<strong>UNITY_LIGHTMODEL_AMBIENT</strong>就可以得到<strong>环境光</strong>的颜色和强度信息。</li>
</ul>
<h3 id="5-4-在Unity中实现漫反射光照模型"><a href="#5-4-在Unity中实现漫反射光照模型" class="headerlink" title="5.4 - 在Unity中实现漫反射光照模型"></a>5.4 - 在Unity中实现漫反射光照模型</h3><p>漫反射的计算公式：<br>$$<br>c_{diffuse} = (c_{light} \cdot m_{diffuse})max(0, \hat{n} \cdot I)<br>$$<br>从公式可以看出，要计算漫反射需要知道4个参数:</p>
<ul>
<li>入射光线的颜色和强度<strong>c_light</strong>，</li>
<li>材质的漫反射系数<strong>m_diffuse</strong>，</li>
<li>表面法线<strong>n</strong></li>
<li>光源方向<strong>I</strong></li>
</ul>
<blockquote>
<p>为了防止点积结果为<strong>负值</strong>，我们需要使用<strong>max操作</strong>，而CG提供了这样的函数。在本例中，使用CG的另一个函数可以达到同样的目的,即<code>saturate</code>函数。</p>
</blockquote>
<h4 id="5-4-1-逐顶点光照的实现"><a href="#5-4-1-逐顶点光照的实现" class="headerlink" title="5.4.1 - 逐顶点光照的实现"></a>5.4.1 - 逐顶点光照的实现</h4><ol>
<li><p>为Shader改名</p>
</li>
<li><p>为了得到漫反射颜色，声明Color类型的属性**_Diffuse**,用于控制漫反射颜色</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">  _Diffuse (&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在Pass中指定光照模式</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>包含Unity内置文件<strong>Lighting.cginc</strong></p>
</li>
<li><p>定义变量，与属性中声明的变量匹配</p>
</li>
<li><p>在appdata和v2f中定义相应的变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> fixed3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : SV_POSITION;</span><br><span class="line"> fixed3 color : COLOR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在顶点着色计算漫反射</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line"></span><br><span class="line"> // 获取环境光</span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> // 将法线方向从物体空间转为剪裁空间</span><br><span class="line"> fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line"> // 获取世界空间下的光线方向</span><br><span class="line"> fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"> // 计算漫反射</span><br><span class="line"> fixed3 diffuse =  _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line"> o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>因为计算都在顶点着色器中完成，片元着色器只要返回颜色值。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;        </span><br><span class="line"> return fixed4(i.color, 1.0);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后添加回调函数</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h4 id="5-4-2-逐像素光照的实现"><a href="#5-4-2-逐像素光照的实现" class="headerlink" title="5.4.2 - 逐像素光照的实现"></a>5.4.2 - 逐像素光照的实现</h4><blockquote>
<p>逐像素光照是在逐顶点光照的基础上，将计算都移到片元着色器中实现。</p>
</blockquote>
<blockquote>
<p>顶点着色器和片元着色器的输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> fixed3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : SV_POSITION;</span><br><span class="line"> float3 worldNormal : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>顶点着色器中只计算法线方向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在片元着色器中完成所有计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> // 获取环境光</span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> // 将法线方向从物体空间转为剪裁空间</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> // 获取世界空间下的光线方向</span><br><span class="line"> fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"> // 计算漫反射</span><br><span class="line"> fixed3 diffuse =  _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line"></span><br><span class="line"> fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line"> return fixed4(color, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-4-3-半兰伯特模型"><a href="#5-4-3-半兰伯特模型" class="headerlink" title="5.4.3 - 半兰伯特模型"></a>5.4.3 - 半兰伯特模型</h4><p><strong>半兰伯特模型的计算公式如下：</strong><br>$$<br>c_{diffuse} = (c_{light} \cdot m_{diffuse})(0.5(0, \hat{n} \cdot I)+0.5)<br>$$</p>
<blockquote>
<p>这个模型没有使用Max函数来防止光线为负，而是将n·I的结果从[-1，1]映射到[0，1]的范围。</p>
<p>这样做的好处是能够使得背光面有明暗变化，而不是死黑。</p>
</blockquote>
<blockquote>
<p>在逐像素光照的基础上，将<strong>saturate</strong>的操作更换成以下操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> // 获取环境光</span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> // 将法线方向从物体空间转为剪裁空间</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> // 获取世界空间下的光线方向</span><br><span class="line"> fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"> // 计算漫反射</span><br><span class="line"> fixed halfLambert = dot(worldNormal,worldLight) * 0.5 + 0.5;</span><br><span class="line"></span><br><span class="line"> fixed3 diffuse =  _LightColor0.rgb * _Diffuse.rgb * halfLambert;</span><br><span class="line"></span><br><span class="line"> fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line"> return fixed4(color, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-5-在Unity中实现高光反射模型"><a href="#5-5-在Unity中实现高光反射模型" class="headerlink" title="5.5 - 在Unity中实现高光反射模型"></a>5.5 - 在Unity中实现高光反射模型</h3><p><strong>高光反射的计算公式如下：</strong><br>$$<br>c_{specular} = (c_{light} \cdot m_{specular})max(0, \hat{v} \cdot r)^{m_{gloss}}<br>$$<br>从上述公式可以得出，计算高光反射需要4个参数：</p>
<ul>
<li>入射光线的颜色和强度<strong>c_light</strong></li>
<li>材质的高光反射系数<strong>m_specular</strong></li>
<li>视角方向的<strong>单位向量v</strong></li>
<li>反射方向<strong>r</strong></li>
</ul>
<blockquote>
<p>反射方向r可以由表面法线的<strong>单位向量n</strong>和光源方向的<strong>单位向量I</strong>得到，</p>
<p>可以直接使用CG提供的函数<code>reflect(i，n)</code>计算得出</p>
</blockquote>
<h4 id="5-5-1-逐顶点光照的实现"><a href="#5-5-1-逐顶点光照的实现" class="headerlink" title="5.5.1 - 逐顶点光照的实现"></a>5.5.1 - 逐顶点光照的实现</h4><ol>
<li><p>首先，在属性声明三个属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _Diffuse (&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line"> _Specular (&quot;Specular&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line"> _Gloss (&quot;&quot;, Range(8.0, 256)) = 20</span><br><span class="line"> //高光区域大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Specular用于控制高光反射的颜色，Gloss用于控制高光区域的大小</p>
</blockquote>
</li>
<li><p>然后指明光照模式</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>指明我们定义的顶点和片元着色器，同时将<code>&quot;Lighting.cginc&quot;</code>包含进来</p>
</li>
<li><p>声明属性变量，并且定义顶点和片元着色器的输入结构体</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> fixed3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : SV_POSITION;</span><br><span class="line"> float3 color : COLOR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在顶点着色器中计算高光反射：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> // 获取环境光</span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> // 将法线方向从物体空间转为剪裁空间</span><br><span class="line"> fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line"> // 获取世界空间下的光线方向</span><br><span class="line"> fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"> //计算漫反射系数</span><br><span class="line"> fixed3 diffuse =  _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line"></span><br><span class="line"> //从世界空间获取反射方向</span><br><span class="line"> fixed3 reflectDir = normalize(reflect(-worldLight, worldNormal));</span><br><span class="line"> //从世界空间获取视觉方向</span><br><span class="line"> fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);</span><br><span class="line"> //计算高光系数</span><br><span class="line"> fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)),_Gloss);</span><br><span class="line"></span><br><span class="line"> o.color = ambient + diffuse + specular;</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>漫反射的部分和上节提到的完全一致，对于高光反射部分，我们首先计算入射光线方向关于表面法线的反射方向<strong>reflectDir</strong>。由于CG的<strong>reflect函数</strong>的入射方向要求是由光源指向交点处的，因此我们需要对 <strong>worldLightDir</strong> 取反后再传给reflect函数。</p>
</li>
<li><p>然后，我们通过**_WorldSpaceCameraPos<strong>得到了世界空间中的摄像机位置，再把顶点位置从模型空间变换到世界空间下，再通过和</strong>_WorldSpaceCameraPos** 相减即可得到世界空间下的视角方向。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>在片元着色器中输出颜色</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> return fixed4(i.color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后设置回调函数</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Specular&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h4 id="5-5-2-逐像素光照的实现"><a href="#5-5-2-逐像素光照的实现" class="headerlink" title="5.5.2 - 逐像素光照的实现"></a>5.5.2 - 逐像素光照的实现</h4><ol>
<li><p>在逐顶点光照的基础上，修改输入结构体：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> fixed3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : SV_POSITION;</span><br><span class="line"> float3 worldNormal : TEXCOORD0;</span><br><span class="line"> float3 worldPos : TEXCOORD1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在顶点着色器中，我们只要计算<strong>世界空间</strong>下的<strong>法线方向</strong>以及<strong>顶点坐标</strong>，并将它们传递给片元着色器即可</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在片元着色器中计算光照模型：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  // 获取环境光</span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> // 将法线方向从物体空间转为剪裁空间</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> // 获取世界空间下的光线方向</span><br><span class="line"> fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"> //计算漫反射系数</span><br><span class="line"> fixed3 diffuse =  _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line"></span><br><span class="line"> //从世界空间获取反射方向</span><br><span class="line"> fixed3 reflectDir = normalize(reflect(-worldLight, worldNormal));</span><br><span class="line"> //从世界空间获取视觉方向</span><br><span class="line"> fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line"> //计算高光系数</span><br><span class="line"> fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)),_Gloss);</span><br><span class="line"></span><br><span class="line"> fixed3 color = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在从世界空间获取<strong>反射方向</strong>r中，CG的<strong>reflect函数</strong>的入射方向要求是由光源指向交点处的，因此我们需要对 <strong>worldLightDir</strong> 取反后再传给reflect函数。</p>
</blockquote>
</li>
</ol>
<p>逐像素处理可以得到更加平滑的高光效果，至此，我们得到了一个完整的Phong光照模型</p>
<h4 id="5-5-3-Blinn-Phong光照模型"><a href="#5-5-3-Blinn-Phong光照模型" class="headerlink" title="5.5.3 - Blinn-Phong光照模型"></a>5.5.3 - Blinn-Phong光照模型</h4><p>Blinn模型没有使用<strong>反射方向r</strong>，而是引入一个新的矢量h：<br>$$<br>\hat{h} = \frac{\hat{v} + \hat{I}}{\mid \hat{v} + \hat{I} \mid }<br>$$<br>而Blinn模型计算高光反射的公式如下：<br>$$<br>c_{specular} = (c_{light} \cdot m_{specular})max(0, \hat{n} \cdot \hat{h})^{m_{gloss}}<br>$$</p>
<p>代码的实现只要修改逐像素光照中片元着色器的部分：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"> //从世界空间获取视觉方向</span><br><span class="line"> fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line"> //从世界空间获取半方向</span><br><span class="line"> fixed3 halfDir = normalize(worldLight + viewDir);</span><br><span class="line"> //计算高光系数</span><br><span class="line"> fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal, halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line"> fixed3 color = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>法线向量n</strong>与<strong>halfDir</strong>进行点积，最后将环境光、漫反射、高光反射相加得到颜色。</p>
</blockquote>
<p>Blinn-Phong光照模型的高光反射部分看起来更大、更亮一些，在<strong>实际的渲染</strong>中，我们也会<strong>选择Blinn-Phong光照模型</strong>。</p>
<h3 id="5-6-Unity内置函数"><a href="#5-6-Unity内置函数" class="headerlink" title="5.6 - Unity内置函数"></a>5.6 - Unity内置函数</h3><p>在计算光照模型的时候，我们往往需要得到光源方向、视角方向这两个基本信息。我们在上面的例子中得到的光源方向，这种办法只适用于平行光，如果需要处理更复杂的光照模型，如点光源和聚光灯，那么这种计算方法是错误的。我们需要现在代码中先判断光源的类型，再计算它的光源信息。</p>
<p>Unity提供了一些内置函数来帮助我们计算这些信息：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float3 WorldSpaceViewDir (float4 v)</td>
<td align="center">输入一个<strong>模型空间</strong>中的顶点位置,返回<strong>世界空间</strong>中从该点到摄像机的观察方向。内部实现使用了<strong>Unity WorldSpace ViewDir</strong>函数</td>
</tr>
<tr>
<td align="center">float3 Unity WorldSpaceViewDir (float4 v)</td>
<td align="center">输入一个<strong>世界空间</strong>中的顶点位置,返回<strong>世界空间</strong>中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td align="center">float3 ObjSpaceViewDir (float4 v)</td>
<td align="center">输入一个<strong>模型空间</strong>中的顶点位置,返回<strong>模型空间</strong>中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td align="center">float3 WorldSpaceLightDir(float4 v)</td>
<td align="center"><strong>仅可用于前向渲染中</strong>。输入一个<strong>模型空间</strong>中的顶点位置，返回<strong>世界空间</strong>中从该点到光源的光照方向。内部实现使用了 Unity WorldSpaceLightDir函数。没有被归一化</td>
</tr>
<tr>
<td align="center">float3 UnityWorldSpaceLightDir (float4 v)</td>
<td align="center"><strong>仅可用于前向渲染中</strong>。输入一个<strong>世界空间</strong>中的顶点位置，返回<strong>世界空间</strong>中从该点到光源的光照方向。没有被归一化</td>
</tr>
<tr>
<td align="center">float3 ObjSpaceLightDir (float4 v)</td>
<td align="center"><strong>仅可用于前向渲染中。</strong>输入一个<strong>模型空间</strong>中的顶点位置，返回<strong>模型空间</strong>中从该点到光源的光照方向。没有被归一化</td>
</tr>
<tr>
<td align="center">float3 UnityObjectToWorldNormal (float3 norm)</td>
<td align="center">把法线方向从<strong>模型空间</strong>转换到<strong>世界空间</strong>中</td>
</tr>
<tr>
<td align="center">float3 UnityObjectToWorldDir (in float3 dir)</td>
<td align="center">把方向矢量从<strong>模型空间</strong>变换到<strong>世界空间</strong>中</td>
</tr>
<tr>
<td align="center">float3 Unity WorldToObjectDir(float3 dir)</td>
<td align="center">把方向矢量从<strong>世界空间</strong>变换到<strong>模型空间</strong>中</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，这些函数都没有保障得到的方向矢量是单位矢量，因此，我们需要在使用前把它们归一化</p>
</blockquote>
<p>计算光源方向的3个函数：</p>
<ul>
<li><strong>WorldSpaceLightDir</strong></li>
<li><strong>Unity WorldSpaceLightDir</strong></li>
<li><strong>ObjSpaceLightDir</strong> </li>
</ul>
<p>它们尽可用于向前渲染，因为只有在向前渲染中，这3个函数中使用的内置变量**_WorldSpaceLightPos0**才会被正确赋值。</p>
<p>以下是在<strong>Blinn-Phong光照模型</strong>中的使用Unity内置函数的例子：</p>
<ul>
<li><p>在顶点着色器中，我们使用<strong>UnityObjectToWorldNormal</strong> 来计算世界空间下的法线方向</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> //o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"> //使用内置函数来计算世界空间中的法线向量</span><br><span class="line"> o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在片元着色器中，我们使用内置的<strong>UnityWorldSpaceLightDir</strong> 函数和<strong>WorldSpaceViewDir</strong> 来计算世界空间中的光照方向和视角方向</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> // 将法线方向从物体空间转为剪裁空间</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> // 获取世界空间下的光线方向</span><br><span class="line"> fixed3 worldLight = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"> //fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> //从世界空间获取视角方向</span><br><span class="line"> fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line"> //fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<blockquote>
<p>以上的方向矢量都需要使用<strong>normalize</strong>进行归一化得到单位矢量。</p>
</blockquote>
<h2 id="6-基础纹理"><a href="#6-基础纹理" class="headerlink" title="6 - 基础纹理"></a>6 - 基础纹理</h2><blockquote>
<p>在美术人员建模的时候，通常会在建模软件中利用纹理展开技术把<strong>纹理映射坐标(texture-mapping coordinates）</strong>存储在每个顶点上。纹理映射坐标定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个<strong>二维变量(u, v)<strong>来表示，其中u是横向坐标，而v是纵向坐标。因此，纹理映射坐标也被称为</strong>UV坐标</strong>。</p>
<p>Unity使用的纹理空间是符合<strong>OpenGL</strong>风格的。</p>
</blockquote>
<h3 id="6-1-单张纹理"><a href="#6-1-单张纹理" class="headerlink" title="6.1 -  单张纹理"></a>6.1 -  单张纹理</h3><h4 id="6-1-1-单张纹理的实现"><a href="#6-1-1-单张纹理的实现" class="headerlink" title="6.1.1 - 单张纹理的实现"></a>6.1.1 - 单张纹理的实现</h4><ol>
<li><p>为了使用纹理，在Properties中添加以下属性</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">    _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _Specular (&quot;Specular&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">    _Gloss (&quot;&quot;, Range(8.0, 256)) = 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>指明光照模式、声明变量、包含内置文件</p>
<blockquote>
<p>与其他属性类型不同的是，我们还需要为纹理类型的属性声明一个 <strong>float4</strong>类型的变量**_MainTex_ST<strong>。其中，</strong>_MainTex_ST<strong>的名字不是任意起的。在 Unity中，我们需要使用纹理名</strong>_ST<strong>的方式来声明某个纹理的属性。其中，</strong>ST<strong>是</strong>缩放(scale)<strong>和</strong>平移( translation)<strong>的缩写。</strong>_MainTex_ST<strong>可以让我们得到该纹理的缩放和平移（偏移）值，</strong>_MainTex_ST.xy** 存储的是缩放值，而**_MainTex ST.zw**存储的是偏移值。这些值可以在材质中调节。</p>
</blockquote>
</li>
<li><p>定义顶点着色器的输入和输出结构体</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    fixed3 normal : NORMAL;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD2;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在上面的代码中,我们首先在a2v结构体中使用<strong>TEXCOORDO</strong>语义声明了一个新的变量uv，这样Unity就会将模型的第一组纹理坐标存储到该变量中。</p>
</li>
<li><p>然后，我们在<strong>v2f</strong>结构体中添加了用于存储纹理坐标的变量<strong>uv</strong>，以便在片元着色器中使用该坐标进行纹理采样。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    </span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    </span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在顶点着色器中，我们使用纹理的属性值**_MainTex_ST<strong>来对顶点纹理坐标进行变换，得到最终的纹理坐标。计算过程是，首先使用缩放属性</strong>_MainTex_ST.xy** 对顶点纹理坐标进行缩放,然后再使用偏移属<strong>性_Main Tex_ST.zw</strong>对结果进行偏移。</p>
</li>
<li><p>Unity 提供了一个内置宏 <strong>TRANSFORM_TEX</strong>来帮我们计算上述过程。TRANSFORM_TEX是在 UnityCGcginc中定义的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TRANSFORM_TEX(tex, name) &#123;tex.xy * name##_ST,xy + name##_ST,zw&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
<li><p>实现片元着色器，并在计算漫反射时使用纹理中的纹素值</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">    fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line">    </span><br><span class="line">    fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">    fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">    fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal, halfDir)),_Gloss);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    fixed3 col = ambient + diffuse + specular;</span><br><span class="line">    return fixed4(col, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码首先计算了在<strong>世界空间</strong>下的<strong>法线方向</strong>和<strong>光照方向</strong>，然后使用CG的tex2D函数对纹理进行采样。它的第一个参数是<strong>需要被采样的纹理</strong>，第二个参数是一个<strong>float2</strong>类型的<strong>纹理坐标</strong>，它将返回计算得到的纹素值。我们使用采样结果和颜色属性**_Color** 的乘积来作为材质的反射率<strong>albedo</strong>，并把它和环境光照相乘得到环境光部分。随后，我们使用<strong>albedo</strong>来计算漫反射光照的结果，并和环境光照、高光反射光照相加后返回。</p>
</blockquote>
</li>
<li><p>设置合适的回调函数</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Specular&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h4 id="6-1-2-纹理的属性"><a href="#6-1-2-纹理的属性" class="headerlink" title="6.1.2 - 纹理的属性"></a>6.1.2 - 纹理的属性</h4><p>纹理的类型有以下几种</p>
<ul>
<li>Default：默认为纹理类型</li>
<li>Normal map：法线类型</li>
<li>Cubemap</li>
</ul>
<ul>
<li><p><strong>Wrap Mode一共有两种：</strong> <strong>Repeat</strong>和<strong>Clamp</strong>。它决定了纹理坐标超过[0, 1]时候纹理将会如何被平铺，Repeat会不断重复，Clamp只会截取临近的部分，如果纹理坐标大于1，那么会截取到1，如果小于0，那么会截取到0；</p>
</li>
<li><p><strong>Filter Mode：</strong>它决定了当纹理由于变换而产生拉伸时将会采用哪种滤波模式。</p>
<p>Filter Mode支持3种模式:<strong>Point</strong>，<strong>Bilinear</strong>以及 <strong>Trilinear</strong>。它们得到的图片滤波效果依次提升，但需要耗费的性能也依次增大。纹理滤波会影响放大或缩小纹理时得到的图。</p>
<blockquote>
<ul>
<li><p>纹理缩小的过程比放大更加复杂一些，此时原纹理中的多个像素将会对应一个目标像素。纹理缩放更加复杂的原因在于我们往往需要处理抗锯齿问题一个最常使用的方法就是使用<strong>多级渐远纹理(mipmapping）</strong>技术。</p>
</li>
<li><p>多级渐远纹理技术将原纹理提前用滤波处理来得到很多更小的图像，形成了一个图像金字塔，每一层都是对上一层图像降采样的结果。这样在实时运行时，就可以快速得到结果像素，例如当物体远离摄像机时，可以直接使用较小的纹理。但缺点是需要使用一定的空间用于存储这些多级渐远纹理，通常会多占用33%的内存空间。这是一种典型的用空间换取时间的方法。</p>
</li>
<li><p>在 Unity中，我们可以在纹理导入面板中，首先将纹理类型(TextureType）选择成Advanced，再勾选 Generate Mip Maps即可开启多级渐远纹理技术。同时，我们还可以选择生成多级渐远纹理时是否使用<strong>线性空间</strong>以及采用的滤波器等。</p>
</li>
</ul>
</blockquote>
<p>在内部实现上，<strong>Point</strong>模式使用了<strong>最近邻(nearest neighbor）滤波</strong>,在放大或缩小时，它的采样像素数目通常只有一个，因此图像会看起来有种<strong>像素风格</strong>的效果。而<strong>Bilinear滤波</strong>则使用了<strong>线性滤波</strong>，对于每个目标像素，它会找到4个邻近像素，然后对它们进行线性插值混合后得到最终像素，因此图像看起来像被模糊了。而 <strong>Trilinear滤波</strong>几乎是和 <strong>Bilinear</strong>一样的，只是 <strong>Trilinear</strong>还会在<strong>多级渐远纹理</strong>之间进行混合。如果一张纹理没有使用<strong>多级渐远纹理技术</strong>，那么<strong>Trilinear</strong>得到的结果还是和<strong>Bilinear</strong>是一样的。</p>
</li>
<li><p><strong>纹理的最大尺寸：</strong>如果导入的纹理大小超过了Max Texture Size 中的设置值,那么Unity将会把该纹理缩放为这个最大分辨率。理想情况下,导入的纹理可以是非正方形的,但长宽的大小应该是2的幂,<br>例如<br>2、4、8、16、32、64等。如果使用了非2的幂大小(Non Powerof Two,NPOT)的纹理，那么这些纹理往往会占用更多的内存空间，而且GPU 读取该纹理的速度也会有所下降。有一些平台甚至不支持这种<strong>NPOT纹理</strong>,这时Unity在内部会把它缩放成最近的2的幂大小。出于性能和空间的考虑，我们应该尽量使用2的幂大小的纹理。</p>
</li>
</ul>
<p><strong>Point</strong>，<strong>Bilinear</strong>以及 <strong>Trilinear</strong>下的画面拉伸的图：</p>
<p><img src="/image/UnityShaderLearning/image-20230704184957079.png" alt="image-20230704184957079"></p>
<h3 id="6-2-凹凸映射"><a href="#6-2-凹凸映射" class="headerlink" title="6.2 - 凹凸映射"></a>6.2 - 凹凸映射</h3><p>纹理的另一种常见的应用就是<strong>凹凸映射（bump mapping)<strong>。凹凸映射的目的是使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法</strong>不会真的改变模型的顶点位置</strong>,只是让模型看起来好像是“凹凸不平”的，但可以从模型的轮廓处看出“破绽”。</p>
<p>有两种主要的方法可以用来进行凹凸映射:</p>
<ul>
<li>一种方法是使用一张<strong>高度纹理(height map）</strong>来模拟表面位移(displacement),然后得到一个修改后的法线值,这种方法也被称为高度映射(heightmapping);</li>
<li>另一种方法则是使用一张<strong>法线纹理(normal map）</strong>来直接存储表面法线，这种方法又被称为法线映射（normal mapping)。尽管我们常常将凹凸映射和法线映射当成是相同的技术，但读者需要知道它们之间的不同。</li>
</ul>
<h4 id="6-2-1-高度纹理"><a href="#6-2-1-高度纹理" class="headerlink" title="6.2.1 - 高度纹理"></a>6.2.1 - 高度纹理</h4><p>高度图中存储的是强度值（intensity)，它用于表示模型表面局部的海拔高度。因此,颜色越浅表明该位置的表面越向外凸起,而颜色越深表明该位置越问里。</p>
<p>这种力云内灯处足非常直观,我们可以从高度图中明确地知道一个模型表画的凹凸情况，但缺点是计算更加复杂，在实时计算时不能直接得到表面法线,而是需要由像素的灰度值，因此需要消耗更多的性能。</p>
<p>高度图通常会和法线映射一起便用,用于给出表面凹凸的额外信息。也就是说，我们通常会使用法线映射来修改光照。</p>
<h4 id="6-2-2-法线纹理"><a href="#6-2-2-法线纹理" class="headerlink" title="6.2.2 - 法线纹理"></a>6.2.2 - 法线纹理</h4><p>而法线纹理中存储的就是表面的法线方向。由于<strong>法线方向的分量范围</strong>在**[-1，1]<strong>，而</strong>像素的分量范围<strong>为</strong>[0,1]<strong>，因此我们需要做一个映射，通常使用的映射就是:<br>$$<br>pixel = \frac{normal + 1}{2}<br>$$<br>这就要求，我们在Shader中对法线纹理进行纹理采样后，还需要对结果进行一次反映射的过程，以得到原先的法线方向。反映射的过程实际就是使用上面映射函数的逆函数:<br>$$<br>normal = pixel * 2 -1<br>$$<br>在实际制作中,我们往往会采用另一种坐标空间，即模型顶点的</strong>切线空间**(tangent space)来存储法线。</p>
<p>对于模型的每个顶点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而z轴是顶点的法线方向(n)，x轴是顶点的切线方向(t)，而y轴可由法线和切线叉积而得，也被称为是副切线（bitangent，b)或副法线，如图7.12所示。</p>
<p><img src="/image/UnityShaderLearning/image-20230704192202607.png" alt="image-20230704192202607"></p>
<p>总体来说，使用模型空间来存储法线的优点如下。</p>
<ul>
<li><strong>实现简单，更加直观。</strong>我们甚至都不需要模型原始的法线和切线等信息，也就是说，计算更少。生成它也非常简单，而如果要生成切线空间下的法线纹理，由于模型的切线一般是和UV方向相同，因此想要得到效果比较好的法线映射就要求纹理映射也是连续的。</li>
<li><strong>在纹理坐标的缝合处和尖锐的边角部分，可见的突变(缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。</strong>而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。</li>
</ul>
<p><strong>但使用切线空间有更多优点。</strong></p>
<ul>
<li><strong>自由度很高。</strong>模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型,而应用到其他模型上效果就完全错误了。而切线空间下的法线纹理记录的是相对法线信息,这意味着，即便把该纹理应用到一个完全不同的网格上,也可以得到一个合理的结果。</li>
<li><strong>可进行UV动画。</strong>比如,我们可以移动一个纹理的UV坐标来实现一个凹凸移动的效果,但使用模型空间下的法线纹理会得到完全错误的结果。原因同上。这种UV动画在水或者火山眯岩这种类型的物体上会经常用到。</li>
<li><strong>可以重用法线纹理。</strong>比如，一个砖块，我们仅使用一张法线纹理就可以用到所有的6个面上。原因同上。</li>
<li><strong>可压缩。</strong>由于切线空间下的法线纹理中法线的Z方向总是正方向，因此我们可以仅存储XY方向，而推导得到Z方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储3个方向的值,不可压缩。</li>
</ul>
<p>切线空间下的法线纹理的前两个优点足以让很多人放弃模型空间下的法线纹理而选择它。从上面的优点可以看出，切线空间在很多情况下都优于模型空间，而且可以节省美术人员的工作。因此，在本书中,我们使用的也是切线空间下的法线纹理。</p>
<p>我们需要在计算光照模型中统一各个方向矢量所在的坐标空间。由于<strong>法线纹理</strong>中存储的法线是<strong>切线空间</strong>下的方向，因此我们通常有两种选择:</p>
<ul>
<li>一种选择是在<strong>切线空间</strong>下进行光照计算，此时我们需要把光照方向、视角方向变换到切线空间下;</li>
<li>另一种选择是在<strong>世界空间</strong>下进行光照计算,此时我们需要把采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向进行计算。</li>
</ul>
<blockquote>
<p>从<strong>效率</strong>上来说，<strong>第一种方法往往要优于第二种方法</strong>，因为我们可以在顶点着色器中就完成对光照方向和视角方向的变换，而第二种方法由于要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味着我们需要在片元着色器中进行一次矩阵操作。</p>
<p>但从<strong>通用性角度</strong>来说，<strong>第二种方法要优于第一种方法</strong>,因为有时我们需要在<strong>世界空间下进行一些计算</strong>，例如在使用 <strong>Cubemap进行环境映射</strong>时，我们需要<strong>使用世界空间下的反射方向对Cubemap进行采样</strong>。如果同时需要进行法线映射，我们就需要把法线方向变换到世界空间下。</p>
</blockquote>
<h4 id="6-2-3-在切线空间下计算"><a href="#6-2-3-在切线空间下计算" class="headerlink" title="6.2.3 - 在切线空间下计算"></a>6.2.3 - 在切线空间下计算</h4><p><strong>基本思路：</strong></p>
<ul>
<li><p>在<strong>顶点着色器</strong>中把<strong>视角方向</strong>和<strong>光照方向</strong>从<strong>模型空间</strong>变换到<strong>切线空间</strong>中</p>
<blockquote>
<p>我们需要知道从模型空间到切线空间的变换矩阵，这个变换矩阵的逆矩阵即从切线空间到模型空间的变换矩阵是非常容易求得的。如果一个变换中仅存在<strong>平移</strong>和<strong>旋转变换</strong>，那么这个<strong>变换的逆矩阵</strong>就等于它的<strong>转置矩阵</strong>，而从<strong>模型空间</strong>到<strong>切线空间</strong>的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵。</p>
</blockquote>
</li>
<li><p>在<strong>片元着色器</strong>中通过纹理采样得到<strong>切线空间</strong>下的法线，然后再与切线空间下的视角方向、光源方向等计算</p>
</li>
</ul>
<p><strong>实现如下：</strong></p>
<ol>
<li><p>添加属性</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Color (&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line"> _Specular (&quot;Specular&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line"> _Gloss (&quot;&quot;, Range(8.0, 256)) = 20</span><br><span class="line"> _BumpMap (&quot;BumpMap&quot;, 2D) = &quot;Bump&quot; &#123;&#125;</span><br><span class="line"> _BumpScale (&quot;BumpScale&quot;, Float) = 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，**_Color<strong>、</strong>_Specular<strong>、</strong>_Gloss**都是我们为了实现之前的Blinn-Phong光照模型所需的必要参数</p>
<p><strong>_BumpMap</strong>是我们需要的法线纹理，**_BumpScale**用于控制纹理的凹凸程度</p>
</blockquote>
</li>
<li><p>配置光照模式、声明变量、引入内置文件</p>
</li>
<li><p>修改顶点着色器的输入结构体</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> float3 normal : NORMAL;</span><br><span class="line"> float4 tangent : TANGENT;    </span><br><span class="line"> float4 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们使用<strong>TANGENT</strong>语义来描述<strong>tangent</strong>，即告诉Unity把顶点的<strong>切线方向</strong>填充到<strong>tangent</strong>中</p>
</li>
<li><p>需要注意的是，和法线方向<strong>normal</strong> 不同，<strong>tangent</strong>的类型是<strong>float4</strong>，而非 float3，这是因为我们需要使用<strong>tangent.w分量</strong>来决定切线空间中的第三个坐标轴——副切线的方向性。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>修改片元着色器的输入结构体</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : SV_POSITION;</span><br><span class="line"> float4 uv : TEXCOORD0;</span><br><span class="line"> float3 lightDir : TEXCOORD1;</span><br><span class="line"> float3 viewDir : TEXCOORD2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //为了减少寄存器的使用，将贴图存储到一个纹理坐标中</span><br><span class="line"> o.uv.xy = v.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"> o.uv.zw = v.uv.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line"> // o.uv.xy = TRANSFORM_TEX(v.uv.xy, _MainTex);</span><br><span class="line"> // o.uv.zw = TRANSFORM_TEX(v.uv.xy, _BumpMap);</span><br><span class="line"></span><br><span class="line"> TANGENT_SPACE_ROTATION;</span><br><span class="line"></span><br><span class="line"> o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line"> o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于我们使用了两张纹理，我们使用<strong>float4</strong>类型的 <strong>uv</strong>去保存它们，其中<strong>xy分量</strong>存储**_Main<strong>的Tex纹理坐标，</strong>zw分量<strong>存储</strong>_BumpMap**纹理坐标。这样做的好处是可以减少插值寄存器的使用数目。</p>
</li>
<li><p>然后我们使用Unity内置的<strong>宏</strong>来计算得到从模型空间到切线空间的变换矩阵 <strong>rotation</strong></p>
</li>
<li><p>然后，我们使用Unity的内置函数<strong>ObjSpaceLightDir</strong>和<strong>ObjSpaceViewDir</strong>来得到模型空间下的光照和视角方向，再使用变换矩阵将它们从模型空间变换到切线空间中。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>我们在顶点着色器中完成了大部分工作，在片元着色器中只需要采样得到切线空间下的法线方向，再在切线空间下进行光照计算即可</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">fixed3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">fixed3 tangentViewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">fixed3 tangentNormal;</span><br><span class="line"></span><br><span class="line">tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">tangentNormal.xy *= _BumpScale;</span><br><span class="line">tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">	return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先用<strong>tex2D</strong>对法线纹理**_BumpMap**进行采样。因为法线纹理中存储的是把法线经过映射得到的像素值，因此我们需要把它们反映射回来。</p>
<p>我们需要在Unity中把这个法线纹理设置为Normal map，然后只用Unity的内置函数UnpackNormal来获得正确的法线方向。</p>
<p>使用**_BumpScale<strong>对法线的值进行缩放，由于法线都是单位矢量,因此</strong>tangentNormal.z<strong>分量可以由</strong>tangentNormal.xy**计算而得。由于我们使用的是切线空间下的法线纹理，因此可以保证法线方向的z分量为正。</p>
</blockquote>
</li>
<li><p>最后添加合适的回调函数</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Specular&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h4 id="6-2-4-在世界空间下计算"><a href="#6-2-4-在世界空间下计算" class="headerlink" title="6.2.4 - 在世界空间下计算"></a>6.2.4 - 在世界空间下计算</h4><p><strong>基本思路：</strong></p>
<ul>
<li>在顶点着色器中计算从切线空间到世界空间的变换矩阵，然后将它传递给片元着色器</li>
<li>在片元着色器中把法线纹理中的<strong>法线方向</strong>从<strong>切线空间</strong>变换到<strong>世界空间</strong>下</li>
</ul>
<blockquote>
<p>尽管这种方法需要更多的计算，但在需要使用Cubemap进行环境映射的情况下，我们就需要这种方法。</p>
</blockquote>
<p><strong>实现如下：</strong></p>
<ol>
<li><p>复制之前的代码，修改顶点着色器的输出v2f</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line">    float4 uv : TEXCOORD0;</span><br><span class="line">    float4 TtoW0 : TEXCOORD1;</span><br><span class="line">    float4 TtoW1 : TEXCOORD2;</span><br><span class="line">    float4 TtoW2 : TEXCOORD4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>插值寄存器最多只能存储<strong>float4</strong>大小的变量，对于矩阵这样的变量，我们可以把它们按行拆成多个变量再进行存储。上面代码中的<strong>TtoW0</strong>、<strong>TtoW1</strong>和 <strong>TtoW2</strong> 就依次存储了从切线空间到世界空间的变换矩阵的每一行。实际上，对方向矢量的变换只需要使用3×3大小的矩阵，也就是说，每一行只需要使用float3类型的变量即可。但为了充分利用插值寄存器的存储空间，我们把世界空间下的顶点位置存储在这些变量的w分量中。</p>
</blockquote>
</li>
<li><p>修改顶点着色器，计算从切线空间到世界空间的变换矩阵</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //为了减少寄存器的使用，将贴图存储到一个纹理坐标中</span><br><span class="line">    o.uv.xy = v.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">    o.uv.zw = v.uv.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">    // o.uv.xy = TRANSFORM_TEX(v.uv.xy, _MainTex);</span><br><span class="line">    // o.uv.zw = TRANSFORM_TEX(v.uv.xy, _BumpMap);</span><br><span class="line">    </span><br><span class="line">    float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">    fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">    o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">    o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);    </span><br><span class="line">    o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>修改片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line"></span><br><span class="line">    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">    fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">    fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">    bump.xy *= _BumpScale;</span><br><span class="line">    bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">    fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir));</span><br><span class="line"></span><br><span class="line">    fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">	return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先从<strong>TtoW0</strong>、<strong>TtoW1</strong>和 <strong>TtoW2</strong>的<strong>w分量</strong>中构建世界空间下的坐标。</li>
<li>然后，使用内置的<strong>UnityWorldSpaceLightDir</strong>和 <strong>UnityWorldSpaceViewDir</strong>函数得到世界空间下的光照和视角方向。</li>
<li>接着，我们使用内置的 <strong>UnpackNormal</strong>函数对法线纹理进行采样和解码（<strong>需要把法线纹理的格式标识成Normal map</strong>)，并使用 <strong>BumpScale</strong>对其进行缩放。</li>
<li>最后,我们使用TtoW0、TtoW1和 TtoW2存储的变换矩阵把法线变换到世界空间下。这是通过使用点乘操作来实现矩阵的每一行和法线相乘来得到的。</li>
</ul>
</blockquote>
</li>
</ol>
<p>从视觉表现上，在切线空间下和在世界空间下计算光照几乎没有任何差别。</p>
<h4 id="6-2-5-Unity中的法线纹理类型"><a href="#6-2-5-Unity中的法线纹理类型" class="headerlink" title="6.2.5 - Unity中的法线纹理类型"></a>6.2.5 - Unity中的法线纹理类型</h4><p>当把法线纹理的纹理类型标识成<strong>Normal map</strong>时，可以使用 Unity的内置函数 <strong>UnpackNormal</strong>来得到正确的法线方向</p>
<p>当我们需要使用那些包含了法线映射的内置的Unity Shader时,必须把使用的法线纹理按上面的方式标识成<strong>Normal map</strong>才能得到正确结果(即便你忘了这么做，Unity 也会在材质面板中提醒你修正这个问题)，这是因为这些Unity Shader都使用了内置的<strong>UnpackNormal</strong> 函数来采样法线方向。那么,当我们把纹理类型设置成 Normal map时到底发生了什么呢?为什么要这么做呢?</p>
<p>简单来说，这么做可以让Unity 根据不同平台对法线方向时，需要把纹理类型标识为Normal map纹理进行压缩（例如使用 <strong>DXT5nm</strong>格式)，再通过 <strong>UnpackNormal</strong>函数来针对不同的压缩格式对法线纹理进行正确的采样。我们可以在 UnityCGcginc里找到UnpackNormal函数的内部实现:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline fixed3 UnpackNormalDXT5nm (fixed4 packednormal)</span><br><span class="line">&#123;</span><br><span class="line">	fixed3 normal;</span><br><span class="line">	normal.xy=packednormal .wy * 2-1;</span><br><span class="line">	normal.z = sqrt(l- saturate(dot(normal.xy, normal.xy)));</span><br><span class="line">	return normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fixed3 UnpackNormal(fixed4 packednormal)</span><br><span class="line">&#123;</span><br><span class="line">#if defined (UNITY NO DXT5nm)</span><br><span class="line">	return packednormal.xyz *2- 1;</span><br><span class="line">#else</span><br><span class="line">	return UnpackNormalDXT5nm(packednormal);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，在某些平台上由于使用了<strong>DXT5nm</strong>的压缩格式，因此需要针对这种格式对法线进行解码。在 <strong>DXT5nm</strong>格式的法线纹理中，纹素的<strong>a通道</strong>(即<strong>w分量</strong>)对应了<strong>法线的r分量</strong>，<strong>g通道对应了法线的y分量</strong>，而纹理的<strong>r</strong>和<strong>b</strong>通道则会被<strong>舍弃</strong>，法线的<strong>z分量</strong>可以由<strong>xy分量推导</strong>而得。</p>
<p>为什么之前的普通纹理不能按这种方式压缩,而<strong>法线</strong>就需要使用<strong>DXT5nm</strong>格式来进行压缩呢?这是因为，按我们之前的处理方式，法线纹理被当成一个和普通纹理无异的图，但实际上，它<strong>只有两个通道是真正必不可少的</strong>，因为第<strong>三个通道的值可以用另外两个推导出来</strong>（法线是单位向量，并且切线空间下的法线方向的z分量始终为正)。使用这种压缩方法就可以减少法线纹理占用的内存空间。</p>
</blockquote>
<p>当我们把纹理类型设置成<strong>Normal map</strong>后，还有一个复选框是<code>Create from Grayscale</code>，这个复选框就是用于<strong>从高度图中生成法线纹理的</strong>。<strong>高度图</strong>本身记录的是相对高度，是一张<strong>灰度图</strong>，<strong>白色表示相对更高</strong>,<strong>黑色表示相对更低</strong>。当我们把张高度图导入Unity后，除了需要把它的纹理类型设置成Normal map外,还需要勾选 Create from Grayscale,然后，我们就可以把它和切线空间下的法线纹理同等对待了。</p>
<p>当勾选了<strong>Create from Grayscale</strong>后，还多出了两个选项——<strong>Bumpiness</strong>和 <strong>Filtering</strong>。其中<strong>Bumpiness</strong>用于控制<strong>凹凸程度</strong>，而<strong>Filtering</strong> 决定我们使用哪种方式来计算凹凸程度，它有两种选项:一种是<strong>Smooth</strong>，这使得生成后的法线纹理会比较<strong>平滑</strong>;另一种是<strong>Sharp</strong>，它会使用<strong>Sobel滤波</strong>(一种边缘检测时使用的滤波器）来生成法线。<strong>Sobel滤波</strong>的实现非常简单，我们只需要在一个3×3的滤波器中计算x和y方向上的导数，然后从中得到法线即可。具体方法是:对于高度图中的每个像素，我们考虑它与水平方向和竖直方向上的像素差，把它们的差当成该点对应的法线在x和y方向上的位移，然后使用之前提到的映射函数存储成到法线纹理的<strong>r和g分量</strong>即可。</p>
<h3 id="6-3-渐变映射"><a href="#6-3-渐变映射" class="headerlink" title="6.3 - 渐变映射"></a>6.3 - 渐变映射</h3><p>实现如下：</p>
<ol>
<li><p>在Properties语义块中声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">    _RampTex (&quot;Ramp Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _Specular (&quot;Specular&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">    _Gloss (&quot;&quot;, Range(8.0, 256)) = 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>配置光照模式、声明变量、引入内置文件</p>
</li>
<li><p>修改顶点着色器的输入结构体</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 uv : TEXCOORD0;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float2 uv : TEXCOORD2;</span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line"></span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>修改顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _RampTex);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>修改片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">    fixed halfLambert = dot(worldNormal,worldLightDir) * 0.5 + 0.5;</span><br><span class="line">    </span><br><span class="line">    fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse =  _LightColor0.rgb * diffuseColor;</span><br><span class="line"></span><br><span class="line">    fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">    fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line"></span><br><span class="line">    fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(0, dot(worldNormal, halfDir))), _Gloss);</span><br><span class="line"></span><br><span class="line">    return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中，我们使用半兰伯特模型，通过对法线方向和光照方向的点积做一次0.5倍的缩放以及一个0.5大小的偏移来计算半兰伯特部分 <strong>halfLambert</strong>。这样，我们得到的halfLambert的范围被映射到了**[0，1]**之间。</li>
<li>之后，我们使用 <strong>halfLambert</strong> 来构建一个<strong>纹理坐标</strong>,并用这个纹理坐标对渐变纹理 <strong>RampTex</strong>进行采样。由于 <strong>RampTex</strong>实际就是一个<strong>一维纹理</strong>(它在纵轴方向上颜色不变)，因此纹理坐标的u和v方向我们都使用了<strong>halfLambert</strong>。</li>
<li>然后，把从渐变纹理采样得到的颜色和材质颜色 <strong>Color</strong>相乘，得到最终的漫反射颜色。剩下的代码就是计算高光反射和环境光，并把它们的结果进行相加。</li>
</ul>
</blockquote>
</li>
<li><p>最后添加合适的回调函数</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Specular&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<blockquote>
<p>需要注意的是,我们需要把渐变纹理的 <strong>Wrap Mode</strong>设为<strong>Clamp</strong>模式,以防止对纹理进行采样时由于浮点数精度而造成的问题。</p>
<p>使用Repeat模式中在高光区域有一些黑点。这是由浮点精度造成的,当我们使用<strong>fixed2(halfLambert,halfLambert)<strong>对渐变纹理进行采样时,虽然理论上halfLambert 的值在[0,1]之间,<br>但可能会有1.000 01这样的值出现。如果我们使用的是</strong>Repeat模式</strong>,此时就会舍弃整数部分,只保留小数部分，得到的值就是0.00001，对应了渐变图中最左边的值，即黑色。因此，就会出现图中这样在高光区域反而有黑点的情况。我们只需要把渐变纹理的<strong>Wrap Mode</strong>设为<strong>Clamp模式</strong>就可以解决这种问题。</p>
</blockquote>
<h3 id="6-4-遮罩映射"><a href="#6-4-遮罩映射" class="headerlink" title="6.4 - 遮罩映射"></a>6.4 - 遮罩映射</h3><p><strong>遮罩纹理（mask texture）</strong>允许我们可以保护某些区域,使它们免于某些修改。</p>
<p>例如，我们希望模型表面某些区域的反光强烈一些，而某些区域弱一些。为了得到更加细腻的效果，我们就可以使用一张遮罩纹理来控制光照。</p>
<p>另一种常见的应用是在制作地形材质时需要混合多张图片，例如表现草地的纹理、表现石子的纹理、表现裸露土地的纹理等，使用遮罩纹理可以控制如何混合这些纹理。</p>
<p><strong>实现如下：</strong></p>
<ol>
<li><p>在Properties语义块中声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _Color (&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">    _Specular (&quot;Specular&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">    _Gloss (&quot;&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    _BumpMap (&quot;BumpMap&quot;, 2D) = &quot;Bump&quot; &#123;&#125;</span><br><span class="line">    _BumpScale (&quot;BumpScale&quot;, Float) = 1.0</span><br><span class="line">    _SpecularScale (&quot;SpecularScale&quot;, Float) = 1.0</span><br><span class="line">    _SpecularMask (&quot;SpecularMask&quot;, 2D) = &quot;Bump&quot; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>配置光照模式、声明变量、引入内置文件</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">fixed4 _Color;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">float _BumpScale;</span><br><span class="line">sampler2D _SpecularMask;</span><br><span class="line">float _SpecularScale;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line">float _Gloss;</span><br></pre></td></tr></table></figure>

<p>我们为主要纹理**_MainTex<strong>、法线纹理</strong>_BumpMap<strong>、遮罩纹理</strong>_SpecularMask<strong>定义了他们共同使用的纹理属性变量</strong>_MainTex_ST**。在属性中修改主要纹理的平铺系数和偏移系数会同时影响3个纹理的采样。这样做可以节省需要存储的纹理坐标数目。</p>
</blockquote>
</li>
<li><p>修改顶点着色器的输入结构体</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 uv : TEXCOORD0;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float2 uv : TEXCOORD2;</span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line"></span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>修改顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _RampTex);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>修改片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 lightDir = normalize(i.lightDir);</span><br><span class="line">    fixed3 viewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">    //解析法线贴图</span><br><span class="line">    fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">    tangentNormal.xy *= _BumpScale;</span><br><span class="line">    tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, lightDir));</span><br><span class="line"></span><br><span class="line">    fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">    fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line"></span><br><span class="line">	return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>环境光照和漫反射光照和之前使用过的代码完全一样。在计算高光反射时，我们首先对遮罩纹理**_SpecularMask<strong>进行采样。由于本书使用的遮罩纹理中每个纹素的rgb分量其实都是一样的，表明了该点对应的高光反射强度，在这里我们选择使用r分量来计算掩码值。然后，我们用得到的掩码值和</strong>_SpecularScale**相乘，一起来控制高光反射的强度。</li>
<li>需要说明的是，我们使用的这张遮罩纹理其实有很多空间被浪费了——它的rgb分量存储的都是同一个值。在实际的游戏制作中，我们往往会充分利用遮罩纹理中的每一个颜色通道来存储不同的表面属性。</li>
</ul>
</blockquote>
</li>
</ol>
<p>在真实的游戏制作过程中，遮罩纹理已经不止限于保护某些区域使它们免于某些修改，而是可以存储任何我们希望逐像素控制的表面属性。通常，我们会充分利用一张纹理的RGBA四个通道，用于存储不同的属性。例如，我们可以把高光反射的强度存储在R通道，把边缘光照的强度存储在G通道，把高光反射的指数部分存储在B通道，最后把自发光强度存储在A通道。<br>在游戏《DOTA2》的开发中，开发人员为每个模型使用了4张纹理:一张用于定义模型颜色，一张用于定义表面法线,另外两张则都是遮罩纹理。这样,两张遮罩纹理提供了共8种额外的表面属性，这使得游戏中的人物材质自由度很强，可以支持很多高级的模型属性。</p>
<h2 id="7-透明效果"><a href="#7-透明效果" class="headerlink" title="7 - 透明效果"></a>7 - 透明效果</h2><p>在 Unity中,我们通常使用两种方法来实现透明效果:</p>
<ul>
<li><p>第一种是使用<strong>透明度测试(Alpha Test)</strong>,这种方法其实无法得到真正的半透明效果;</p>
<blockquote>
<p>透明度测试:它采用一种“霸道极端”的机制，只要一个片元的透明度不满足条件(通常<br>是小于某个阈值),那么它对应的片元就会被舍弃。</p>
<p>它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。</p>
</blockquote>
</li>
<li><p>另一种是<strong>透明度混合（Alpha Blending)</strong></p>
<blockquote>
<p>透明度混合:这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合,得到新的颜色。但是,透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。</p>
<p>需要注意的是,透明度混合只关闭了深度写入,但没有关闭深度测试。这意味着，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。这一点决定了，当一个不透明物体出现在一个透明物体的前面，而我们先渲染了不透明物体，它仍然可以正常地遮挡住透明物体。也就是说，对于透明度混合来说，深度缓冲是只读的。</p>
</blockquote>
</li>
</ul>
<p>对于透明度混合技术，需要关闭<strong>深度写入</strong>，此时我们就需要小心处理透明物体的渲染顺序。</p>
<p>那么，我们为什么要关闭<strong>深度写入</strong>呢?如果不关闭<strong>深度写入</strong>，一个半透明表面背后的表面本来是可以透过它被我们看到的，但由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也就<strong>无法透过半透明表面看到后面的物体了</strong>。但是，我们由此就破坏了深度缓冲的工作机制，关闭深度写入导致渲染顺序将变得非常重要。</p>
<h3 id="7-1-Unity-Shader的渲染顺序"><a href="#7-1-Unity-Shader的渲染顺序" class="headerlink" title="7.1 - Unity Shader的渲染顺序"></a>7.1 - Unity Shader的渲染顺序</h3><p>Unity为了解决渲染顺序提供了渲染队列，<strong>SubShader</strong>的<strong>Queue</strong>标签来决定我们的模型归于哪个渲染队列，<strong>索引号越小表示越早被渲染</strong>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>队列索引号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Background</td>
<td>1000</td>
<td>这个渲染队列会在任何其他队列之前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体</td>
</tr>
<tr>
<td>Geometry</td>
<td>2000</td>
<td>默认的渲染队列，大多数物体都使用这个队列。不透明物体使用这个队列</td>
</tr>
<tr>
<td>AlphaTest</td>
<td>2450</td>
<td>需要透明度测试的物体使用这个队列。在 Unity 5中它从 Geometry 队列中被单独分出来，这是因为在所有不透明物体渲染之后再渲染它们会更加高效</td>
</tr>
<tr>
<td>Transparent</td>
<td>3000</td>
<td>这个队列中的物体会在所有 Geometry和 AlphaTest物体渲染后，再按从后往前的顺序进行渲染。任何使用了透明度混合（例如关闭了深度写入的 Shader）的物体都应该使用该队列</td>
</tr>
<tr>
<td>Overlay</td>
<td>4000</td>
<td>该队列用于实现一些叠加效果。任何需要在最后渲染的物体都应该使用该队列</td>
</tr>
</tbody></table>
<p>因此，如果想通过<strong>透明度测试</strong>实现透明效果，代码中应包含以下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &#125;</span><br><span class="line">    Pass &#123; </span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果想通过<strong>透明度混合</strong>测试实现透明效果，代码中应包含以下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &#125;</span><br><span class="line">    Pass &#123; </span><br><span class="line">    	Zwrite off</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>ZWrite Off</strong>用于关闭深度写入，在这里我们选择把它写在Pass中。我们也可以把它写在 SubShader 中，这意味着该SubShader下的所有Pass都会关闭深度写入。</p>
</blockquote>
<h3 id="7-3-透明度测试"><a href="#7-3-透明度测试" class="headerlink" title="7.3 - 透明度测试"></a>7.3 - 透明度测试</h3><blockquote>
<p>透明度测试:只要一个片元的透明度不满足条件(通常是小于某个阈值)，那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响;否则，就会按照普通的不透明物体的处理方式来处理它。</p>
</blockquote>
<p>通常，我们会在片元着色器中使用<strong>clip</strong>函数来进行透明度测试。clip是CG 中的一个函数，如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色。</p>
<p>Shader：<strong>Chapter8-AlphaTest</strong></p>
<p>实现如下：</p>
<ol>
<li><p>定义属性，声明一个范围在[0，1]的属性<code>_Cutoff</code>用来控制是否透明</p>
</li>
<li><p>定义Tag</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; </span><br><span class="line">        &quot;Queue&quot;=&quot;AlphaTest&quot;</span><br><span class="line">        &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">        &quot;RenderType&quot;=&quot;TransparentCutout&quot; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>透明度测试使用的渲染队列是名为<code>AlphaTest</code>的队列，因此我们需要把<code>Queue</code>标签设置为<code>AlphaTest</code>。</li>
<li>而 RenderType标签可以让Unity把这个Shader归入到提前定义的组(这里就是<code>TransparentCutout</code>组)中,以指明该Shader是一个使用了透明度测试的 Shader。RenderType标签通常被用于着色器替换功能。</li>
<li>把<code>IgnoreProjector</code>设置为<code>True</code>，这意味着这个 Shader 不会受到投影器(Projectors）的影响。</li>
</ul>
</blockquote>
</li>
<li><p>包含内置文件、声明变量、定义顶点着色器以及它的输入和输出结构体</p>
</li>
<li><p>修改片元着色器：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 WorldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">    fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">    clip(texColor.a - _Cutoff);</span><br><span class="line"></span><br><span class="line">    fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">    fixed3 ambient =  UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, WorldLightDir));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return fixed4(ambient + diffuse, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用clip函数判断参数<code>texColor.a</code>是否小于材质参数<code>_Cutoff</code>,是就舍弃该片元的输出。</p>
</blockquote>
</li>
<li><p>选择合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="7-4-透明度混合"><a href="#7-4-透明度混合" class="headerlink" title="7.4 - 透明度混合"></a>7.4 - 透明度混合</h3><p>为了进行混合，我们需要使用Unity提供的混合命令：Blend，以下是ShaderLab的Blend命令。</p>
<table>
<thead>
<tr>
<th align="center">语义</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Blend Off</td>
<td align="center">关闭混合</td>
</tr>
<tr>
<td align="center">Blend SrcFactor DstFactor</td>
<td align="center">开启混合，并设置混合因子。源颜色(该片元产生的颜色）会乘以SrcFactor，而目标颜色(已经存在于颜色缓存的颜色）会乘以 DstFactor，然后把两者相加后再存入颜色缓冲</td>
</tr>
<tr>
<td align="center">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td>
<td align="center">和上面几乎一样，只是使用不同的因子来混合透明通道</td>
</tr>
<tr>
<td align="center">BlendOp BlendOperation</td>
<td align="center">并非是把源颜色和目标颜色简单相加后混合，而是使用BlendOperation对它们进行其他操作</td>
</tr>
</tbody></table>
<p>Shader：<strong>Chapter8-AlphaBlend</strong></p>
<p>实现如下：</p>
<ol>
<li><p>定义属性，声明一个范围在[0，1]的属性<code>_AlphaScale</code>用来控制透明度</p>
</li>
<li><p>定义Tag</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; </span><br><span class="line">        &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">        &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">        &quot;RenderType&quot;=&quot;Transparent&quot;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>透明度混合使用的渲染队列是名为<code>Transparent</code>的队列，因此我们需要把<code>Queue</code>标签设置为<code>Transparent</code>。</li>
<li>而 RenderType标签可以让Unity把这个Shader归入到提前定义的组(这里就是<code>Transparent</code>组)中,以指明该Shader是一个使用了透明度混合的 Shader。RenderType标签通常被用于着色器替换功能。</li>
<li>把<code>IgnoreProjector</code>设置为<code>True</code>，这意味着这个 Shader 不会受到投影器(Projectors）的影响。</li>
</ul>
</blockquote>
</li>
<li><p>与透明度测试不同的是，我们还需要在Pass中为透明的混合进行合适的混合状态设置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">    Zwrite Off</span><br><span class="line">    Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure>

<p>Pass的标签仍和之前一样，即把<code>LightMode</code>设为<code>ForwardBase</code>，这是为了让 Unity 能够按前向渲染路径的方式为我们正确提供各个光照变量。</p>
<p>除此之外，我们还把该Pass 的深度写入（ZWrite)设置为关闭状态（Off)</p>
<p>然后，我们开启并设置了该Pass 的混合模式。我们将源颜色（该片元着色器产生的颜色）的混合因子设为<code>SrcAlpha</code>，把目标颜色(已经存在于颜色缓冲中的颜色）的混合因子设为<code>OneMinusSrcAlpha</code>,以得到合适的半透明效果。</p>
</blockquote>
</li>
<li><p>包含内置文件、声明变量、定义顶点着色器以及它的输入和输出结构体</p>
</li>
<li><p>修改片元着色器：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 WorldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">    fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">    fixed3 ambient =  UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, WorldLightDir));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的更改的设置了该片元着色器返回值中的透明通道</p>
</blockquote>
</li>
<li><p>选择合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback &quot;Transparent/vertexLit&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<blockquote>
<p>由于网格有复杂结构，这个透明效果仍不够好，仍然需要使用深入写入来优化</p>
</blockquote>
<h3 id="7-5-开启深度写入的半透明效果"><a href="#7-5-开启深度写入的半透明效果" class="headerlink" title="7.5 - 开启深度写入的半透明效果"></a>7.5 - 开启深度写入的半透明效果</h3><p>Shader：<strong>Chapter8-AlphaBlendZWrite</strong></p>
<p>实现如下：</p>
<p>使用<strong>Chapter8-AlphaBlend</strong>中的代码，在此基础上在<strong>原来的Pass前面</strong>添加一个新的Pass即可</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Zwrite On</span><br><span class="line">    ColorMask 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个新添加的Pass的目的仅仅是为了把模型的深度信息写入深度缓冲中,从而剔除模型中被自身遮挡的片元。因此，Pass的第一行开启了深度写入。</li>
<li>在第二行，我们使用了一个新的渲染命<code>ColorMask</code>。在ShaderLab 中，<code>ColorMask</code> 用于设置颜色通道的写掩码(write mask)。当<code>ColorMask</code>设为0时，意味着该Pass 不写入任何颜色通道，即不会输出任何颜色。这正是我们需要的——该Pass只需写入深度缓存即可。</li>
</ul>
</blockquote>
<h3 id="7-6-ShaderLab的混合指令"><a href="#7-6-ShaderLab的混合指令" class="headerlink" title="7.6 - ShaderLab的混合指令"></a>7.6 - ShaderLab的混合指令</h3><h4 id="7-6-1-混合等式和参数"><a href="#7-6-1-混合等式和参数" class="headerlink" title="7.6.1 - 混合等式和参数"></a>7.6.1 - 混合等式和参数</h4><blockquote>
<p>混合是一个逐片元的操作,而且它不是可编程的，但却是高度可配置的。也就是说，我们可以设置混合时使用的运算操作、混合因子等来影响混合。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Blend SrcFactor DstFactor</td>
<td>开启混合，并设置混合因子。源颜色（该片元产生的颜色）会乘以SrcFactor，而目标颜色(已经存在于颜色缓存的颜色）会乘以DstFactor，然后把两者相加后再存入颜色缓冲中</td>
</tr>
<tr>
<td>Blend SrcFactor DstFactor, SrcFactor A DstFactorA</td>
<td>和上面几乎一样，只是使用不同的因子来混合透明通道</td>
</tr>
</tbody></table>
<h4 id="7-6-2-常见的混合类型"><a href="#7-6-2-常见的混合类型" class="headerlink" title="7.6.2 - 常见的混合类型"></a>7.6.2 - 常见的混合类型</h4><p>通过混合操作和混合因子命令的组合，我们可以得到一些类似 Photoshop混合模式中的混合效果:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Normal 正常，即透明度混合</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">// Soft Additive 柔和相加</span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"></span><br><span class="line">// Multiply 正片叠底</span><br><span class="line">Blend DstColor Zero</span><br><span class="line"></span><br><span class="line">// 2x Multiply 两倍相乘</span><br><span class="line">Blend DstColor SrcColor</span><br><span class="line"></span><br><span class="line">// Darken 变暗</span><br><span class="line">BlendOp Min</span><br><span class="line">Blend One One	// When using Min operation, these factors are ignored</span><br><span class="line"></span><br><span class="line">//  Lighten 变亮</span><br><span class="line">BlendOp Max</span><br><span class="line">Blend One One // When using Max operation, these factors are ignored</span><br><span class="line"></span><br><span class="line">// Screen 滤色</span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line">//等同于</span><br><span class="line">Blend One OneMinusSrcColor</span><br><span class="line"></span><br><span class="line">// Linear Dodge 线性减淡</span><br><span class="line">Blend One One</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="7-7-双面渲染的透明效果"><a href="#7-7-双面渲染的透明效果" class="headerlink" title="7.7 - 双面渲染的透明效果"></a>7.7 - 双面渲染的透明效果</h3><h4 id="7-7-1-透明度测试的双面渲染"><a href="#7-7-1-透明度测试的双面渲染" class="headerlink" title="7.7.1 - 透明度测试的双面渲染"></a>7.7.1 - 透明度测试的双面渲染</h4><p>这节的代码和透明度测试的代码几乎一样，只是在Pass语义块中加了一行：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">    Cull off</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="7-7-2-透明度混合的双面渲染"><a href="#7-7-2-透明度混合的双面渲染" class="headerlink" title="7.7.2 - 透明度混合的双面渲染"></a>7.7.2 - 透明度混合的双面渲染</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; </span><br><span class="line">        &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">        &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">        &quot;RenderType&quot;=&quot;Transparent&quot;  </span><br><span class="line">        &#125;</span><br><span class="line">    Pass</span><br><span class="line">    &#123; </span><br><span class="line">        Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line">        Cull Front</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125; </span><br><span class="line">        Cull Back</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>为此，我们选择把双面渲染的工作分成两个Pass-第一Pass只渲染背面，第二个Pass只渲染正面，由于Unity会顺序执行SubShader中的各个Pass,因此我们可以保证背面总是在正面被渲染之前渲染，从而可以保证正确的深度渲染关系。</p>
</blockquote>
<h2 id="8-复杂光照"><a href="#8-复杂光照" class="headerlink" title="8 - 复杂光照"></a>8 - 复杂光照</h2><h3 id="8-1-Unity的渲染路径"><a href="#8-1-Unity的渲染路径" class="headerlink" title="8.1 - Unity的渲染路径"></a>8.1 - Unity的渲染路径</h3><p>在Unity中，<strong>渲染路径（Render Path）</strong>决定了光照是如何应用到Unity Shader中的。如果要和光源打交道，那么我们需要为每个Pass指定它使用的渲染路径。</p>
<p><strong>LightMode标签支持的渲染路径选项：</strong></p>
<table>
<thead>
<tr>
<th align="center">标签名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照</td>
</tr>
<tr>
<td align="center">ForwardBase</td>
<td align="center">用于<strong>前向渲染</strong>。该Pass 会计算环境光、最重要的平行光、逐顶点/SH光源和 Lightmaps</td>
</tr>
<tr>
<td align="center">ForwardAdd</td>
<td align="center">用于<strong>前向渲染</strong>。该Pass会计算额外的逐像素光源，每个Pass对应一个光源</td>
</tr>
<tr>
<td align="center">Deferred</td>
<td align="center">用于<strong>延迟渲染</strong>。该Pass会渲染G缓冲（G-buffer)</td>
</tr>
<tr>
<td align="center">ShadowCaster</td>
<td align="center">把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中</td>
</tr>
</tbody></table>
<h4 id="8-1-1-向前渲染路径"><a href="#8-1-1-向前渲染路径" class="headerlink" title="8.1.1 - 向前渲染路径"></a>8.1.1 - 向前渲染路径</h4><p><strong>向前渲染路径的原理：</strong></p>
<p>每进行一次完整的向前渲染，我们需要渲染该对象的图元，并计算两个缓冲区的信息，一个是<strong>颜色缓冲区</strong>，一个是<strong>深度缓冲区</strong>。我们利用<strong>深度缓冲</strong>来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。</p>
<blockquote>
<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个 Pass，每个 Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有N个物体，每个物体受M个光源的影响，那么要渲染整个场景一共需要N*M个 Pass。可以看出，如果有大量逐像素光照，那么需要执行的Pass数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p>
</blockquote>
<p><strong>Unity中的向前渲染：</strong></p>
<p>一共Pass不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。</p>
<p>在Unity中，向前渲染路径有3种处理光照的方式，<strong>逐顶点处理</strong>，<strong>逐像素处理</strong>，<strong>球谐函数处理（Spherical Harmonics，SH）</strong>。</p>
<p>光源模式指的是该光源是否是<strong>重要的（Important）</strong>，如果一个光源被设置成重要的，那么它就会被逐像素处理。</p>
<p>Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度（例如距离物体的远近、光源强度等），对这些光源进行一个重要度的排序。其中,一定数目的光源会按逐像素的方式处理，然后最多有4个光源按逐顶点的方式处理,剩下的光源可以按 SH方式处理。Unity 使用的判断规则如下。</p>
<ul>
<li>场景中最亮的平行光总是按逐像素处理的。</li>
<li>渲染模式被设置成 Not Important的光源,会按逐顶点或者SH处理。</li>
<li>渲染模式被设置成Important的光源,会按逐像素处理。</li>
<li>如果根据以上规则得到的逐像素光源数量小于<strong>Quality Setting</strong> 中的逐像素光源数量(PixelLight Count)，会有更多的光源以逐像素的方式进行渲染。</li>
</ul>
<p>Unity的光照在Pass中进行计算，向前渲染有两种Pass：<strong>Base Pass</strong>和<strong>Additional Pass</strong>。</p>
<p><img src="/image/UnityShaderLearning/image-20230706104114037.png" alt="image-20230706104114037"></p>
<blockquote>
<p>对于前向渲染来说，一个Unity Shader通常会定义一个 Base Pass(Base Pass也可以定义多次，例如需要双面渲染等情况)以及Additional Pass。一个 Base Pass仅会执行一次(定义了多个 Base Pass的情况除外),<br>而一个Additional Pass会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次Additional Pass。</p>
</blockquote>
<p><strong>向前渲染路径中可以使用的内置光照变量：</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_LightColor0</td>
<td>float4</td>
<td>该Pass处理的逐像素光源的颜色</td>
</tr>
<tr>
<td>_WorldSpaceLightPos0</td>
<td>float4</td>
<td><code>_WorldSpaceLightPos0.xyz</code>是该 Pass处理的逐像素光源的位置。如果该光源是平行光，那么<code>_WorldSpaceLightPos0.w</code>是0,其他光源类型w值为1</td>
</tr>
<tr>
<td>_LightMatrix0</td>
<td>float4×4</td>
<td>从世界空间到光源空间的变换矩阵。可以用于采样cookie和光强衰减（attenuation)纹理</td>
</tr>
<tr>
<td>unity_4LightPosX0, unity_4LightPosY0,unity_4LightPosZ0</td>
<td>float4</td>
<td>仅用于 Base Pass。前4个非重要的点光源在世界空间中的位置</td>
</tr>
<tr>
<td>unity_4LightAtten0</td>
<td>float4</td>
<td>仅用于Base Pass。存储了前4个非重要的点光源的衰减因子</td>
</tr>
<tr>
<td>unity_LightColor</td>
<td>half4[4]</td>
<td>仅用于Base Pass。存储了前4个非重要的点光源的颜色</td>
</tr>
</tbody></table>
<p><strong>向前渲染中可以使用的内置光照函数：</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>float3 WorldSpaceLightDir(float4 v)</td>
<td>仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。内部实现使用了Unity WorldSpaceLightDir函数。没有被归一化</td>
</tr>
<tr>
<td>float3 UnityWorldSpaceLightDir(float4 v)</td>
<td>仅可用于前向渲染中。输入一个世界空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化</td>
</tr>
<tr>
<td>float3 ObjSpaceLightDir(float4 v)</td>
<td>仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向。没有被归一化</td>
</tr>
<tr>
<td>float3 Shade4PointLights (…)</td>
<td>仅可用于前向渲染中。计算四个点光源的光照，它的参数是已经打包进矢量的光照数据，通常就是表9.2中的内置变量，如 unity_4LightPosX0，unity_4LightPosY0,unity_ 4LightPosZ0、unity LightColor和 unity_4LightAtten0等。前向渲染通常会使用这个函数来计算逐顶点光照</td>
</tr>
</tbody></table>
<h4 id="8-1-2-顶点渲染路径"><a href="#8-1-2-顶点渲染路径" class="headerlink" title="8.1.2 - 顶点渲染路径"></a>8.1.2 - 顶点渲染路径</h4><p>顶点照明渲染路径是对硬件配置要求最少、运算性能最高，但同时也是得到的效果最差的一种类型，它不支持那些逐像素才能得到的效果，例如<strong>阴影法线映射</strong>、<strong>高精度的高光反射</strong>等。实际上，它仅仅是前向渲染路径的一个<strong>子集</strong>，也就是说，所有可以在顶点照明渲染路径中实现的功能都可以在<strong>前向渲染路径</strong>中完成。就如它的名字一样，顶点照明渲染路径只是使用了逐顶点的方式来计算光照，并没有什么神奇的地方。实际上，我们在上面的前向渲染路径中也可以计算一些逐顶点的光源。但如果选择使用顶点照明渲染路径，那么Unity 会只填充那些逐顶点相关的光源变量,意味着我们不可以使用一些逐像素光照变量。</p>
<p>顶点照明渲染路径通常在一个 Pass中就可以完成对物体的渲染。在这个Pass中，我们会计算我们关心的所有光源对该物体的照明，并且这个计算是按逐顶点处理的。这是Unity 中最快速的渲染路径，并且具有最广泛的硬件支持。</p>
<h4 id="8-1-3-延迟渲染路径"><a href="#8-1-3-延迟渲染路径" class="headerlink" title="8.1.3 - 延迟渲染路径"></a>8.1.3 - 延迟渲染路径</h4><p>前向渲染的问题是:当场景中包含大量实时光源时，前向渲染的性能会急速下降。例如，如果我们在场景的某一块区域放置了多个光源，这些光源影响的区域互相重叠，那么为了得到最终的光照效果，我们就需要为该区域内的每个物体执行多个 Pass来计算不同光源对该物体的光照结果，然后在颜色缓存中把这些结果混合起来得到最终的光照。然而，每执行一个 Pass我们都需要重新渲染一遍物体,但很多计算实际上是重复的。</p>
<p>延迟渲染主要包含了两个Pass 。<strong>在第一个Pass中</strong>，我们不进行任何光照计算,而是仅仅计算哪些片元是可见的,这主要是通过深度缓冲技术来实现，当发现一个片元是可见的,我们就把它的相关信息存储到G缓冲区中。然后，<strong>在第二个 Pass中</strong>，我们利用G缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。</p>
<p>对于延迟渲染路径来说，它最适合在场景中光源数目很多、如果使用前向渲染会造成性能瓶颈的情况下使用。而且，延迟渲染路径中的每个光源都可以按逐像素的方式处理。但是，延迟渲染也有一些缺点。</p>
<ul>
<li>不支持真正的抗锯齿（anti-aliasing）功能。</li>
<li>不能处理半透明物体。</li>
<li>对显卡有一定要求。如果要使用延迟渲染的话，显卡必须支持 MRT (Multiple RenderTargets)、Shader Mode 3.0及以上、深度渲染纹理以及双面的模板缓冲。</li>
</ul>
<p>当使用延迟渲染时，Unity要求我们提供两个Pass。</p>
<p>(1）第一个 Pass用于渲染G缓冲。在这个 Pass中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的G缓冲区中。对于每个物体来说，这个Pass仅会执行一次。</p>
<p>(2）第二个Pass用于计算真正的光照模型。这个 Pass 会使用上一个Pass中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。</p>
<h3 id="8-2-Unity的光源类型"><a href="#8-2-Unity的光源类型" class="headerlink" title="8.2 - Unity的光源类型"></a>8.2 - Unity的光源类型</h3><p>Unity一共支持四种光源类型：平行光、点光源、聚光灯和面光源（Area Light），面光源仅在烘焙时才可发挥作用。</p>
<h4 id="8-2-1-在向前渲染中处理不同的光源类型"><a href="#8-2-1-在向前渲染中处理不同的光源类型" class="headerlink" title="8.2.1 - 在向前渲染中处理不同的光源类型"></a>8.2.1 - 在向前渲染中处理不同的光源类型</h4><p>Shader：<strong>Chapter9-ForwardRendering</strong></p>
<ol>
<li><p>使用Blinn-Phone光照模型，并为向前渲染定义了<strong>Bass Pass</strong> 和 <strong>Additional Pass</strong>来处理多个光源。</p>
</li>
<li><p>定义第一个Pass - Base Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    // Base Shader</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line">    </span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">     // Apparently need to add this declaration </span><br><span class="line">    #pragma multi_compile_fwdbase  </span><br></pre></td></tr></table></figure>

<p>除了设置渲染路径以外，还是用了#pragma编译指令。 <code>#pragma multi_compile_fwdbase</code>可以保证我们在Shader中使用的光照衰减等光照变量可以被正确赋值。</p>
</blockquote>
</li>
<li><p>在Base Pass中计算环境光，我们希望环境光只计算一次，因此在之后的<strong>Additional Pass</strong>就不会在计算这个部分。与之类似的还有自发光。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>然后，我们在<strong>Base Pass</strong> 中处理了场景中的最重要的平行光。我们可以使用**_WorldSpaceLightPos0<strong>来得到这个平行光的方向（位置对平行光来说没有意义),使用</strong>_LightColor0<strong>来得到它的颜色和强度(_LightColor0已经是颜色和强度相乘后的结果)，由于平行光可以认为是没有衰减的，因此这里我们直接令衰减值为</strong>1.0**。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed3 diffuse =  _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal,worldLight));</span><br><span class="line"></span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal, halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line">fixed atten = 1.0;</span><br><span class="line">fixed3 color = ambient + (diffuse + specular) * atten;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return fixed4(color, 1.0);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果场景中包含了多个平行光，Unity 会选择最亮的平行光传递给Base Pass-进行逐像素处理，其他平行光会按照逐顶点或在Additional Pass中按逐像素的方式处理。</li>
<li>如果场景中没有任何平行光，那么 Base Pass 会当成全黑的光源处理。每一个光源有5个属性:位置、方向、颜色、强度以及衰减。对于Base Pass来说，它处理的逐像素光源类型一定是平行光。</li>
</ul>
</blockquote>
</li>
<li><p>接下来，需要对场景其他像素定义Additional Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    // Additional Shader</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ForwardAdd&quot; &#125;</span><br><span class="line"></span><br><span class="line">    Blend One One</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">   // Apparently need to add this declaration</span><br><span class="line">    #pragma multi_compile_fwdadd</span><br></pre></td></tr></table></figure>

<p>除了设置渲染路径标签外，我们同样使用了<code>#pragma multi_compile_fwdadd</code>指令，如前面所<br>说，这个指令可以保证我们在<strong>Additional Pass</strong> 中访问到正确的光照变量。与<strong>Base Pass</strong>不同的是,我们还使用 <strong>Blend</strong> 命令开启和设置了混合模式。这是因为，我们希望 <strong>Additional Pass</strong>计算得到的光照结果可以在帧缓存中与之前的光照结果进行叠加。如果没有使用<strong>Blend</strong>命令的话，<strong>AdditionalPass</strong> 会直接覆盖掉之前的光照结果。在本例中，我们选择的混合系数是<code>Blend One One</code>，这不是必需的，我们可以设置成 Unity支持的任何混合系数。常见的还有<code>Blend SrcAlpha One</code></p>
</blockquote>
</li>
<li><p>通常来说，<strong>Additional Pass</strong>中的光照处理和<strong>Base Pass</strong>中的处理方式是一样的，只需要去掉<strong>Base Pass</strong>中的<strong>环境光</strong>、<strong>自发光</strong>、<strong>逐顶点光照</strong>、<strong>SH光照的部分</strong>，并添加<strong>对不同光源的支持</strong>。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USING_DIRECTIONAL_LIGHT</span><br><span class="line">    fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">#else</span><br><span class="line">    fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先判断了当前处理的逐像素光源的类型，这是通过使用#ifdef指令判断是否定义了<code>USING_DIRECTIONAL_LIGHT</code>来得到的。如果当前前向渲染 Pass 处理的光源类型是平行光，那么Unity的底层渲染引擎就会定义USING DIRECTIONAL LIGHT。</p>
<ul>
<li>如果判断得知是平行光的话,光源方向可以直接由 <code>WorldSpaceLightPos0.xyz</code>得到;</li>
<li>如果是点光源或聚光灯,那么 <code>WorldSpaceLightPos0.xyz</code>表示的是世界空间下的光源位置，而想要得到光源方向的话，我们就需要用这个位置减去世界空间下的顶点位置。</li>
</ul>
</blockquote>
</li>
<li><p>最后，我们需要处理不同光源的衰减：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USING_DIRECTIONAL_LIGHT</span><br><span class="line">    fixed atten = 1.0;</span><br><span class="line">#else</span><br><span class="line">    #if defined(POINT)</span><br><span class="line">        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br><span class="line">        fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">    #elif  defined(SPOT)</span><br><span class="line">        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1));</span><br><span class="line">        fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">    #else</span><br><span class="line">        fixed atten = 1.0;</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>我们同样通过判断是否定义了<code>USING_DIRECTIONAL_LIGHT</code>来决定当前处理的光源类型。</p>
<ul>
<li>如果是平行光的话，衰减值为1.0。</li>
<li>如果是其他光源类型,那么处理更复杂一些。Unity选择了使用一张纹理作为查找表（Lookup Table，LUT),以在片元着色器中得到光源的衰减。我们首先得到光源空间下的坐标，然后使用该坐标对衰减纹理进行采样得到衰减值。</li>
</ul>
</blockquote>
</li>
</ol>
<p>当我们创建一个光源时，默认情况下它的 Render Mode(可以在 Light组件中设置)是Auto。这意味着，Unity 会在背后为我们判断哪些光源会按逐像素处理，而哪些按逐顶点或SH的方式处理。</p>
<blockquote>
<p>由于我们没有更改Edit Project Settings - Quality →Pixel Light Count中的数值,因此默认情况下一个物体可以接收除最亮的平行光外的4个逐像素光照。</p>
</blockquote>
<h3 id="8-3-Unity的光照衰减"><a href="#8-3-Unity的光照衰减" class="headerlink" title="8.3 - Unity的光照衰减"></a>8.3 - Unity的光照衰减</h3><blockquote>
<p>Unity默认使用一张纹理：<code>_LightTexture0</code> 作为查找表来在片元着色器中计算逐像素光照的衰减</p>
</blockquote>
<p>为了对**_LightTexture0**纹理采样得到给定点到该光源的衰减值;首先我们要得到该点在光源空间中的位置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，我们可以使用这个坐标的模的平方对衰减纹理进行采样，得到衰减值</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure>

<p>可以发现，在上面的代码中，我们使用了光源空间中顶点距离的平方(通过dot函数来得到)来对纹理采样，之所以没有使用距离值来采样是因为这种方法可以避免开方操作。然后，我们使用宏<strong>UNITY_ATTEN_CHANNEL</strong> 来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值。</p>
</blockquote>
<h3 id="8-4-Unity的阴影"><a href="#8-4-Unity的阴影" class="headerlink" title="8.4 - Unity的阴影"></a>8.4 - Unity的阴影</h3><h4 id="8-4-1-阴影是如何产生的"><a href="#8-4-1-阴影是如何产生的" class="headerlink" title="8.4.1 - 阴影是如何产生的"></a>8.4.1 - 阴影是如何产生的</h4><p>在实时渲染中，我们最常使用的是一种名为Shadow Map的技术，它的原理是：</p>
<p>首先会把摄像机放在于光源重合的位置，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。</p>
<p>在向前渲染路径中，如果场景中最重要的平行光开启了阴影，Unity就会为该光源计算阴<strong>影映射纹理（Shadowmap）</strong>，它本质上是一张深度图，记录了从该光源位置出发，能够看到的场景中距离它最近的表面位置（深度信息）。</p>
<p>由于我们只需要深度信息，因此Unity使用<strong>LightMode</strong>标签为<strong>ShadowCaster</strong>的Pass来更新<strong>阴影映射纹理</strong>。</p>
<ul>
<li><p>如果我们想要一个物体<strong>接收来自其他物体的阴影</strong>，就必须在Shader中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，然后把采样结果和最后的光照结果相乘来产生阴影效果。</p>
</li>
<li><p>如果我们想要一个物体<strong>向其他物体投射阴影</strong>，就必须把该物体<strong>加入到光源的阴影映射纹理的计算中</strong>，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。</p>
<blockquote>
<p>在Unity中，这个过程是通过为该物体执行<code>LightMode</code>为<code>ShadowCaster</code>的Pass来实现的，如果使用了屏幕空间的投影映射技术，Unity还会使用这个Pass产生一张摄像机的深度纹理。</p>
</blockquote>
</li>
</ul>
<h4 id="8-4-2-不透明物体的阴影"><a href="#8-4-2-不透明物体的阴影" class="headerlink" title="8.4.2 - 不透明物体的阴影"></a>8.4.2 - 不透明物体的阴影</h4><p><strong>1.让物体投射阴影</strong></p>
<blockquote>
<p>在 Unity中,我们可以选择是否让一个物体投射或接收阴影。这是通过设置Mesh Renderer组件中的<code>Cast Shadows</code>和 <code>Receive Shadows</code>属性来实现的。</p>
<p>在光源组件中，将<code>Strength</code>设置为0.3,阴影类型为软阴影</p>
<p>在默认情况下，计算光源的阴影映射纹理会剔除物体的背面，但对于内置的平面来说他只有一个面，在本例中，由于它右侧的平面在光源空间下没有任何正面，因此不会添加到阴影映射纹理中。可以将<code>Cast Shadows</code>设置为<code>Two Sided</code>来允许对物体所有面都计算阴影信息。</p>
</blockquote>
<p>最简单的方法是适合合适的FallBack，Unity会为我们选择<strong>LightMode</strong>为<strong>ShadowCaster</strong>的Pass。</p>
<blockquote>
<p>可以在Untiy的内置着色器中找到他：<code>builtin_shaders-2023.1.2f1 -&gt; DefaultResourcesExtra -&gt; Normal-VertexLit.shader</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Name &quot;ShadowCaster&quot;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br><span class="line">#pragma target 2.0</span><br><span class="line">#pragma multi_compile_shadowcaster</span><br><span class="line">#pragma multi_compile_instancing // allow instanced shadow pass for most of the shaders</span><br><span class="line">#include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line">V2F_SHADOW_CASTER;</span><br><span class="line">UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert( appdata_base v )</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);</span><br><span class="line">TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 frag( v2f i ) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实际作用是将深度信息写入渲染目标中，这个Pass是可以在多个Unity Shader中通用的，因此可以直接使用FallBack回调。</p>
</blockquote>
<p><strong>2.让物体接受阴影</strong></p>
<ol>
<li><p>为<strong>Base Pass</strong>包含一个新的内置文件，这个文件包含我们计算阴影所用的宏</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;AutoLight.cginc&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>为顶点着色器输出结构体<strong>v2f</strong>添加一个内置宏<strong>SHADOW_COORDS</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    SHADOW_COORDS(2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个宏的作用是声明一个用于阴影纹理采样的坐标</li>
<li>它的参数需要的是下一个可用的插值寄存器的索引值，这里是2。</li>
</ul>
</blockquote>
</li>
<li><p>在<strong>顶点着色器</strong>返回之前添加另一个内置宏<strong>TRANSFER_SHADOW</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Pass shadow coordinates to pixel shader</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个宏用于计算在v2f中声明的阴影纹理坐标</p>
</blockquote>
</li>
<li><p>接着，在<strong>片元着色器</strong>中计算阴影值，这里同样使用了一个内置宏<strong>SHADOW_ATTENUATION</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed shadow = SHADOW_ATTENUATION(i);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这些宏会使用上下文变量来进行相关计算，例如<strong>TRANSFER_SHADOW</strong>会使用<code>v.vertex</code>或<code>a.pos</code>来计算，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配。</p>
<p>我们需要保证:<code>a2f</code>结构体中的顶点坐标变量名必须是<code>vertex</code>，顶点着色器的输出结构体<code>v2f</code>必须命名为<code>v</code>，且<code> v2f</code>中的顶点位置变量必须命名为<code>pos</code>.</p>
</blockquote>
</li>
<li><p>完成了上面的操作之后，我们只需要把阴影值<strong>shadow</strong>和<strong>漫反射</strong>以及<strong>高光反射颜色</strong>相乘即可。</p>
</li>
</ol>
<h4 id="8-4-3-统一管理光照衰减和阴影"><a href="#8-4-3-统一管理光照衰减和阴影" class="headerlink" title="8.4.3 - 统一管理光照衰减和阴影"></a>8.4.3 - 统一管理光照衰减和阴影</h4><p><strong>光照衰减</strong>和<strong>阴影</strong>对物体最终的渲染结果的影响本质上是相同的，都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果。在Unity中，提供了一个方法来同时计算两个信息：<strong>UNITY_LIGHT_ATTENUATION</strong></p>
<p>代码与Shadow类似，只有以下部分进行变更：</p>
<ul>
<li><p>在片元着色器中使用宏<strong>UNITY_LIGHT_ATTENUATION</strong>来计算光照衰减和阴影</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"></span><br><span class="line">    // UNITY_LIGHT_ATTENUATION not only compute attenuation, but also shadow infos</span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    return fixed4((diffuse + specular) * atten, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>由于我们使用了<strong>UNITY_LIGHT_ATTENUATION</strong>，我们的<strong>Base Pass</strong>和<strong>Additional Pass</strong>的代码得以统一，不需要在<strong>Base Pass</strong>中单独处理阴影，也不需要在<strong>Additional Pass</strong>中判断光源的类型来处理光照衰减。</p>
<h4 id="8-4-4-透明物体的阴影"><a href="#8-4-4-透明物体的阴影" class="headerlink" title="8.4.4 - 透明物体的阴影"></a>8.4.4 - 透明物体的阴影</h4><blockquote>
<p>对于大多数不透明物体来说，把 Fallback 设为VertexLit 就可以得到正确的阴影。但对于透明物体来说，我们就需要小心处理它的阴影。透明物体的实现通常会使用透明度测试或透明度混合，我们需要小心设置这些物体的FallBack,</p>
</blockquote>
<p><strong>Alpha Test</strong></p>
<p>Shader：<strong>Chapter9-AlphaTestWithShadow</strong></p>
<ul>
<li><p>沿用了之前的<strong>Chapter8-AlphaTest</strong>的代码，在此基础上添加AutoLight内置文件以及宏，详见8.4.2 - 不透明物体的阴影 - 让物体接受阴影</p>
</li>
<li><p>并且更改回调函数为</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure>

<p>如果使用了VertexLit，由于这个Pass没有进行任何透明的测试的计算，会把整个物体的深度信息渲染到深度图和阴影映射纹理中，会产生错误的结果。</p>
<p>由于一些面背对光源，没有进入阴影映射纹理的计算中，可以使<strong>Mesh Renderer</strong>中的<strong>Cast Shadows</strong>属性设置为<strong>Two Sided</strong>，强制计算所有面的深度信息。</p>
</blockquote>
</li>
</ul>
<p><strong>Alpha Blend</strong></p>
<blockquote>
<p>在Unity中，所有内置的半透明Shader是不会产生任何阴影效果的，我们可以使用一些dirty trick来强制为半透明物体生成阴影：比如将他们的FallBack设置为VertexLit，Diffuse这些不透明物体使用的Shader。</p>
</blockquote>
<h3 id="8-5-标准Unity-Shader"><a href="#8-5-标准Unity-Shader" class="headerlink" title="8.5 - 标准Unity Shader"></a>8.5 - 标准Unity Shader</h3><p>本书提供了两个这样标准的Unity Shader—<strong>BumpedDiffuse</strong>和 <strong>BumpedSpecular</strong>。这两个Unity Shader都包含了对法线纹理、多光源、光照衰减和阴影的相关处理，唯一不同的是，<strong>BumpedDifuse</strong>使用了<strong>Phong光照模型</strong>，而<strong>BumpedSpecular</strong>使用了<strong>Blinn-Phong光照模型</strong>。</p>
<h2 id="9-高级纹理"><a href="#9-高级纹理" class="headerlink" title="9 - 高级纹理"></a>9 - 高级纹理</h2><h3 id="9-1-立方体纹理"><a href="#9-1-立方体纹理" class="headerlink" title="9.1 - 立方体纹理"></a>9.1 - 立方体纹理</h3><p>在图形学中,立方体纹理（Cubemap)是环境映射（Environment Mapping）的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层<strong>金属</strong>一样反射出周围的环境。</p>
<ul>
<li>使用立方体纹理的好处在于,它的实现简单快速,而且得到的效果也比较好。</li>
<li>但它也有一些缺点,例如当场景中引入了新的物体、光源,或者物体发生移动时,我们就需要重新生成立方体纹理。</li>
</ul>
<blockquote>
<p>除此之外，立方体纹理也仅可以反射环境,但不能反射使用了该立方体纹理的物体本身。这是因为，立方体纹理不能模拟多次反射的结果，例如两个金属球互相反射的情况.想要得到令人信服的渲染结果，我们应该尽量对凸面体而不要对凹面体使用立方体纹理(因为凹面体会反射自身)。</p>
</blockquote>
<p>常见的立方体纹理应用有以下几种：</p>
<ul>
<li><p>天空盒</p>
</li>
<li><p>环境映射</p>
<blockquote>
<p>在 Unity 5中，创建用于环境映射的立方体纹理的方法有三种:</p>
<p>第一种方法是直接由一些特殊布局的纹理创建;</p>
<p>第二种方法是手动创建一个Cubemap资源，再把6张图赋给它;</p>
<p>第三种方法是由脚本生成。</p>
</blockquote>
</li>
<li><p>反射</p>
</li>
<li><p>折射</p>
</li>
<li><p>菲涅尔反射</p>
</li>
</ul>
<h4 id="9-1-1-反射"><a href="#9-1-1-反射" class="headerlink" title="9.1.1 - 反射"></a>9.1.1 - 反射</h4><p>Shader：<strong>Chapter10-Reflection</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _ReflectColor (&quot;Reflect Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line"> _ReflectAmount (&quot;Reflect Amount&quot;, Range(0, 1)) = 1</span><br><span class="line"> _Cubemap (&quot;Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，**_ReflectColor<strong>用于控制反射颜色，</strong>_ReflectAmount<strong>用于控制这个材质的反射程度，</strong>_Cubemap**就是用于模拟反射的环境映射纹理。</p>
</blockquote>
</li>
<li><p>我们在顶点着色器中计算了该顶点处的反射方向，这是通过使用CG的<strong>reflect函数</strong>来实现的:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> o.worldNormal = UnityObjectToWorldNormal(v.vertex);</span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"> o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line"></span><br><span class="line"> o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物体反射到摄像机中的光线方向，可以由光路可逆的原则来反向求得。也就是说，我们可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。</p>
</blockquote>
</li>
<li><p>在片元着色器中，可以利用反射方向来对立方体纹理采样</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"> fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"> // Use the reflect dir in world space to access the cubemap</span><br><span class="line"> fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line"></span><br><span class="line"> UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line"> // Mix the diffuse color with the reflected color</span><br><span class="line"> fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line"></span><br><span class="line"> return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对立方体纹理的采样需要使用CG的<strong>texCUBE</strong>函数。注意，在上面的计算中，我们在采样时并没有对<code>i.worldRefl</code>进行归一化操作。这是因为,用于采样的参数仅仅是作为方向变量传递给<strong>texCUBE</strong> 函数的，因此我们没有必要进行一次归一化的操作。</p>
<p>然后，我们使用<strong>ReflectAmount</strong>来混合漫反射颜色和反射颜色，并和环境光照相加后返回。</p>
</blockquote>
</li>
<li><p>选择Cubemap到材质中。</p>
</li>
</ol>
<h4 id="9-1-2-折射"><a href="#9-1-2-折射" class="headerlink" title="9.1.2 - 折射"></a>9.1.2 - 折射</h4><p>当给定入射角时，根据斯涅耳定律（Snell’s Law）可以计算反射角时，当光从介质1沿着和表面法线夹角为θ1的方向斜射入介质2时，我们可以使用如下公式计算折射光线与法线的夹角θ2：<br>$$<br>\eta_1 sin\theta_1 = \eta_2 sin\theta_2<br>$$</p>
<blockquote>
<p>其中，η1和η2分别是两个介质的折射率(index of refraction)。折射率是一项重要的物理常数，例如真空的折射率是1，而玻璃的折射率一般是1.5。<br>通常来说，当得到折射方向后我们就会直接使用它来对立方体纹理进行采样，但这是不符合物理规律的。对一个透明物体来说，一种更准确的模拟方法需要计算两次折射—一次是当光线进入它的内部时，而另一次则是从它内部射出时。但是，想要在实时渲染中模拟出第二次折射方向是比较复杂的，而且仅仅模拟一次得到的效果从视觉上看起来“也挺像那么回事的”。正如我们之前提到的——图形学第一准则“如果它看起来是对的，那么它就是对的”。因此，在实时渲染中我们通常仅模拟第一次折射。</p>
</blockquote>
<p>Shader：<strong>Chapter10-Refraction</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _RefractColor (&quot;Refract Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)</span><br><span class="line"> _RefractAmount (&quot;Refract Amount&quot;, Range(0, 1)) = 1</span><br><span class="line"> _RefractRatio (&quot;Refract Ratio&quot; , Range(0.1 ,1)) = 0.5</span><br><span class="line"> _Cubemap (&quot;Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>RefractColor</strong>、<strong>RefractAmount</strong>和 <strong>Cubemap</strong> 与反射一节中控制反射时使用的属性类似。<br>除此之外，我们还使用了一个属性 <strong>RefractRatio</strong>，我们需要使用该属性得到不同介质的透射比，以此来计算折射方向。</p>
</blockquote>
</li>
<li><p>我们在顶点着色器中计算了折射方向</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(appdata v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line"> o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line"></span><br><span class="line"> // Compute the refract dir in world space</span><br><span class="line"> o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了CG的<strong>refract</strong>函数来计算折射方向。</p>
<p>它的第一个参数即为入射光线的方向，它必须是归一化后的矢量;</p>
<p>第二个参数是表面法线，法线方向同样需要是归一化后的;</p>
<p>第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值，例如如果光是从空气射到玻璃表面，那么这个参数应该是空气的折射率和玻璃的折射率之间的比值，即1/1.5。</p>
<p>它的返回值就是计算而得的折射方向，它的模则等于入射光线的模。</p>
</blockquote>
</li>
<li><p>在片元着色器中，可以利用折射方向来对立方体纹理采样</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"> fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"> // Use the refract dir in world space to access the cubemap</span><br><span class="line"> fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line"></span><br><span class="line"> UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line"> // Mix the diffuse color with the refract color</span><br><span class="line"> fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line"></span><br><span class="line"> return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，我们也没有对<code>i.worldRefr</code>进行归一化操作，因为对立方体纹理的采样只需要提供方向即可。最后，我们使用<strong>RefractAmount</strong>来混合漫反射颜色和折射颜色，并和环境光照相加后返回。</p>
</blockquote>
</li>
<li><p>选择Cubemap到材质中。</p>
</li>
</ol>
<h4 id="9-1-3-菲涅尔反射"><a href="#9-1-3-菲涅尔反射" class="headerlink" title="9.1.3 - 菲涅尔反射"></a>9.1.3 - 菲涅尔反射</h4><p>这是基于物理的渲染中非常重要的一项高光反射计算因子。通俗地讲，菲涅耳反射描述了一种光学现象，即当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比率关系可以通过菲涅耳等式进行计算。</p>
<blockquote>
<p>参考阅读：<a target="_blank" rel="noopener" href="http://filmicworlds.com/blog/everything-has-fresnel/">http://filmicworlds.com/blog/everything-has-fresnel/</a></p>
</blockquote>
<p>那么，我们如何计算菲涅耳反射呢?这就需要使用菲涅耳等式。真实世界的菲涅耳等式是非常复杂的,但在实时渲染中,我们通常会使用<br>一些近似公式来计算。其中一个著名的近似公式就是 Schlick菲涅耳近似等式:<br>$$<br>F_{schlick}(v, n) = F_0 + (1 - F_0)(1 - v \cdot n)^5<br>$$<br>使用上面的菲涅耳近似等式，我们可以在边界处模拟反射光强和折射光强/漫反射光强之间的变化。在许多车漆、水面等材质的渲染中，我们会经常使用菲涅耳反射来模拟更加真实的反射效果。</p>
<p>Shader：<strong>Chapter10-Refraction</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _FresnelScale (&quot;Fresnel Scale&quot;, Range(0, 1)) = 1</span><br><span class="line"> _Cubemap (&quot;Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>我们在顶点着色器中计算了法线方向、视角方向以及反射方向</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> o.worldNormal = UnityObjectToWorldNormal(v.vertex);</span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"> o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line"></span><br><span class="line"> o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在片元着色器中计算菲涅尔反射，并使用结果值混合漫反射光在和反射光照</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"> fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"> UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line"> fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line"> fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5);</span><br><span class="line"></span><br><span class="line"> fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"> fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line"></span><br><span class="line"> return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用<strong>Schlick 菲涅耳近似等式</strong>来计算<strong>fresnel</strong>变量，并使用它来混合漫反射光照和反射光照。一些实现也会直接把 fresnel和反射光照相乘后叠加到漫反射光照上，模拟边缘光照的效果。</p>
<p>当我们把**_FresnelScale<strong>调节到</strong>1<strong>时，物体将完全反射Cubemap中的图像;当</strong>_FresnelScale<strong>为</strong>0**时，则是一个具有边缘光照效果的漫反射物体。</p>
</blockquote>
</li>
<li><p>选择Cubemap到材质中。</p>
</li>
</ol>
<h3 id="9-2-渲染纹理"><a href="#9-2-渲染纹理" class="headerlink" title="9.2 - 渲染纹理"></a>9.2 - 渲染纹理</h3><h4 id="9-2-1-镜子效果"><a href="#9-2-1-镜子效果" class="headerlink" title="9.2.1 - 镜子效果"></a>9.2.1 - 镜子效果</h4><p>Shader：<strong>Chapter10-Mirror</strong></p>
<ol>
<li><p>准备好场景，创建一个<strong>Render Texture</strong>，以及准备一个用于观察场景的摄像机。</p>
</li>
<li><p>在顶点着色器中翻转uv的x，因为镜子中显示的图像是左右相反的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line"> o.uv.x = 1 - o.uv.x; </span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在片元着色器中对渲染纹理进行采用，将纹理拖入材质中。</p>
</li>
</ol>
<h4 id="9-2-2-玻璃效果"><a href="#9-2-2-玻璃效果" class="headerlink" title="9.2.2 - 玻璃效果"></a>9.2.2 - 玻璃效果</h4><p>Shader：<strong>Chapter10-GlassRefraction</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line"> _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line"> _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line"> _Distortion (&quot;Distortion&quot;, Range(0, 100)) = 10</span><br><span class="line"> _RefractAmount (&quot;Refract Amount&quot;, Range(0.0, 1.0)) = 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，**_MainTex**是该玻璃的材质纹理，默认为白色纹理;</p>
<p><strong>_BumpMap</strong>是玻璃的法线纹理;<br><strong>_Cubemap</strong>是用于模拟反射的环境纹理;</p>
<p><strong>_Distortion</strong>则用于控制模拟折射时图像的扭曲程度;<br><strong>_RefractAmount</strong>用于控制折射程度，当**_RefractAmount<strong>值为0时，该玻璃只包含反射效果当</strong>_RefractAmount**值为1时,该玻璃只包括折射效果。</p>
</blockquote>
</li>
<li><p>定义相应的渲染队列，并使用GrabPass来获取屏幕图像</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// We must be transparent, so other objects are drawn before this one.</span><br><span class="line">Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line"></span><br><span class="line">// This pass grabs the screen behind the object into a texture.</span><br><span class="line">// We can access the result in the next pass as _RefractionTex</span><br><span class="line">GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先在SubShader的标签中将渲染队列设置成<strong>Transparent</strong>，尽管在后面的RenderType被设置为了 <strong>Opaque</strong>。这两者看似矛盾，但实际上服务于不同的需求。我们在之前说过，把<strong>Queue</strong>设置成<strong>Transparent</strong>可以确保该物体渲染时，其他所有不透明物体都已经被渲染到屏幕上了否则就可能无法正确得到“透过玻璃看到的图像”。而设置 RenderType 则是为了在使用着色器替换<br>(Shader Replacement）时，该物体可以在需要时被正确渲染。这通常发生在我们需要得到摄像机的深度和法线纹理时。</li>
<li>随后,我们通过关键词 <strong>GrabPass</strong>定义了个抓取屏幕图像的 Pass。在这个 Pass中我们定义了一个字符串，该字符串内部的名称决定了抓取得到的屏幕图像将会被存入哪个纹理中。实际上,我们可以省略声明该字符串，但直接声明纹理名称的方法往往可以得到更高的性能。</li>
</ul>
</blockquote>
</li>
<li><p>定义变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">float4 _BumpMap_ST;</span><br><span class="line">samplerCUBE _Cubemap;</span><br><span class="line">float _Distortion;</span><br><span class="line">fixed _RefractAmount;</span><br><span class="line">sampler2D _RefractionTex;</span><br><span class="line">float4 _RefractionTex_TexelSize;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们还定义了**_RefractionTex<strong>和</strong>_RefractionTex_TexelSize<strong>变量，这对应了在使用</strong>GrabPass<strong>时指定的纹理名称。</strong>RefractionTex_ TexelSize**可以让我们得到该纹理的纹素大小,例如一个大小为256×512的纹理，它的纹素大小为(1/256,1/512)。我们需要在对屏幕图像的采样坐标进行偏移时使用该变量。</p>
</blockquote>
</li>
<li><p>定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line"></span><br><span class="line"> o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"> o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line"></span><br><span class="line"> float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line"> fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line"> fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line"> fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line"></span><br><span class="line"> o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line"> o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line"> o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行了必要的顶点坐标变换后,我们通过调用内置的<strong>ComputeGrabScreenPos</strong>函数来得到对应被抓取的屏幕图像的采样坐标。可以在UnityCG.cginc文件中找到它的声明，它的主要代码和<strong>ComputeScreenPos</strong>基本类似，最大的不同是针对平台差异造成的采样坐标问题进行了处理。</p>
<p>接着，我们计算了<strong>MainTex</strong> 和<strong>BumpMap</strong>的采样坐标，并把它们分别存储在一一个float4类型变量的<strong>xy</strong>和<strong>zw</strong>分量中。由于我们需要<strong>在片元着色器中把法线方向从切线空间(由法线纹理采样得到)变换到世界空间下，以便对Cubemap进行采样</strong>，因此，我们需要在这里计算该顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在TtoW0、TtoW1和TtoW2的xyz分量中。这里面使用的数学方法就是，得到切线空间下的3个坐标轴(xyz 轴分别对应了副切线、切线和法线的方向)在世界空间下的表示，再把它们依次按列组成-一个变换矩阵即可。TtoW0 等值的w轴同样被利用起来，用于存储世界空间下的顶点坐标。</p>
</blockquote>
</li>
<li><p>定义片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target &#123;		</span><br><span class="line"> float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line"> fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line"> // Get the normal in tangent space</span><br><span class="line"> fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));	</span><br><span class="line"></span><br><span class="line"> // Compute the offset in tangent space</span><br><span class="line"> float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line"> i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;</span><br><span class="line"> fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line"></span><br><span class="line"> // Convert the normal to world space</span><br><span class="line"> bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"> fixed3 reflDir = reflect(-worldViewDir, bump);</span><br><span class="line"> fixed4 texColor = tex2D(_MainTex, i.uv.xy);</span><br><span class="line"> fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;</span><br><span class="line"></span><br><span class="line"> fixed3 finalColor = reflCol * (1 - _RefractAmount) + refrCol * _RefractAmount;</span><br><span class="line"></span><br><span class="line"> return fixed4(finalColor, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先通过TtoW0等变量的w分量得到世界坐标，并用该值得到该片元对应的视角方向。<br>随后，我们对法线纹理进行采样，得到切线空间下的法线方向。我们使用该值和 <strong>Distortion</strong>属性以及**_RefractionTex_TexelSize<strong>来对屏幕图像的采样坐标进行偏移，模拟折射效果。</strong>_Distortion<strong>值越大，</strong>偏移量越大<strong>，</strong>玻璃背后的物体看起来变形程度越大**。在这里，我们选择使用切线空间下的法线方向来进行偏移，是因为该空间下的法线可以反映顶点局部空间下的法线方向。</p>
<p>随后，我们对scrPos透视除法得到真正的屏幕坐标，再使用该坐标对抓取的屏幕图像**_RefractionTex<strong>进行采样，得到模拟的折射颜色。之后，我们把法线方向从切线空间变换到了世界空间下（使用变换矩阵的每一行,即TtoWo、TtoW1 和TtoW2,分别和法线方向点乘,构成新的法线方向)，并据此得到视角方向相对于法线方向的反射方向。随后，使用反射方向对 Cubemap进行采样，并把结果和主纹理颜色相乘后得到反射颜色。<br>最后，我们使用</strong>RefractAmount<strong>属性对反射和折射颜色进行混合，作为最终的输出颜完成后,我们把本书资源中的Glass Diffuse.jpg和 Glass Normal.jpg文件赋给材质的Main Tex和 Normal Map属性，把之前创建的 <strong>Glass Cubemap</strong>赋给 <strong>Environment Cubemap</strong>属性，再调整</strong>RefractAmount**属性即可得到类似图10.13 中的玻璃效果。</p>
</blockquote>
</li>
<li><p>选择MainTex、Normal map、Cubemap到材质中。</p>
</li>
</ol>
<h4 id="9-2-3-渲染纹理-VS-GrabPass"><a href="#9-2-3-渲染纹理-VS-GrabPass" class="headerlink" title="9.2.3 - 渲染纹理 VS. GrabPass"></a>9.2.3 - 渲染纹理 VS. GrabPass</h4><p>Grap Pass和渲染纹理都可以抓取屏幕图像，但是他们之间有一些不同：</p>
<ul>
<li>GrabPass实现简单，渲染纹理需要额外创建渲染纹理以及摄像机</li>
<li>效率上渲染纹理好于GrabPass。</li>
</ul>
<h4 id="9-2-4-使用程序生成Cubemap"><a href="#9-2-4-使用程序生成Cubemap" class="headerlink" title="9.2.4 - 使用程序生成Cubemap"></a>9.2.4 - 使用程序生成Cubemap</h4><p>包含以下文件：</p>
<ul>
<li>Editor-&gt;RenderCubemapWizard</li>
<li>Script-&gt;ProceduralTextureGeneration</li>
</ul>
<p>需要以上文件才能在菜单栏的<code>GameObject-&gt;Render into Cubemap</code>中执行。</p>
<p><strong>RenderCubemapWizard：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RenderCubemapWizard</span> : <span class="title">ScriptableWizard</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Transform renderFromPosition;</span><br><span class="line">   <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span> ()</span> &#123;</span><br><span class="line">      helpString = <span class="string">&quot;Select transform to render from and cubemap to render into&quot;</span>;</span><br><span class="line">      isValid = (renderFromPosition != <span class="literal">null</span>) &amp;&amp; (cubemap != <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span> ()</span> &#123;</span><br><span class="line">      <span class="comment">// create temporary camera for rendering</span></span><br><span class="line">      GameObject go = <span class="keyword">new</span> GameObject( <span class="string">&quot;CubemapCamera&quot;</span>);</span><br><span class="line">      go.AddComponent&lt;Camera&gt;();</span><br><span class="line">      <span class="comment">// place it on the object</span></span><br><span class="line">      go.transform.position = renderFromPosition.position;</span><br><span class="line">      <span class="comment">// render into cubemap    </span></span><br><span class="line">      go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// destroy temporary camera</span></span><br><span class="line">      DestroyImmediate( go );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   [<span class="meta">MenuItem(<span class="string">&quot;GameObject/Render into Cubemap&quot;</span>)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCubemap</span> ()</span> &#123;</span><br><span class="line">      ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(</span><br><span class="line">         <span class="string">&quot;Render cubemap&quot;</span>, <span class="string">&quot;Render!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProceduralTextureGeneration：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Serialization;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProceduralTextureGeneration</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Material material = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">region</span> Material properties</span></span><br><span class="line">   </span><br><span class="line">   [<span class="meta">FormerlySerializedAs(<span class="string">&quot;textureWidth&quot;</span>)</span>]</span><br><span class="line">   [<span class="meta">SerializeField</span>]</span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">int</span> m_textureWidth = <span class="number">512</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> textureWidth &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> m_textureWidth;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         m_textureWidth = <span class="keyword">value</span>;</span><br><span class="line">         _UpdateMaterial();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   [<span class="meta">FormerlySerializedAs(<span class="string">&quot;backgroundColor&quot;</span>)</span>]</span><br><span class="line">   [<span class="meta">SerializeField</span>]</span><br><span class="line">   <span class="keyword">private</span> Color m_backgroundColor = Color.white;</span><br><span class="line">   <span class="keyword">public</span> Color backgroundColor &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> m_backgroundColor;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         m_backgroundColor = <span class="keyword">value</span>;</span><br><span class="line">         _UpdateMaterial();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   [<span class="meta">FormerlySerializedAs(<span class="string">&quot;circleColor&quot;</span>)</span>]</span><br><span class="line">   [<span class="meta">SerializeField</span>]</span><br><span class="line">   <span class="keyword">private</span> Color m_circleColor = Color.yellow;</span><br><span class="line">   <span class="keyword">public</span> Color circleColor &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> m_circleColor;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         m_circleColor = <span class="keyword">value</span>;</span><br><span class="line">         _UpdateMaterial();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   [<span class="meta">FormerlySerializedAs(<span class="string">&quot;blurFactor&quot;</span>)</span>]</span><br><span class="line">   [<span class="meta">SerializeField</span>]</span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">float</span> m_blurFactor = <span class="number">2.0f</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> blurFactor &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> m_blurFactor;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         m_blurFactor = <span class="keyword">value</span>;</span><br><span class="line">         _UpdateMaterial();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Texture2D m_generatedTexture = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Use this for initialization</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">         Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">         <span class="keyword">if</span> (renderer == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;Cannot find a renderer.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         material = renderer.sharedMaterial;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _UpdateMaterial();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> _UpdateMaterial() &#123;</span><br><span class="line">      <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">         m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">         material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, m_generatedTexture);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="built_in">float</span> mixFactor) &#123;</span><br><span class="line">      Color mixColor = Color.white;</span><br><span class="line">      mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">      mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">      mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">      mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">      <span class="keyword">return</span> mixColor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">      Texture2D proceduralTexture = <span class="keyword">new</span> Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The interval between circles</span></span><br><span class="line">      <span class="built_in">float</span> circleInterval = textureWidth / <span class="number">4.0f</span>;</span><br><span class="line">      <span class="comment">// The radius of circles</span></span><br><span class="line">      <span class="built_in">float</span> radius = textureWidth / <span class="number">10.0f</span>;</span><br><span class="line">      <span class="comment">// The blur factor</span></span><br><span class="line">      <span class="built_in">float</span> edgeBlur = <span class="number">1.0f</span> / blurFactor;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; textureWidth; w++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; textureWidth; h++) &#123;</span><br><span class="line">            <span class="comment">// Initalize the pixel with background color</span></span><br><span class="line">            Color pixel = backgroundColor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Draw nine circles one by one</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                  <span class="comment">// Compute the center of current circle</span></span><br><span class="line">                  Vector2 circleCenter = <span class="keyword">new</span> Vector2(circleInterval * (i + <span class="number">1</span>), circleInterval * (j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// Compute the distance between the pixel and the center</span></span><br><span class="line">                  <span class="built_in">float</span> dist = Vector2.Distance(<span class="keyword">new</span> Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// Blur the edge of the circle</span></span><br><span class="line">                  Color color = _MixColor(circleColor, <span class="keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="number">0.0f</span>), Mathf.SmoothStep(<span class="number">0f</span>, <span class="number">1.0f</span>, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// Mix the current color with the previous color</span></span><br><span class="line">                  pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      proceduralTexture.Apply();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> proceduralTexture;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="9-3-程序纹理"><a href="#9-3-程序纹理" class="headerlink" title="9.3 - 程序纹理"></a>9.3 - 程序纹理</h3><p>**程序纹理（Procedural Texture)**指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素,例如木头、石子等。</p>
<p>使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些属性不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，这使得我们可以得到更加丰富的动画和视觉效果。</p>
<h4 id="9-3-1-在Unity中实现简单的程序纹理"><a href="#9-3-1-在Unity中实现简单的程序纹理" class="headerlink" title="9.3.1 - 在Unity中实现简单的程序纹理"></a>9.3.1 - 在Unity中实现简单的程序纹理</h4><blockquote>
<p><strong>SetProperty</strong>无法使用，该插件可以当我们修改了材质属性时，执行set中的_UpdateMaterial函数来使用新的属性重新生成程序纹理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine.Serialization;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line">public class ProceduralTextureGeneration : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">public Material material = null;</span><br><span class="line"></span><br><span class="line">#region Material properties</span><br><span class="line"></span><br><span class="line">[FormerlySerializedAs(&quot;textureWidth&quot;)]</span><br><span class="line">[SerializeField]</span><br><span class="line">private int m_textureWidth = 512;</span><br><span class="line">public int textureWidth &#123;</span><br><span class="line">   get &#123;</span><br><span class="line">      return m_textureWidth;</span><br><span class="line">   &#125;</span><br><span class="line">   set &#123;</span><br><span class="line">      m_textureWidth = value;</span><br><span class="line">      _UpdateMaterial();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[FormerlySerializedAs(&quot;backgroundColor&quot;)]</span><br><span class="line">[SerializeField]</span><br><span class="line">private Color m_backgroundColor = Color.white;</span><br><span class="line">public Color backgroundColor &#123;</span><br><span class="line">   get &#123;</span><br><span class="line">      return m_backgroundColor;</span><br><span class="line">   &#125;</span><br><span class="line">   set &#123;</span><br><span class="line">      m_backgroundColor = value;</span><br><span class="line">      _UpdateMaterial();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[FormerlySerializedAs(&quot;circleColor&quot;)]</span><br><span class="line">[SerializeField]</span><br><span class="line">private Color m_circleColor = Color.yellow;</span><br><span class="line">public Color circleColor &#123;</span><br><span class="line">   get &#123;</span><br><span class="line">      return m_circleColor;</span><br><span class="line">   &#125;</span><br><span class="line">   set &#123;</span><br><span class="line">      m_circleColor = value;</span><br><span class="line">      _UpdateMaterial();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[FormerlySerializedAs(&quot;blurFactor&quot;)]</span><br><span class="line">[SerializeField]</span><br><span class="line">private float m_blurFactor = 2.0f;</span><br><span class="line">public float blurFactor &#123;</span><br><span class="line">   get &#123;</span><br><span class="line">      return m_blurFactor;</span><br><span class="line">   &#125;</span><br><span class="line">   set &#123;</span><br><span class="line">      m_blurFactor = value;</span><br><span class="line">      _UpdateMaterial();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">private Texture2D m_generatedTexture = null;</span><br><span class="line"></span><br><span class="line">// Use this for initialization</span><br><span class="line">void Start () &#123;</span><br><span class="line">   if (material == null) &#123;</span><br><span class="line">      Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">      if (renderer == null) &#123;</span><br><span class="line">         Debug.LogWarning(&quot;Cannot find a renderer.&quot;);</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      material = renderer.sharedMaterial;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   _UpdateMaterial();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void _UpdateMaterial() &#123;</span><br><span class="line">   if (material != null) &#123;</span><br><span class="line">      m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">      material.SetTexture(&quot;_MainTex&quot;, m_generatedTexture);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Color _MixColor(Color color0, Color color1, float mixFactor) &#123;</span><br><span class="line">   Color mixColor = Color.white;</span><br><span class="line">   mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">   mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">   mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">   mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">   return mixColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">   Texture2D proceduralTexture = new Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">   // The interval between circles</span><br><span class="line">   float circleInterval = textureWidth / 4.0f;</span><br><span class="line">   // The radius of circles</span><br><span class="line">   float radius = textureWidth / 10.0f;</span><br><span class="line">   // The blur factor</span><br><span class="line">   float edgeBlur = 1.0f / blurFactor;</span><br><span class="line"></span><br><span class="line">   for (int w = 0; w &lt; textureWidth; w++) &#123;</span><br><span class="line">      for (int h = 0; h &lt; textureWidth; h++) &#123;</span><br><span class="line">         // Initalize the pixel with background color</span><br><span class="line">         Color pixel = backgroundColor;</span><br><span class="line"></span><br><span class="line">         // Draw nine circles one by one</span><br><span class="line">         for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">               // Compute the center of current circle</span><br><span class="line">               Vector2 circleCenter = new Vector2(circleInterval * (i + 1), circleInterval * (j + 1));</span><br><span class="line"></span><br><span class="line">               // Compute the distance between the pixel and the center</span><br><span class="line">               float dist = Vector2.Distance(new Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">               // Blur the edge of the circle</span><br><span class="line">               Color color = _MixColor(circleColor, new Color(pixel.r, pixel.g, pixel.b, 0.0f), Mathf.SmoothStep(0f, 1.0f, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">               // Mix the current color with the previous color</span><br><span class="line">               pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   proceduralTexture.Apply();</span><br><span class="line"></span><br><span class="line">   return proceduralTexture;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="9-3-2-Unity的程序材质"><a href="#9-3-2-Unity的程序材质" class="headerlink" title="9.3.2 - Unity的程序材质"></a>9.3.2 - Unity的程序材质</h4><p>使用<strong>Substance Designer</strong>可以生成程序材质，这些材质都是以<code>.sbsar</code>为后缀的，导入Unity后就会生成一个程序纹理资源。</p>
<p>程序材质自由度很高，调整属性可以得到不同的材质效果。</p>
<h2 id="10-画面动效"><a href="#10-画面动效" class="headerlink" title="10 - 画面动效"></a>10 - 画面动效</h2><h3 id="10-1-Unity的内置时间变量"><a href="#10-1-Unity的内置时间变量" class="headerlink" title="10.1 - Unity的内置时间变量"></a>10.1 - Unity的内置时间变量</h3><blockquote>
<p>动画效果往往都是把时间添加到一些变量的计算中,以便在时间变化时画面也可以随之变化。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_Time</td>
<td>float4</td>
<td>t是自该场景加载开始所经过的时间，4个分量的值分别是(t/20, t, 2t, 3t)。</td>
</tr>
<tr>
<td>_SinTime</td>
<td>float4</td>
<td>t是时间的正弦值，4个分量的值分别是(t/8, t/4, t/2,t)</td>
</tr>
<tr>
<td>_CosTime</td>
<td>float4</td>
<td>t是时间的余弦值,4个分量的值分别是(t/8, t/4,t/2, t)</td>
</tr>
<tr>
<td>unity_DeltaTime</td>
<td>float4</td>
<td>dt是时间增量，4个分量的值分别是(dt, 1/dt, smoothDt, 1/smoothDt)</td>
</tr>
</tbody></table>
<h3 id="10-2-纹理动画"><a href="#10-2-纹理动画" class="headerlink" title="10.2 - 纹理动画"></a>10.2 - 纹理动画</h3><h4 id="10-2-1-序列帧动画"><a href="#10-2-1-序列帧动画" class="headerlink" title="10.2.1 - 序列帧动画"></a>10.2.1 - 序列帧动画</h4><p>最常见的纹理动画之一就是序列帧动画。序列帧动画的原理非常简单，它像放电影一样，依次播放一系列关键帧图像，当播放速度达到一定数值时，看起来就是一个连续的动画。</p>
<p>它的优点在于灵活性很强，我们不需要进行任何物理计算就可以得到非常细腻的动画效果。</p>
<p>而它的缺点也很明显，由于序列帧中每张关键帧图像都不一样。因此,要制作一张出色的序列帧纹理所需要的美术工程量也比较大。</p>
<p>Shader：<strong>Chapter11-ImageSequenceAnimation</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">  _Color (&quot;Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = 4</span><br><span class="line"> _VerticalAmount (&quot;Vertical Amount&quot;, Float) = 4</span><br><span class="line"> _Speed (&quot;Speed&quot;, Range(1, 100)) = 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>_MainTex</strong>就是包含了所有关键帧图像的纹理，**_HorizontalAmount<strong>和</strong>_VerticalAmount<strong>分别代表水平和垂直方向上包含的关键帧图像个数。</strong>_Speed**用于控制序列帧动画播放的速度。</p>
</blockquote>
</li>
<li><p>由于帧序列图像是透明纹理，我们需要设置Pass相关状态以渲染透明效果。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line"> &#123;</span><br><span class="line">     Tags &#123; </span><br><span class="line">         &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">         &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">         &quot;RenderType&quot;=&quot;Transparent&quot;  </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     Pass</span><br><span class="line">     &#123;</span><br><span class="line">         Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">         ZWrite off</span><br><span class="line">         Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure>

<p>由于序列帧图像通常包含了透明通道，因此可以被当成是一个<strong>半透明对象</strong>。在这里我们使用半透明的“标配”来设置它的SubShader标签，即把 Queue和 RenderType设置成 Transparent,把IgnoreProjector 设置为True。在 Pass中，我们使用Blend命令来开启并设置混合模式，同时关闭了深度写入。</p>
</blockquote>
</li>
<li><p>在顶点着色器只进行基本的顶点变换，并把纹理坐标存到v2f的结构体中。</p>
</li>
<li><p>在片元着色器中计算动画</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> float time = floor(_Time.y * _Speed);</span><br><span class="line"> float row = floor(time / _HorizontalAmount);</span><br><span class="line"> float column = time - row * _VerticalAmount;</span><br><span class="line"></span><br><span class="line"> // half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount);</span><br><span class="line"> // uv.x += column / _HorizontalAmount;</span><br><span class="line"> // uv.y -= row / _VerticalAmount;</span><br><span class="line"> half2 uv = i.uv + half2(column, -row);</span><br><span class="line"> uv.x /= _HorizontalAmount;</span><br><span class="line"> uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line"> fixed4 col = tex2D(_MainTex, uv);</span><br><span class="line"> col.rgb *= _Color;</span><br><span class="line"></span><br><span class="line"> return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由上一节可知，<code>_Time.y</code>就是自场景加载后经过的时间，把<code>_Time.y </code>乘以 <code>_Speed</code>可以得到模拟的时间。并使用floor函数对结果取整可以得到整数时间Time。</p>
</li>
<li><p>使用time除以_HorizontalAmount，<strong>余数</strong>则是列索引。</p>
</li>
<li><p>使用行列索引来取得真正的采样坐标。首先我们将原来的纹理坐标按行数和列数进行等分，然后我们使用row和column对结果进行偏移。</p>
<p>需要注意的是，在竖直方向上进行等分需要用减法，这是因为Unity中的纹理坐标方向顺序和帧序列中的顺序是相反的。</p>
</li>
<li><p>我们可以将上面注释的代码进行整合，得到以下的代码。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>设置FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Transparent/vertexLit&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h4 id="10-2-2-滚动的背景"><a href="#10-2-2-滚动的背景" class="headerlink" title="10.2.2 - 滚动的背景"></a>10.2.2 - 滚动的背景</h4><blockquote>
<p>本节的纹理资源来自OpenGameArt：<a target="_blank" rel="noopener" href="http://opengameart.org/">http://opengameart.org</a></p>
</blockquote>
<p>Shader：<strong>Chapter11-ScrollingBackground</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Base Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _DetailTex (&quot;2nd Layer&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _ScollX (&quot;Base layer scroll speed&quot;, Float) = 1.0</span><br><span class="line"> _Scoll2X (&quot;2nd layer scroll speed&quot;, Float) = 1.0</span><br><span class="line"> _Multiplier (&quot;Layer Multiplier&quot;, Float) =1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>_MainTex</strong>对应的是底层的背景，**_DetailTex<strong>对应的是顶层的背景，</strong>_ScollX<strong>和</strong>_Scoll2X<strong>对应各自的水平移动速度，</strong>_Multiplier**用于控制整体的亮度。</p>
</blockquote>
</li>
<li><p>在顶点着色器中实现动画</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> o.uv.xy = TRANSFORM_TEX(v.uv.xy, _MainTex) + frac(float2(_ScollX, 0.0) * _Time.y);</span><br><span class="line"> o.uv.zw = TRANSFORM_TEX(v.uv.zw, _DetailTex) + frac(float2(_Scoll2X, 0.0) * _Time.y);</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>frac</code>函数通常用于执行周期性的操作，例如创建循环动画或实现周期性的颜色变化。它可以通过获取时间值的小数部分来控制动画或颜色的变化速度，以实现平滑循环的效果。</p>
</blockquote>
</li>
<li><p>在片元着色器中采样背景</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> fixed4 firstLayer = tex2D(_MainTex, i.uv);</span><br><span class="line"> fixed4 secondLayer = tex2D(_DetailTex, i.uv);</span><br><span class="line"></span><br><span class="line"> fixed4 col = lerp(firstLayer, secondLayer, secondLayer.a);</span><br><span class="line"> col.rgb *= _Multiplier; </span><br><span class="line"></span><br><span class="line"> return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>设置FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;VertexLit&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="10-3-顶点动画"><a href="#10-3-顶点动画" class="headerlink" title="10.3 - 顶点动画"></a>10.3 - 顶点动画</h3><h4 id="10-3-1-流动的河流"><a href="#10-3-1-流动的河流" class="headerlink" title="10.3.1 - 流动的河流"></a>10.3.1 - 流动的河流</h4><blockquote>
<p>河流的模拟是顶点动画最常见的应用之一。它的原理通常就是使用正弦函数等来模拟水流的波动效果。</p>
</blockquote>
<p>Shader：<strong>Chapter11-Water</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _Magnitude (&quot;Distortion Magnitude&quot;, Float) = 1</span><br><span class="line"> _Frequency (&quot;Distortion Frequency&quot;, Float) = 1</span><br><span class="line"> _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10</span><br><span class="line"> _Speed (&quot;Speed&quot;, Float) = 0.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>_MainTex</strong>是河流纹理，**_Color<strong>用于控制整体颜色，</strong>_Magnitude<strong>用于控制水流波动的幅度，</strong>_Frequency<strong>用于控制波动频率，</strong>_InvWaveLength<strong>用于控制波长的倒数（</strong>_InvWaveLength<strong>越大，波长越小）。</strong>_Speed**用于控制河流纹理的移动速度。</p>
</blockquote>
</li>
<li><p>设置合适的标签</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>除了设置透明效果的标签之外，还禁止了批处理：DisableBatching。</p>
<p>一些SubShader在使用Unity 的批处理功能时会出现问题，这时可以通过该标签来直接指明是否对该 SubShader 使用批处理。而这些需要特殊处理的Shader通常就是指包含了模型空间的顶点动画的Shader。这是因为，批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失。而在本例中，我们需要在物体的模型空间下对顶点位置进行偏移。因此，在这里需要取消对该Shader 的批处理操作。</p>
</blockquote>
</li>
<li><p>设置Pass的渲染状态</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"> ZWrite Off</span><br><span class="line"> Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"> Cull Off</span><br></pre></td></tr></table></figure>

<p>这里关闭了深度写入，开启并设置了混合模式，并关闭了剔除功能。这是为了让水流的每个面都能显示。</p>
</blockquote>
</li>
<li><p>在顶点着色器中进行了相关的顶点动画</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"></span><br><span class="line"> float4 offset;</span><br><span class="line"> offset.yzw = float3(0.0, 0.0, 0.0);</span><br><span class="line"> offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line"></span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex + offset);</span><br><span class="line"> o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line"> o.uv += float2(0.0, _Time.y * _Speed);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先计算顶点位移量。我们只希望对顶点的x方向进行位移，因此 <code>yzw</code>的位移量被设置为0。然后，我们利用**<em>Frequency<strong>属性和内置的 <code>Time.y</code>变量来控制正弦函数的频率。为了让不同位置具有不同的位移，我们对上述结果加上了模型空间下的位置分量，并乘以</strong>_InvWaveLength**来控制波长。最后，我们对结果值乘以</em><strong>Magnitude</strong>属性来控制波动幅度，得到最终的位移。剩下的工作，我们只需要把位移量添加到顶点位置上，再进行正常的顶点变换即可。</p>
</blockquote>
</li>
<li><p>片元着色器只需要对纹理进行采样以及颜色控制即可</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line"> col.rgb *= _Color.rgb;</span><br><span class="line"> return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后设置合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Transparent/VertexLit&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h4 id="10-3-2-广告牌"><a href="#10-3-2-广告牌" class="headerlink" title="10.3.2 - 广告牌"></a>10.3.2 - 广告牌</h4><p>另一种常见的顶点动画就是<strong>广告牌技术（Billboarding)<strong>。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形(通常就是简单的四边形，这个多边形就是广告牌)，使得多边形看起来好像</strong>总是面对着摄像机</strong>。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p>
<p>Shader：<strong>Chapter11-Billborad</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _VerticalBillboarding (&quot;Vertical Restrains&quot;, Range(0, 1)) = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>_MainTex</strong>是广告牌显示的透明纹理，**_Color<strong>用于控制整体的颜色，</strong>_VerticalBillboarding<strong>用于调整是</strong>固定法线<strong>还是</strong>固定向上**的方向，约束垂直方向的程度。</p>
</blockquote>
</li>
<li><p>设置合适的标签</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>除了设置透明效果的标签之外，还禁止了批处理：DisableBatching。</p>
<p>一些SubShader在使用Unity 的批处理功能时会出现问题，这时可以通过该标签来直接指明是否对该 SubShader 使用批处理。而这些需要特殊处理的Shader通常就是指包含了模型空间的顶点动画的Shader。这是因为，批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失。而在本例中，我们需要在物体的模型空间下对顶点位置进行偏移。因此，在这里需要取消对该Shader 的批处理操作。</p>
</blockquote>
</li>
<li><p>设置Pass的渲染状态</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"> ZWrite Off</span><br><span class="line"> Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"> Cull Off</span><br></pre></td></tr></table></figure>

<p>这里关闭了深度写入，开启并设置了混合模式，并关闭了剔除功能。这是为了让水流的每个面都能显示。</p>
</blockquote>
</li>
<li><p>在顶点着色器中进行了相关的顶点动画</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"></span><br><span class="line"> float3 center = float3(0, 0, 0);</span><br><span class="line"> float3 viewer = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));</span><br><span class="line"></span><br><span class="line"> float3 normalDir = viewer - center;</span><br><span class="line"> normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line"> normalDir = normalize(normalDir);</span><br><span class="line"></span><br><span class="line"> float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line"> float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line"> upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line"> float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line"> float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir.z *centerOffs.z;</span><br><span class="line"></span><br><span class="line"> o.vertex = UnityObjectToClipPos(float4(localPos,1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 center = float3(0, 0, 0);</span><br><span class="line">float3 viewer = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 normalDir = viewer - center;</span><br><span class="line">normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">normalDir = normalize(normalDir);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line">float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">upDir = normalize(cross(normalDir, rightDir));</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir.z * centerOffs.z;</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
<li><p>片元着色器只需要对纹理进行采样以及颜色控制即可</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line"> col.rgb *= _Color.rgb;</span><br><span class="line"> return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后设置合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Transparent/VertexLit&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="11-屏幕后处理效果"><a href="#11-屏幕后处理效果" class="headerlink" title="11 - 屏幕后处理效果"></a>11 - 屏幕后处理效果</h2><p>屏幕后处理就是在渲染完整个场景得到屏幕图像后，在对这个图像进行一些列操作，实现各种屏幕特效。</p>
<h3 id="11-1-建立一个基本的屏幕后处理脚本系统"><a href="#11-1-建立一个基本的屏幕后处理脚本系统" class="headerlink" title="11.1 - 建立一个基本的屏幕后处理脚本系统"></a>11.1 - 建立一个基本的屏幕后处理脚本系统</h3><p>实现屏幕后处理的基础在于得到渲染后的屏幕图像，Unity为我们提供了这样一个接口：<code>OnRenderImage</code>，它的声明如下：</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonoBehaviour.OnRenderImage (RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当我们再脚本中声明此函数后，Unity会把当前渲染得到的图像存储再第一个参数对应的源渲染纹理中，经过函数中的一系列操作后，再把目标渲染纹理（第二个参数对应的渲染纹理）显示到屏幕上</p>
<p>在<code>OnRenderImage</code>函数中，我们通常利用<code>Graphics.Blit</code>来对渲染纹理进行处理。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void Blit (Texture src, RenderTexture dest);</span><br><span class="line">public static void Blit (Texture src, RenderTexture dest, Material mat, int pass = -1);</span><br><span class="line">public static void Blit (Texture src, Material mat,int pass =-1);</span><br></pre></td></tr></table></figure>

<p>src对应原纹理，通常是当前屏幕的渲染纹理。</p>
<p>dest是目标纹理，如果它为null就会直接将结果显示在屏幕上。</p>
<p>mat是我们使用的材质。</p>
<p>pass的值默认为-1，表示将会以此调用Shader中所有的pass，否则只会调用给定索引的pass。</p>
</blockquote>
<p>有时，我们希望在不透明的Pass(即渲染队列小于等于2500的 Pass，内置的Background、Geometry 和 AlphaTest渲染队列均在此范围内）执行完毕后立即调用<code>OnRenderImage</code> 函数，从而<strong>不对透明物体产生任何影响</strong>。此时,我们可以在<code>OnRenderImage</code>函数前添加<strong>ImageEffectOpaque</strong>属性来实现这样的目的。</p>
<p>要在 Unity 中实现屏幕后处理效果，过程通常如下:</p>
<ul>
<li>我们首先需要在摄像机中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现OnRenderImage函数来获取当前屏幕的渲染纹理。</li>
<li>然后，再调用Graphics.Blit函数使用特定的 Unity Shader来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。</li>
<li>对于一些复杂的屏幕特效，我们可能需要多次调用Graphics.Blit函数来对上一步的输出结果进行下一步处理。</li>
</ul>
<p>在进行屏幕后处理之前，我们需要检查平台是否支持渲染纹理和屏幕特效、是否支持当前使用的Unity Shader等。我们创建一个用于屏幕后处理效果的基类：<strong>PostEffectsBase</strong></p>
<p>包含一个重要的函数，用于基于指定的<strong>Shader</strong>创建材质：</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (shader==<span class="literal">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">return</span> material;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">     material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">     material.hideFlags = HideFlags.DontSave;</span><br><span class="line">     <span class="keyword">if</span> (material)</span><br><span class="line">         <span class="keyword">return</span> material;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="11-2-调整屏幕的亮度、饱和度和对比度"><a href="#11-2-调整屏幕的亮度、饱和度和对比度" class="headerlink" title="11.2 - 调整屏幕的亮度、饱和度和对比度"></a>11.2 - 调整屏幕的亮度、饱和度和对比度</h3><p>Script：<strong>BrightnessSaturationAndContrast</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明效果需要的Shader，并由此创建相应的材质。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line"><span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span></span><br><span class="line"> &#123;</span><br><span class="line">     briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">     <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>提供相应的调整连你高度、饱和度和对比度的参数：</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">     Graphics.Blit(src, dest, material);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当<strong>OnRenderImage</strong>函数被调用时，它会检查材质是否可用。如果可用，就把参数传递给材质，再调用 <code>Graphics.Blit</code>进行处理;否则，直接把原图像显示到屏幕上，不做任何处理。</p>
</blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter12-BrightnessSaturationAndContrast</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Brightness (&quot;Brightness&quot;, Float) = 1</span><br><span class="line"> _Saturation(&quot;Saturation&quot;, Float) = 1</span><br><span class="line"> _Contrast(&quot;Contrast&quot;, Float) = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>渲染设置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line"> &#123;</span><br><span class="line">     // No culling or depth</span><br><span class="line">     Cull Off ZWrite Off ZTest Always</span><br></pre></td></tr></table></figure>

<p>屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片，为了防止它对其他物体产生影响，我们需要设置相关的渲染状态。在这里，我们关闭了深度写入，是为了防止它“挡住”在其后面被渲染的物体。</p>
<p>例如，如果当前的<strong>OnRenderImage</strong>函数在所有不透明的Pass执行完毕后立即被调用，不关闭深度写入就会影响后面透明的Pass 的渲染。这些状态设置可以认为是用于屏幕后处理的Shader的“标配”。</p>
</blockquote>
</li>
<li><p>声明变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">half _Brightness;</span><br><span class="line">half _Saturation;</span><br><span class="line">half _Contrast;</span><br></pre></td></tr></table></figure>

<p>这里关闭了深度写入，开启并设置了混合模式，并关闭了剔除功能。这是为了让水流的每个面都能显示。</p>
</blockquote>
</li>
<li><p>顶点着色器只需要传递正确的纹理坐标</p>
</li>
<li><p>片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> fixed4 renderTex = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line"> // Apply brightness</span><br><span class="line"> fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line"></span><br><span class="line"> // Apply saturation</span><br><span class="line"> fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b;</span><br><span class="line"> fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line"> finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line"></span><br><span class="line"> // Apply contrast</span><br><span class="line"> fixed3 avgColor = fixed3(0.5, 0.5, 0.5);</span><br><span class="line"> finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line"></span><br><span class="line"> return fixed4(finalColor, renderTex.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于亮度，我们只需要将原来的颜色乘以亮度系数**_Brightness**</li>
<li>对于饱和度，我们先计算该像素的亮度值<strong>luminance</strong>，这是有每一个颜色分量乘以一个特定系数相加得到的，我们使用该亮度值创建了一个饱和度为0的颜色值（灰度图），并使用**_Saturation**系数与上一步得到的颜色进行插值。</li>
<li>对于对比度，我们先创建一个对比度为0的颜色值，即各分量均为<strong>0.5</strong>，在使用**_Contrast**系数与上一步得到的颜色值进行插值，从而得到最终的结果。</li>
</ul>
</blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="11-3-边缘检测"><a href="#11-3-边缘检测" class="headerlink" title="11.3 - 边缘检测"></a>11.3 - 边缘检测</h3><h4 id="11-3-1-卷积"><a href="#11-3-1-卷积" class="headerlink" title="11.3.1 - 卷积"></a>11.3.1 - 卷积</h4><p>图像处理中的卷积操作指的是使用一个卷积核对一张图像中每个像素进行一系列操作。</p>
<blockquote>
<p>卷积核通常是一个四方形网格结构（例如2×2、3×3的方形区域)，该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时,我们会把卷积核的中心放置于该像素上，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。</p>
</blockquote>
<p>通过卷积可以实现许多常见的图像处理效果，例如图像模糊、边缘检测等。比如如果我们想对图像进行均值模糊，可以使用一个3x3的卷积核，核内每个元素的值均为1/9。</p>
<h4 id="11-3-2-常见的边缘检测算子"><a href="#11-3-2-常见的边缘检测算子" class="headerlink" title="11.3.2 - 常见的边缘检测算子"></a>11.3.2 - 常见的边缘检测算子</h4><p>卷积操作的神奇之处在于选择的卷积核。</p>
<p>为了选择合适的卷积核，我们首先要考虑边到底是如何形成的：如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为它们之间应该有一条边界这种相邻像素之间的差值可以用梯度（gradientt)来表示，可以想象得到，边缘处的梯度绝对会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出来。</p>
<p><img src="/image/UnityShaderLearning/image-20230711215947776.png" alt="image-20230711215947776"></p>
<p>3种常见的边缘检测算子如图12.5所示，它们都包含了两个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值G_x和G_y，处于性能的考虑，我们会使用绝对值代替开根号的操作：<br>$$<br>G = \vert G_x \vert + \vert G_y\vert<br>$$<br><strong>梯度越大，越有可能是边缘点。</strong></p>
<h4 id="11-3-3-实现"><a href="#11-3-3-实现" class="headerlink" title="11.3.3 -  实现"></a>11.3.3 -  实现</h4><p>Script：<strong>EdgeDetection</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明该效果需要的Shader，并创建相应的材质</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader EdgeDetectionShader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Material EdgeDetectionMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span></span><br><span class="line"> &#123;</span><br><span class="line">     EdgeDetectionMaterial = CheckShaderAndCreateMaterial(EdgeDetectionShader, EdgeDetectionMaterial);</span><br><span class="line">     <span class="keyword">return</span> EdgeDetectionMaterial;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在脚本中声明用于调整边缘线强度、描边颜色以及背景的参数</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> edgeOnly = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line"><span class="keyword">public</span> Color backgroundColor = Color.white;</span><br></pre></td></tr></table></figure>

<p>edgeOnly为0时，边缘将直接叠加在图像上。edgeOnly为1时，只会显示边缘。</p>
</blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">&#123;</span><br><span class="line"> if (material != null)</span><br><span class="line"> &#123; </span><br><span class="line">     material.SetFloat(&quot;_EdgeOnly&quot;, edgeOnly);</span><br><span class="line">     material.SetColor(&quot;_EdgeColor&quot;, edgeColor);</span><br><span class="line">     material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line"></span><br><span class="line">     Graphics.Blit(src, dest, material);</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter12-EdgeDetection</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _EdgeOnly (&quot;Edge Only&quot;, Float) = 1.0</span><br><span class="line"> _EdgeColor (&quot;Edge Color&quot;, Color) = (0, 0, 0, 1)</span><br><span class="line"> _BackgroundColor (&quot;Background Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>渲染设置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line"> &#123;</span><br><span class="line">     // No culling or depth</span><br><span class="line">     Cull Off ZWrite Off ZTest Always</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>声明变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">fixed _EdgeOnly;</span><br><span class="line">fixed4 _EdgeColor;</span><br><span class="line">fixed4 _BackgroundColor;</span><br></pre></td></tr></table></figure>

<p><strong>xxx_TexelSize</strong>是 Unity为我们提供的访问相应纹理对应的每个纹素的大小。例如，一张512×512大小的纹理,该值大约为0.001 953(即1/512)。由于卷积需要对相邻区域内的纹理进行采样，因此我们需要利用**_MainTex_TexelSize**来计算各个相邻区域的纹理坐标。</p>
</blockquote>
</li>
<li><p>顶点着色器需要传递纹理坐标和它邻近的8个像素的坐标</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> half2 uv = v.uv;</span><br><span class="line"></span><br><span class="line"> o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);</span><br><span class="line"> o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);</span><br><span class="line"> o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);</span><br><span class="line"> o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);</span><br><span class="line"> o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);</span><br><span class="line"> o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);</span><br><span class="line"> o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);</span><br><span class="line"> o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);</span><br><span class="line"> o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在v2f结构体中定义了一个维数为9的纹理数组，对应了使用<strong>Sobel算子</strong>采样时需要的9个邻域纹理坐标。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能。</p>
<p>其中，<code>o.uv[4]</code>表示中间坐标，通过对这个坐标进行偏移得到周围的邻域纹理坐标。</p>
</blockquote>
</li>
<li><p>片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragSobel(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line"> fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);</span><br><span class="line"> fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line"></span><br><span class="line"> return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先调用Sobel函数计算当前像素的梯度值edge，<strong>edge的值越小</strong>，<strong>表示这个位置更可能是一个边缘点</strong>。</p>
<p>将这个值作为插值系数，可以分别控制带原先背景的图和空白背景的图。</p>
<p><strong>_EdgeOnly</strong>系数用于控制是否带背景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fixed luminance(fixed4 color) &#123;</span><br><span class="line"> return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half Sobel(v2f i)</span><br><span class="line">&#123;</span><br><span class="line"> const half Gx[9] = &#123;-1, -2, -1,</span><br><span class="line">                 0, 0, 0,</span><br><span class="line">                 1, 2, 1&#125;;</span><br><span class="line"></span><br><span class="line"> const half Gy[9] =	&#123;-1, 0, 1,</span><br><span class="line">                 -2, 0, 2,</span><br><span class="line">                 -1, 0, 1&#125;;</span><br><span class="line"></span><br><span class="line"> half texColor;</span><br><span class="line"> half edgeX = 0;</span><br><span class="line"> half edgeY = 0;</span><br><span class="line"> for(int it = 0; it&lt;9; it++)</span><br><span class="line"> &#123;</span><br><span class="line">     texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">     edgeX += texColor * Gx[it];</span><br><span class="line">     edgeY += texColor * Gy[it];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> half edge = 1 - abs(edgeX) - abs(edgeY);</span><br><span class="line"> return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先定义水平和竖直方向上使用的卷积核G_x和G_y。</li>
<li>然后依次对输入的9个像素点进行采样，计算他们的亮度值（灰度图）。</li>
<li>将灰度值像素与卷积核的权重相乘后，叠加到各自的梯度上。</li>
<li>从1中减去水平方向和竖直方向上的梯度值的绝对值，得到edge，<strong>edge的值越小</strong>，<strong>表示这个位置更可能是一个边缘点</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="11-4-高斯模糊"><a href="#11-4-高斯模糊" class="headerlink" title="11.4 - 高斯模糊"></a>11.4 - 高斯模糊</h3><h4 id="11-4-1-高斯滤波"><a href="#11-4-1-高斯滤波" class="headerlink" title="11.4.1 - 高斯滤波"></a>11.4.1 - 高斯滤波</h4><p>高斯模糊同样利用了卷积计算，它使用的卷积核为高斯核，其中每个元素的计算都是基于下面的高斯方程：<br>$$<br>G(x,y) = \frac{1}{2 \pi σ^2} e^{\frac{x^2+y^2}{2σ^2} }<br>$$</p>
<blockquote>
<p>其中，σ是标准方差（一般取值为1)，x和y分别对应了当前位置到卷积核中心的整数距离。高斯方程很好地模拟了邻域每个像素对当前处理像素的影响程度———距离越近，影响越大。高斯核的维数越高，模糊程度越大。</p>
</blockquote>
<ul>
<li>要构建一个高斯核，我们只需要计算高斯核中各个位置对应的高斯值。</li>
<li>为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，即让每个权重除以所有权重的和，这样可以保证所有权重的和为1。因此，高斯函数中e前面的系数实际不会对结果有任何影响。</li>
</ul>
<h4 id="11-4-2-实现"><a href="#11-4-2-实现" class="headerlink" title="11.4.2 - 实现"></a>11.4.2 - 实现</h4><p>在本节，我们将会使用上述5x5的高斯核对原图像进行高斯模糊。</p>
<p>我们将先后调用两个 Pass：</p>
<ul>
<li>第一个 Pass将会使用竖直方向的一维高斯核对图像进行滤波</li>
<li>第二个 Pass再使用水平方向的维高斯核对图像进行滤波，得到最终的目标图像。</li>
<li>在实现中，我们还将利用图像缩放来进一步提高性能，并通过调整<strong>高斯滤波的应用次数</strong>来控制模糊程度（次数越多，图像越模糊)。</li>
</ul>
<blockquote>
<p>高斯核的维数越高,模糊程度越大。使用一个NxN的高斯核对图像进行卷积滤波,就需要<code>NXNxWxH</code>(W和H分别是图像的宽和高）次纹理采样。当N的大小不断增加时，采样次数会变得非常巨大。幸运的是，我们可以把这个二维高斯函数拆分成两个一维函数。也就是说，我们可以使用两个一维的高斯核（图12.8中的右图)先后对图像进行滤波，它们得到的结果和直接使用二维高斯核是一样的，但采样次数只需要<code>2xN×W*H</code>。我们可以进一步观察到，两个一维高斯核中包含了很多重复的权重。对于一个大小为5的一维高斯核，我们实际只需要记录3个权重值即可</p>
</blockquote>
<p><img src="/image/UnityShaderLearning/image-20230712193951362.png" alt="image-20230712193951362"></p>
<p>Script：<strong>GaussianBlur</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明该效果需要的Shader，并创建相应的材质</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader GaussianBlursShader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Material GaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span></span><br><span class="line"> &#123;</span><br><span class="line">     GaussianBlurMaterial = CheckShaderAndCreateMaterial(GaussianBlursShader, GaussianBlurMaterial);</span><br><span class="line">     <span class="keyword">return</span> GaussianBlurMaterial;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在脚本中，我们还提供了调整高斯模糊迭代次数、模糊范围和缩放系数的参数：</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0f, 4f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">[<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line">[<span class="meta">Range(1f, 8f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>blurSpread</strong>和 <strong>downSample</strong>都是出于性能的考虑。</p>
<p>在高斯核维数不变的情况下，<strong>BlurSize</strong>越大，模糊程度越高，但采样数却不会受到影响。但过大的**_BlurSize**值会造成虚影，这可能并不是我们希望的。而 <strong>downSample</strong>越大，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的downSample可能会使图像像素化,</p>
</blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">     <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">     RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">     buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">     Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">         material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">         RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Render the vertical pass</span></span><br><span class="line">         Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">         buffer0 = buffer1;</span><br><span class="line">         buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Render the horizontal pass</span></span><br><span class="line">         Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">         RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">         buffer0 = buffer1;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Graphics.Blit(buffer0, dest);</span><br><span class="line">     RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先利用缩放对图像进行降采样，并将该临时渲染纹理的滤波纹理模式设置为双线性，这样能够提高性能，适当的降采样还能得到更好的模糊效果。</li>
<li>高斯模糊需要调用两个Pass：水平方向和垂直方向的Pass。</li>
<li>使用<strong>blurSpread</strong>属性来控制**_BlurSize<strong>，在高斯核维度不变的情况下，</strong>_BlurSize**越大，模糊程度越高。</li>
<li>在此基础上考虑了迭代次数，迭代次数越多图像越模糊。</li>
</ul>
</blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter12-GaussianBlur</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _BlueSize(&quot;Blue Size&quot;, Float) = 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>使用<strong>CGINCLUDE</strong>来组织代码，可以复用我们已经写过的相关函数。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"> CGINCLUDE</span><br><span class="line"> ...</span><br><span class="line"> ENDCG</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义以下变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;    </span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">float _BlurSize;</span><br></pre></td></tr></table></figure>

<p>由于要得到相邻像素的纹理坐标，我们这里再一次使用了Unity 提供的<code>_MainTex_TexelSize</code>变量,以计算相邻像素的纹理坐标偏移量。</p>
</blockquote>
</li>
<li><p>定义两个Pass使用的顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123;</span><br><span class="line"> float4 pos : SV_POSITION;</span><br><span class="line"> half2 uv[5]: TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>以下是竖直方向上的顶点着色器代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line"> o.uv[0] = uv;</span><br><span class="line"> o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;</span><br><span class="line"> o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;</span><br><span class="line"> o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;</span><br><span class="line"> o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在本节中我们会利用5x5大小的高斯核对原图像进行高斯模糊,一个5x5的二维高斯核可以拆分成两个大小为5的一维高斯核，因此我们只需要计算5个纹理坐标即可。</li>
<li>我们在v2f中存储了当前的采样纹理坐标，<strong>数组的第一个坐标存储了当前的采样坐标</strong>，而剩余的4个坐标则是高斯模糊中对邻域采样时使用的纹理坐标。</li>
</ul>
<p><strong>以下是水平方向上的顶点着色器代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">   v2f o;</span><br><span class="line">   o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">   half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">   o.uv[0] = uv;</span><br><span class="line">   o.uv[1] = uv + float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;</span><br><span class="line">   o.uv[2] = uv - float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;</span><br><span class="line">   o.uv[3] = uv + float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;</span><br><span class="line">   o.uv[4] = uv - float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;</span><br><span class="line"></span><br><span class="line">   return o;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>水平方向的顶点着色器和上面的代码类似，只是在计算4个纹理坐标时使用了水平方向的纹素大小进行纹理偏移。</p>
</blockquote>
</li>
<li><p>定义了两个Pass共用的片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line"> float weight[3] = &#123;0.4026, 0.2442, 0.0545&#125;;</span><br><span class="line"></span><br><span class="line"> fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];</span><br><span class="line"></span><br><span class="line"> for (int it = 1; it &lt; 3; it++) &#123;</span><br><span class="line">     sum += tex2D(_MainTex, i.uv[it*2-1]).rgb * weight[it];</span><br><span class="line">     sum += tex2D(_MainTex, i.uv[it*2]).rgb * weight[it];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return fixed4(sum, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个5×5的二维高斯核可以拆分成两个大小为5的一维高斯核，并且由于它的对称性，我们只需要记录<strong>3个高斯权重</strong>，也就是代码中的 <strong>weight</strong>变量。</li>
<li>我们首先声明了各个邻域像素对应的权重<strong>weight</strong>，然后将结果值<strong>sum</strong>初始化为当前的像素值乘以它的权重值。根据对称性，我们进行了两次迭代，每次迭代包含了两次纹理采样，并把像素值和权重相乘后的结果叠加到sum 中。</li>
<li>最后，函数返回滤波结果 sum。</li>
</ul>
</blockquote>
</li>
<li><p>定义高斯模糊需要的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Name &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vertBlurVertical</span><br><span class="line"> #pragma fragment fragBlur</span><br><span class="line"></span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vertBlurHorizontal</span><br><span class="line"> #pragma fragment fragBlur</span><br><span class="line"></span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="11-5-Bloom效果"><a href="#11-5-Bloom效果" class="headerlink" title="11.5 - Bloom效果"></a>11.5 - Bloom效果</h3><p>Bloom效果可以让画面中较亮的区域扩散到周围，营造一种朦胧的氛围。</p>
<p>Bloom的实现原理非常简单，</p>
<ol>
<li>我们首先根据一个阈值提取出屏幕中较亮的区域，把他们存储到一张渲染纹理中</li>
<li>利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果</li>
<li>最后将这种渲染纹理和原图混合</li>
</ol>
<p>Script：<strong>Bloom</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明该效果需要的Shader，并创建相应的材质</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader BloomShader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Material BloomMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span></span><br><span class="line"> &#123;</span><br><span class="line">     BloomMaterial = CheckShaderAndCreateMaterial(BloomShader, BloomMaterial);</span><br><span class="line">     <span class="keyword">return</span> BloomMaterial;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在脚本中，我们提供了调整高斯模糊迭代次数、模糊范围和缩放系数的参数以及用来控制提取较量区域的阈值<strong>luminanceThreshold</strong>：</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0f, 4f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">[<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line">[<span class="meta">Range(1f, 8f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line">[<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br></pre></td></tr></table></figure>

<p>尽管在绝大多数情况下，图像的亮度值不会超过1。但如果我们开启了HDR,硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过1。因此，在这里我们把<strong>luminanceThreshold</strong> 的值规定在[0,4]范围内。更多关于HDR的内容，可以参见18.4.3节。</p>
</blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">     <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">     RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">     buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">     Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">         material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">         RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Render the vertical pass</span></span><br><span class="line">         Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">         RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">         buffer0 = buffer1;</span><br><span class="line">         buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Render the horizontal pass</span></span><br><span class="line">         Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">         RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">         buffer0 = buffer1;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0);  </span><br><span class="line">     Graphics.Blit (src, dest, material, <span class="number">3</span>);  </span><br><span class="line"></span><br><span class="line">     RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码和高斯模糊中的几乎一致，做了以下改动</p>
<ul>
<li>首先提取图像中较亮的部分，使用<strong>Pass0</strong>进行这个过程。</li>
<li>然后进行高斯模糊迭代，对应<strong>Pass1</strong>和<strong>Pass2</strong>。</li>
<li>然后再把模糊后的较亮区域存储在<strong>buffer0</strong>中，传递给材质中的**_Bloom<strong>属性，然后使用</strong>Pass3**进行混合，将混合的结果存储在目标渲染纹理dest中。</li>
</ul>
</blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter12-Bloom</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _BlueSize(&quot;Blue Size&quot;, Float) = 1.0</span><br><span class="line"> _Bloom (&quot;Bloom&quot;, 2D) = &quot;black&quot; &#123;&#125;</span><br><span class="line"> _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = 0.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>使用<strong>CGINCLUDE</strong>来组织代码，可以复用我们已经写过的相关函数。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"> CGINCLUDE</span><br><span class="line"> ...</span><br><span class="line"> ENDCG</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义以下变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;    </span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">float _BlurSize;</span><br><span class="line">sampler2D _Bloom;  </span><br><span class="line">float _LuminanceThreshold;</span><br></pre></td></tr></table></figure>

<p>由于要得到相邻像素的纹理坐标，我们这里再一次使用了Unity 提供的<code>_MainTex_TexelSize</code>变量,以计算相邻像素的纹理坐标偏移量。</p>
</blockquote>
</li>
<li><p>定义提取较亮区域<strong>Pass0</strong>需要使用的顶点和片元着色器：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123;</span><br><span class="line"> float4 pos : SV_POSITION; </span><br><span class="line"> half2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vertExtractBright(appdata_img v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> o.uv = v.texcoord;</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed luminance(fixed4 color) &#123;</span><br><span class="line"> return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 fragExtractBright(v2f i) : SV_Target &#123;</span><br><span class="line"> fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line"> fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line"> return c * val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在片元着色器中，我们将采样得到的亮度值减去阈值**_LuminanceThreshold**，并将结果截取到0~1之间。</li>
<li>然后，我们将该值与原像素相乘，得到提取后的亮部区域。</li>
</ul>
</blockquote>
</li>
<li><p>定义了混合两部图像和原图像时使用的顶点着色器和片元着色器：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct v2fBloom &#123;</span><br><span class="line"> float4 pos : SV_POSITION; </span><br><span class="line"> half4 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2fBloom vertBloom(appdata_img v) &#123;</span><br><span class="line"> v2fBloom o;</span><br><span class="line"></span><br><span class="line"> o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line"> o.uv.xy = v.texcoord;		</span><br><span class="line"> o.uv.zw = v.texcoord;</span><br><span class="line"></span><br><span class="line"> #if UNITY_UV_STARTS_AT_TOP			</span><br><span class="line"> if (_MainTex_TexelSize.y &lt; 0.0)</span><br><span class="line">     o.uv.w = 1.0 - o.uv.w;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> return o; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line"> return tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>这里使用的顶点着色器与之前的有所不同，我们定义了两个纹理坐标，并存储在同一个类型为 <strong>half4</strong>的变量<strong>uv</strong>中。它的<strong>xy</strong>分量对应了<code>_MainTex</code>，即原图像的纹理坐标。而它的<strong>zw</strong>分量是**_Bloom**，即模糊后的较亮区域的纹理坐标。我们需要对这个纹理坐标进行平台差异化处理（详见5.6.1节)。</li>
</ul>
</blockquote>
</li>
<li><p>定义了Bloom效果需要的4个Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// No culling or depth</span><br><span class="line">Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vertExtractBright</span><br><span class="line"> #pragma fragment fragExtractBright</span><br><span class="line"></span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UsePass &quot;Shader Learning/Chapter12/Chapter12-GaussianBlur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line"></span><br><span class="line">UsePass &quot;Shader Learning/Chapter12/Chapter12-GaussianBlur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vertBloom</span><br><span class="line"> #pragma fragment fragBloom</span><br><span class="line"></span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，由于 Unity内部会把所有Pass 的 Name转换成大写字母表示，因此在使用UsePass命令时我们必须使用<strong>大写形式的名字。</strong></p>
</blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="11-6-运动模糊"><a href="#11-6-运动模糊" class="headerlink" title="11.6 - 运动模糊"></a>11.6 - 运动模糊</h3><p>运动模糊的实现有多种方法。一种实现方法是利用一块**累积缓存（accumulation buffer )**来混合多张连续的图像。当物体快速移动产生多张图像后,我们取它们之间的平均值作为最后的运动模糊图像。然而，这种暴力的方法对性能的消耗很大，因为想要获取多张帧图像往往意味着我们需要在同一帧里渲染多次场景。</p>
<p>另一种应用广泛的方法是创建和使用**速度缓存（velocitybuffer)**，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p>
<p>在本节中，我们采用第一种方法：<strong>累积缓存</strong>来实现运动模糊的效果。</p>
<p>Script：<strong>MotionBlur</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明该效果需要的Shader，并创建相应的材质</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader MotionBlurShader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Material MotionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span></span><br><span class="line"> &#123;</span><br><span class="line">     MotionBlurMaterial = CheckShaderAndCreateMaterial(MotionBlurShader, MotionBlurMaterial);</span><br><span class="line">     <span class="keyword">return</span> MotionBlurMaterial;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>blurAmount</strong>的值越大，运动拖尾的效果就越明显。同时定义一个<strong>RenderTexture</strong>类型的变量<strong>accumulationTexture</strong>，用来保存之前图像叠加的结果。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 9.0f)</span>] </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">private</span> RenderTexture accumulationTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> DestroyImmediate(accumulationTexture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码里，我们在该脚本不运行时，即调用<strong>OnDisable</strong>函数时，立即销毁<strong>accumulationTexture</strong>。这是因为，我们希望在下一次开始应用运动模糊时重新叠加图像。</p>
</blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width ||</span><br><span class="line">         accumulationTexture.height != src.height)</span><br><span class="line">     &#123;</span><br><span class="line">         DestroyImmediate(accumulationTexture);</span><br><span class="line">         accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">         accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">         Graphics.Blit(src, accumulationTexture);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">     material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line"></span><br><span class="line">     Graphics.Blit(src, accumulationTexture, material);</span><br><span class="line">     Graphics.Blit(accumulationTexture, dest);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在确认材质可用后，我们首先判断用于混合图像的accumulationTexture是否满足条件。我们不仅判断它是否为空，还判断它是否与当前的屏幕分辨率相等，如果不满足，就说明我们需要重新创建一个适合于当前分辨率的accumulationTexture变量。</li>
<li>创建完毕后，由于我们会自己控制该变量的销毁，因此可以把它的 <strong>hideFlags</strong>设置为 <code>HideFlags.HideAndDontSave</code><br>这意味着这个变量不会显示在<strong>Hierarchy</strong>中，也不会保存到场景中。</li>
<li>然后，我们使用当前的帧图像初始化 <strong>accumulationTexture</strong></li>
<li>当得到了有效的 <strong>accumulationTexture</strong>变量后，我们调用了<code>accumulationTexture.MarkRestoreExpected</code>函数来表明我们需要进行一个渲染纹理的<strong>恢复操作</strong>。<strong>恢复操作(restore operation)<strong>发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下。在本例中，我们每次调用</strong>OnRenderImage</strong>时都需要把当前的帧图像和<strong>accumulationTexture</strong> 中的图像混合，<strong>accumulationTexture</strong>纹理不需要提前清空，因为它保存了我们之前的混合结果。</li>
<li>然后，我们将参数传递给材质，并调用<code>Graphics.Blit (src, accumulationTexture, material)</code>把当前的屏幕图像<strong>src</strong>叠加到<strong>accumulationTexture</strong>中。最后使用<code>Graphics.Blit (accumulationTexture, dest)</code>把结果显示到屏幕上。</li>
</ul>
</blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter12-MotionBlur</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _BlueAmount(&quot;Blue Amount&quot;, Float) = 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>顶点着色器只需要传递正确的纹理坐标</p>
</li>
<li><p>定义了两个片元着色器，一个用来更新渲染纹理的RGB通道部分，另一个用于更新渲染纹理的A通道部分</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragRGB(v2f i) : SV_Target&#123;</span><br><span class="line"> return fixed4(tex2D(_MainTex, i.uv).rgb, _BlueAmount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">half4 fragA(v2f i) : SV_Target&#123;</span><br><span class="line"> return tex2D(_MainTex, i.uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RGB通道版本的Shader对当前图像进行采样，并将其A通道的值设为_BlurAmount，以便在后面混合时可以使用它的透明通道进行混合。</li>
<li>A通道版本的代码就更简单了，直接返回采样结果。实际上，这个版本只是为了维护渲染纹理的透明通道值，不让其受到混合时使用的透明度值的影响。</li>
</ul>
</blockquote>
</li>
<li><p>定义运动模糊需要的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// No culling or depth</span><br><span class="line">ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"> ColorMask RGB</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment fragRGB</span><br><span class="line"></span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Blend One Zero</span><br><span class="line"> ColorMask A</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment fragA</span><br><span class="line"></span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="11-7-拓展阅读"><a href="#11-7-拓展阅读" class="headerlink" title="11.7 - 拓展阅读"></a>11.7 - 拓展阅读</h3><blockquote>
<p>Unity Image Effect ：http:/ldocs.unity3d.com/Manual/comp-ImageEffects.html </p>
<p>GPU Gems 系列：https:/developer.nvidia.com/gpugems/GPUGems</p>
<p>介绍了许多基于图像处理的渲染技术。例如，《GPU Gems 3》的第27章，介绍了一种景深效果的实现方法。</p>
<p>在 Unity 的资源商店和其他网络资源中找到许多出色的屏幕特效。</p>
</blockquote>
<h2 id="12-深度和法线纹理"><a href="#12-深度和法线纹理" class="headerlink" title="12 - 深度和法线纹理"></a>12 - 深度和法线纹理</h2><h3 id="12-1-获取深度和法线纹理"><a href="#12-1-获取深度和法线纹理" class="headerlink" title="12.1 - 获取深度和法线纹理"></a>12.1 - 获取深度和法线纹理</h3><p>获取深度+法线纹理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void OnEnable()</span><br><span class="line">&#123;</span><br><span class="line">    GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在Shader中声明改变量来访问它们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _CameraDepthNormalsTexture;</span><br></pre></td></tr></table></figure>





<h3 id="12-2-再谈运动模糊"><a href="#12-2-再谈运动模糊" class="headerlink" title="12.2 - 再谈运动模糊"></a>12.2 - 再谈运动模糊</h3><h3 id="12-3-全局雾效"><a href="#12-3-全局雾效" class="headerlink" title="12.3 - 全局雾效"></a>12.3 - 全局雾效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// make fog work</span><br><span class="line">#pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">UNITY_FOG_COORDS(1)</span><br><span class="line"></span><br><span class="line">// apply fog</span><br><span class="line">UNITY_APPLY_FOG(i.fogCoord, col);</span><br></pre></td></tr></table></figure>



<h4 id="12-3-1-重建世界坐标"><a href="#12-3-1-重建世界坐标" class="headerlink" title="12.3.1 - 重建世界坐标"></a>12.3.1 - 重建世界坐标</h4><h4 id="12-3-2-雾的计算"><a href="#12-3-2-雾的计算" class="headerlink" title="12.3.2 - 雾的计算"></a>12.3.2 - 雾的计算</h4><h4 id="12-3-3-实现"><a href="#12-3-3-实现" class="headerlink" title="12.3.3 - 实现"></a>12.3.3 - 实现</h4><p>Script：<strong>FogWithDepthTexture</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明该效果需要的Shader，并创建相应的材质</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader FogWithDepthTextureShader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Material FogWithDepthTextureMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line">  FogWithDepthTextureMaterial = CheckShaderAndCreateMaterial(FogWithDepthTextureShader, FogWithDepthTextureMaterial);</span><br><span class="line">  <span class="keyword">return</span> FogWithDepthTextureMaterial;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在本节中，我们需要获取摄像机的相关参数，如<strong>近裁剪平面的距离</strong>、<strong>FOV</strong>等，同时还需要获取<strong>摄像机在世界空间下的前方、上方和右方等方向</strong>，因此我们用两个变量存储摄像机的Camera组件和 Transform 组件</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Camera myCamera;</span><br><span class="line"><span class="keyword">public</span> Camera camera</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">         myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> myCamera;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line"><span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line"> <span class="keyword">get</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">         myCameraTransform = camera.transform;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> myCameraTransform;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义模拟雾效时使用的各个参数</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fogDensity</strong> 用于控制雾的浓度，<strong>fogColor</strong>用于控制雾的颜色。</li>
<li>我们使用的雾效模拟函数是基于高度的，因此参数<strong>fogStart</strong>用于控制雾效的<strong>起始高度</strong>，<strong>fogEnd</strong>用于控制雾效的<strong>终止高度</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>本例需要获取摄像机的深度纹理，在<strong>OnEnable</strong>中设置摄像机的相应状态。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">     Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">     <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">     <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">     Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">     Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line"></span><br><span class="line">     Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">     <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">     topLeft.Normalize();</span><br><span class="line">     topLeft *= scale;</span><br><span class="line"></span><br><span class="line">     Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">     topRight.Normalize();</span><br><span class="line">     topRight *= scale;</span><br><span class="line"></span><br><span class="line">     Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">     bottomLeft.Normalize();</span><br><span class="line">     bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">     Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">     bottomRight.Normalize();</span><br><span class="line">     bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">     frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">     frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">     frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">     frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">     material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">     material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">     Graphics.Blit (src, dest, material);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>OnRenderImage</strong>首先计算了近裁剪平面的四个角对应的向量，并把它们存储在一个矩阵类型的变量(<strong>frustumCormers</strong>)中。</li>
<li>我们按一定顺序把这四个方向存储到了<strong>frustumCorners</strong>不同的行中，这个顺序是非常重要的,因为这决定了我们在顶点着色器中使用哪行作为该点的待插值向量。</li>
<li>随后，我们把结果和其他参数传递给材质，并调用<code>Graphics.Blit (src, dest, material)</code>把渲染结果显示在屏幕上。</li>
</ul>
</blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter13-FogWithDepthTexture</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _FogDensity (&quot;Fog Density&quot;, Float) = 1.0</span><br><span class="line"> _FogColor (&quot;Fog Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _FogStart (&quot;Fog Start&quot;, Float) = 0.0</span><br><span class="line"> _FogEnd (&quot;Fog End&quot;, Float) = 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，**_Sensitivity**的xy分量分别对应了法线和深度的检测灵敏度，zw分量则没有实际用途。</p>
</blockquote>
</li>
<li><p>声明对应变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float4x4 _FrustumCornersRay;</span><br><span class="line"></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">sampler2D _CameraDepthTexture;</span><br><span class="line">half _FogDensity;</span><br><span class="line">fixed4 _FogColor;</span><br><span class="line">float _FogStart;</span><br><span class="line">float _FogEnd;</span><br></pre></td></tr></table></figure>

<p>FrustumCornersRay虽然没有在 Properties中声明,但仍可由脚本传递给Shader。</p>
<p>除了在上面的代码中，我们还声明了需要获取的深度纹理**_CameraDepthNormalsTexture**。</p>
</blockquote>
</li>
<li><p>定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line"> half2 uv : TEXCOORD0;</span><br><span class="line"> float4 vertex : SV_POSITION;</span><br><span class="line"> half2 uv_depth : TEXCOORD1;</span><br><span class="line"> float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert (appdata_img v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"> o.uv = v.texcoord;</span><br><span class="line"> o.uv_depth = v.texcoord;</span><br><span class="line"></span><br><span class="line"> #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line"> if (_MainTex_TexelSize.y &lt; 0)</span><br><span class="line"> &#123;</span><br><span class="line">     o.uv_depth.y = 1 - o.uv_depth.y;</span><br><span class="line"> &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> int index = 0;</span><br><span class="line"> if (v.texcoord.x &lt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5)</span><br><span class="line"> &#123;</span><br><span class="line">     index = 0;</span><br><span class="line"> &#125;</span><br><span class="line"> else if(v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5)</span><br><span class="line"> &#123;</span><br><span class="line">     index = 1;</span><br><span class="line"> &#125;else if(v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &gt; 0.5)</span><br><span class="line"> &#123;</span><br><span class="line">     index = 2;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">     index = 3;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line"> if (_MainTex_TexelSize.y &lt; 0)</span><br><span class="line"> &#123;</span><br><span class="line">     index = 3 - index;</span><br><span class="line"> &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> o.interpolatedRay = _FrustumCornersRay[index];</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 v2f 结构体中，我们除了定义顶点位置、屏幕图像和深度纹理的纹理坐标外，还定义了<strong>interpolatedRay</strong>变量存储插值后的像素向量。</li>
<li>在顶点着色器中，我们对深度纹理的采样坐标进行了平台差异化处理。更重要的是，我们要决定该点对应了4个角中的哪个角。我们采用的方法是判断它的纹理坐标。我们知道，在Unity中，纹理坐标的(0,0)点对应了左下角，而(1,1)点对应了右上角。我们据此来判断该顶点对应的索引，这个对应关系和我们在脚本中对frustumCorners 的赋值顺序是一致的。实际上，不同平台的纹理坐标不一定是满足上面的条件的，例如 DirectX和Metal 这样的平台，左上角对应了(0,0)点，但大多数情况下Unity 会把这些平台下的屏幕图像进行翻转，因此我们仍然可以利用这个条件。但如果在类似 DirectX 的平台上开启了抗锯齿，Unity就不会进行这个翻转。为了此时仍然可以得到相应顶点位置的索引值，我们对索引值也进行了平台差异化处理（详见5.6.1节)，以便在必要时也对索引值进行翻转。</li>
<li>最后，我们使用索引值来获取 FrustumCornersRay 中对应的行作为该顶点的interpolatedRay值。</li>
<li>尽管我们这里使用了很多判断语句，但由于屏幕后处理所用的模型是一个四边形网格，只包含4个顶点，因此这些操作不会对性能造成很大影响。</li>
</ul>
</blockquote>
</li>
<li><p>定义片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"></span><br><span class="line"> float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line"> float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line"></span><br><span class="line"> float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line"> fogDensity = saturate(fogDensity * _FogDensity);</span><br><span class="line"></span><br><span class="line"> fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line"> finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line"></span><br><span class="line"> return finalColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先,我们需要重建该像素在世界空间中的位置。为此,我们首先使用<strong>SAMPLE_DEPTH_TEXTURE</strong>对深度纹理进行采样，再使用<strong>LinearEyeDepth</strong>得到视角空间下的线性深度值。之后，与<strong>interpolatedRay</strong>相乘后再和世界空间下的摄像机位置相加，即可得到世界空间下的位置。</li>
<li>得到世界坐标后，模拟雾效就变得非常容易。在本例中，我们选择实现基于高度的雾效模拟,计算公式可参见13.3.2节。我们根据材质属性**_FogEnd<strong>和</strong>_FogStart<strong>计算当前的像素高度<code>worldPos.y</code>对应的雾效系数</strong>fogDensity<strong>，再和参数 <strong>FogDensity</strong> 相乘后，利用</strong>saturate**函数截取到[0,1]范围内，作为最后的雾效系数。然后，我们使用该系数将雾的颜色和原始颜色进行混合后返回。也可以使用不同的公式来实现其他种类的雾效。</li>
</ul>
</blockquote>
</li>
<li><p>然后，我们定义雾效渲染需要用到的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line"> ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line"> CGPROGRAM  </span><br><span class="line"></span><br><span class="line"> #pragma vertex vert  </span><br><span class="line"> #pragma fragment frag  </span><br><span class="line"></span><br><span class="line"> ENDCG  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>本节介绍的使用深度纹理重建像素的世界坐标的方法是非常有用的。但需要注意的是，这里的实现是基于摄像机的投影类型是<strong>透视投影</strong>的前提下。如果需要在正交投影的情况下重建世界坐标，需要使用不同的公式。</p>
<h3 id="12-4-再谈边缘检测"><a href="#12-4-再谈边缘检测" class="headerlink" title="12.4 - 再谈边缘检测"></a>12.4 - 再谈边缘检测</h3><blockquote>
<p>在上一章，我们使用Sobel算子实现了屏幕图像的边缘检测，实现描边效果，但是这种直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的边缘线。物体的纹理、阴影等位置也被描上黑边，而这往往不是我们希望看到的。在本节中，我们将学习如何在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。</p>
</blockquote>
<p>本节将使用<strong>Roberts算子</strong>来进行边缘检测，它的卷积核如图所示：</p>
<p><img src="/image/UnityShaderLearning/image-20230714112922450.png" alt="image-20230714112922450"></p>
<p><strong>Roberts算子</strong>的本质是计算左上角和右下角的差值，乘以右上角和左下角的插值，作为评估边缘的依据。</p>
<p>在实现中，我们将取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值，就认为它们之间存在一条边。</p>
<p>Script：<strong>EdgeDetectNormalsAndDepth</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明该效果需要的Shader，并创建相应的材质</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader EdgeDetectShader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Material EdgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span></span><br><span class="line"> &#123;</span><br><span class="line">     EdgeDetectMaterial = CheckShaderAndCreateMaterial(EdgeDetectShader, EdgeDetectMaterial);</span><br><span class="line">     <span class="keyword">return</span> EdgeDetectMaterial;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在脚本中提供调整边缘线强度、描边颜色以及背景颜色的参数。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 1.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line"><span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> sampleDistance = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> sensitivityDepth = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> sensitivityNormals = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure>

<p><strong>sampleDistance</strong>用于控制深度+法线纹理采样时，使用的采样距离。<strong>sampleDistance</strong>越大，描边越宽。</p>
<p><strong>sensitivityDepth</strong>和<strong>sensitivityNormals</strong>将会影响被认为是边界的阈值。如果把灵敏度调得很大,那么可能即使是深度或法线上很小的变化也会形成一条边。</p>
</blockquote>
</li>
<li><p>本例需要获取摄像机的深度+法线纹理，在<strong>OnEnable</strong>中设置摄像机的相应状态。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ImageEffectOpaque</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span>   </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">     material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">     material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_SampleDistance&quot;</span>, sampleDistance);</span><br><span class="line">     material.SetVector(<span class="string">&quot;_Sensitivity&quot;</span>, <span class="keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">     Graphics.Blit(src, dest, material);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里我们为<strong>OnRenderImage</strong>函数添加了**[ImageEffectOpaque]**属性。</p>
<p>在默认情况下，<strong>OnRenderImage</strong>函数会在所有的不透明和透明的Pass执行完毕后被调用,以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的Pass（即渲染队列小于等于2500的 Pass，内置的 Background、 Geometry和 AlphaTest渲染队列均在此范围内）执行完毕后立即调用该函数，而不对透明物体（渲染队列为Transparent 的 Pass）产生影响，可以在<strong>OnRenderImage</strong>函数前添加 <strong>ImageEffectOpaque</strong>属性来实现这样的目的。</p>
<p>在本例中，我们只希望对不透明物体进行描边，而不希望透明物体也被描边，因此需要添加该属性。</p>
</blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter13-EdgeDetection</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _EdgeOnly (&quot;Edge Only&quot;, Float) = 1.0</span><br><span class="line"> _EdgeColor (&quot;Edge Color&quot;, Color) = (0, 0, 0, 1)</span><br><span class="line"> _BackgroundColor (&quot;_ackground Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _SampleDistance (&quot;Sample Distance&quot;, Float) = 1.0</span><br><span class="line"> _Sensitivity (&quot;Sensitivity&quot;, Vector) = (1, 1, 1, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，**_Sensitivity**的xy分量分别对应了法线和深度的检测灵敏度，zw分量则没有实际用途。</p>
</blockquote>
</li>
<li><p>声明对应变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">fixed _EdgeOnly;</span><br><span class="line">fixed4 _EdgeColor;</span><br><span class="line">fixed4 _BackgroundColor;</span><br><span class="line">float _SampleDistance;</span><br><span class="line">half4 _Sensitivity;</span><br><span class="line">sampler2D _CameraDepthNormalsTexture;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们声明了需要获取的深度+法线纹理**_CameraDepthNormalsTexture<strong>。由于我们需要对邻域像素进行纹理采样，所以还声明了存储纹素大小的变量</strong>_MainTex_TexelSize**。</p>
</blockquote>
</li>
<li><p>定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_img v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> half2 uv = v.texcoord;</span><br><span class="line"> o.uv[0] = uv;</span><br><span class="line"></span><br><span class="line"> #if UNITY_UV_STARTS_AT_TOP</span><br><span class="line"> if (_MainTex_TexelSize.y &lt; 0)</span><br><span class="line">     uv.y = 1 - uv.y;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> o.uv[1] = uv + _MainTex_TexelSize.xy * half2(1,1) * _SampleDistance;</span><br><span class="line"> o.uv[2] = uv + _MainTex_TexelSize.xy * half2(-1,-1) * _SampleDistance;</span><br><span class="line"> o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1,1) * _SampleDistance;</span><br><span class="line"> o.uv[4] = uv + _MainTex_TexelSize.xy * half2(1,-1) * _SampleDistance;</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们在 v2f结构体中定义了一个维数为5的纹理坐标数组。这个数组的第一个坐标存储了屏幕颜色图像的采样纹理。</li>
<li>我们对深度纹理的采样坐标进行了平台差异化处理，在必要情况下对它的竖直方向进行了翻转。</li>
<li>数组中剩余的4个坐标则存储了使用 Roberts算子时需要采样的纹理坐标。</li>
<li>我们还使用了SampleDistance来控制采样距离。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算,提高性能。由于从顶点着色器到片元着色器的插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果。</li>
</ul>
</blockquote>
</li>
<li><p>定义片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;</span><br><span class="line"> half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[1]);</span><br><span class="line"> half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[2]);</span><br><span class="line"> half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[3]);</span><br><span class="line"> half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[4]);</span><br><span class="line"></span><br><span class="line"> half edge = 1.0;</span><br><span class="line"></span><br><span class="line"> edge *= CheckSame(sample1, sample2);</span><br><span class="line"> edge *= CheckSame(sample3, sample4);</span><br><span class="line"></span><br><span class="line"> fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[0]), edge);</span><br><span class="line"> fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line"></span><br><span class="line"> return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先使用4个纹理坐标对深度+法线纹理进行采样，再调用<strong>CheckSame函数来分别计算对角线上两个纹理值的差值</strong>。<strong>CheckSame</strong>函数的返回值要么是0，要么是1，<strong>返回0时表明这两点之间存在一条边界</strong>，反之则返回1。</p>
<p>它的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">half CheckSame(half4 center, half4 sample)</span><br><span class="line">&#123;</span><br><span class="line"> half2 centerNormal = center.xy;</span><br><span class="line"> float centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line"> half2 sampleNormal = sample.xy;</span><br><span class="line"> float sampleDepth = DecodeFloatRG(sample.zw);</span><br><span class="line"></span><br><span class="line"> half2 diffNormal = abs(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line"> int isSameNormal = (diffNormal.x + diffNormal.y) &lt; 0.1;</span><br><span class="line"></span><br><span class="line"> float diffDepth = abs(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line"></span><br><span class="line"> int isSameDepth = diffDepth &lt; 0.1 * centerDepth;</span><br><span class="line"></span><br><span class="line"> // return:</span><br><span class="line"> // 1 - if normals and depth are similar enough</span><br><span class="line"> // 0 - otherwise</span><br><span class="line"> return isSameNormal * isSameDepth ? 1.0 : 0.0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>CheckSame</strong>首先对输入参数进行处理，得到两个采样点的法线和深度值。</p>
<p>值得注意的是，这里我们并没有解码得到真正的法线值，而是直接使用了xy分量。这是因为我们只需要比较两个采样值之间的差异，而不需要知道它真正的法线值。</p>
</li>
<li><p>然后，我们把两个采样点的对应值相减并取绝对值，再乘以灵敏度系数，把差异值的每个分量相加在和一个阈值比较</p>
<p>如果它们的和小于阈值，则返回1，说明差异不明显，不存在一条边界</p>
<p>否则返回0，说明存在一条边界。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>然后，我们定义边缘检测需要用到的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">CGPROGRAM  </span><br><span class="line"></span><br><span class="line">#pragma vertex vert  </span><br><span class="line">#pragma fragment fragRobertsCrossDepthAndNormal  </span><br><span class="line"></span><br><span class="line">ENDCG  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>本节实现的描边效果是基于整个屏幕空间进行的，也就是说，场景内的所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，例如当玩家选中场景中的某个物体后，我们想要在该物体周围添加一层描边效果。这时，我们可以使用 Unity提供的<code>Graphics.DrawMesh</code>或<code>Graphics.DrawMeshNow</code>函数把需要描边的物体再次渲染一遍(在所有不透明物体渲染完毕之后)，然后再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否4小于某个阈值，如果是，就在Shader 中使用<code>clip()</code>函数将该像素剔除掉，从而显示出原来的物体颜色。</p>
<h2 id="13-非真实感渲染"><a href="#13-非真实感渲染" class="headerlink" title="13 - 非真实感渲染"></a>13 - 非真实感渲染</h2><h3 id="13-1-卡通渲染"><a href="#13-1-卡通渲染" class="headerlink" title="13.1 - 卡通渲染"></a>13.1 - 卡通渲染</h3><blockquote>
<p>卡通风格是游戏中常见的一种渲染风格。使用这种风格的游戏画面通常有一些共有的特点,例如物体都被黑色的线条描边，以及分明的明暗变化等。</p>
</blockquote>
<p>要实现卡通渲染有很多方法，其中之一就是使用<strong>基于色调的着色技术(tone-based shading）</strong></p>
<p>Gooch等人在他们1998年的一篇论文中提出并实现了基于色调的光照模型。在实现中,我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调。我们曾在7.3节使用渐变纹理实现过这样的效果。</p>
<p>卡通风格的高光效果也和我们之前学习的光照不同。在卡通渲染中，模型的高光往往是一块块分界明显的纯色区域。</p>
<p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。</p>
<h4 id="13-1-1-渲染轮廓线"><a href="#13-1-1-渲染轮廓线" class="headerlink" title="13.1.1 - 渲染轮廓线"></a>13.1.1 - 渲染轮廓线</h4><p>在实时渲染中，轮廓线的渲染是应用非常广泛的一种效果。近20年来，有许多绘制模型轮廓线的方法被先后提出来。在《Real Time Rendering,third edition》一书中，作者把这些方法分成了5种类型。</p>
<ul>
<li><p>基于观察角度和表面法线的轮廓线渲染。这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速可以在一个 Pass中就得到渲染结果，但局限性很大,很多模型渲染出来的描边效果都不尽如人意。</p>
</li>
<li><p>过程式几何轮廓线渲染。这种方法的核心是使用两个Pass渲染。第一个 Pass渲染背面的面片,并使用某些技术让它的轮廓可见;第二个 Pass再正常渲染正面的面片。这种方法的优点在于快速有效,并且适用于绝大数表面平滑的模型,但它的缺点是不适合类似于立方体这样平整的模型。</p>
</li>
<li><p>基于图像处理的轮廓线渲染。我们在第12、13章介绍的边缘检测的方法就属于这个类别。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来,例如桌子上的纸张。</p>
</li>
<li><p>基于轮廓边检测的轮廓线渲染。上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对于一些情况,我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件:<br>$$<br>(n_0 \cdot v &gt; 0) \neq (n_1 \cdot v &gt; 0)<br>$$</p>
<blockquote>
<p>其中，n0和n1分别表示两个相邻三角面片的法向，v是从视角到该边上任意顶点的方向。</p>
<p>上述公式的本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。</p>
<p>我们可以在几何着色器（Geometry Shader）的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说,由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。</p>
</blockquote>
</li>
<li><p>最后一个种类就是混合了上述的几种渲染方法。例如，<strong>首先找到精确的轮廓边</strong>，<strong>把模型和轮廓边渲染到纹理中</strong>，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</p>
</li>
</ul>
<p>在本节中，我们将会在Unity中使用<strong>过程式几何轮廓线渲染</strong>的方法来对模型进行轮廓描边。</p>
<p>我们将使用两个Pass渲染模型:在第一个Pass中，我们会使用轮廓线颜色渲染整个背面的面片,并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见。代码如下:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewPos = viewPos + viewNormal * _Outline;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生面面片的情况。</p>
<p>为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的z分量进行处理,使它们等于一个定值<br>然后把法线归一化后再对顶点进行扩张。</p>
<p>这样做的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewNormal.z = -0.5;</span><br><span class="line">viewNormal = normalize(viewNormal) ;</span><br><span class="line">viewPos = viewPos + viewNormal * Outline;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="13-1-2-添加高光"><a href="#13-1-2-添加高光" class="headerlink" title="13.1.2 - 添加高光"></a>13.1.2 - 添加高光</h4><p>前面提到过，卡通风格中的高光往往是模型上一块块分界明显的纯色区域。为了实现这种效果，我们就不能再使用之前学习的光照模型。回顾一下，在之前实现 Blinn-Phong模型的过程中,我们使用法线点乘光照方向以及视角方向和的一半，再和另一个参数进行指数操作得到高光反射系数。代码如下:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float spec = pow(max(0, dot(normal,halfDir)), Gloss)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于卡通渲染需要的高光反射光照模型，我们同样需要计算normal和 halfDir的点乘结果,但不同的是，我们把该值和一个阈值进行比较，如果小于该阙值，则高光反射系数为0，否则返回1。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float spec = dot(worldNormal, worldHalfDir);</span><br><span class="line">spec = step(threshold, spec);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在上面的代码中，我们使用CG的<strong>step函数</strong>来实现和阈值比较的目的。<strong>step函数</strong>接受两个参数，第一个参数是参考值，第二个参数是待比较的数值。如果第二个参数大于等于第一个参数则返回1，否则返回0。</p>
<p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，如图14.3左图所示。出现这种问题的原因在于，高光区域的边缘不是平滑渐变的，而是由0突变到1。要想对其进行抗锯齿处理,我们可以在边界处很小的一块区域内,进行平滑处理。代码如下:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float spec = dot(worldNormal, worldHalfDir);</span><br><span class="line">spec = lerp(0, 1, smoothstep(-w, w, spec - threshold));</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们没有像之前一样直接使用step函数返回0或1，而是首先使用了CG的<strong>smoothstep函数</strong>。其中，w是一个很小的值，当<code>spec - threshold</code>小于-w时，返回0，大于w时,返回1，否则在0到1之间进行插值。</p>
<p>这样的效果是，我们可以在[-w,w]区间内，即高光区域的边界处，得到一个从0到1平滑变化的spec值，从而实现抗锯齿的目的。尽管我们可以把w设为一个很小的定值，但在本例中，我们选择使用邻域像素之间的近似导数值,这可以通过CG的<strong>fwidth函数</strong>来得到。</p>
</blockquote>
<h4 id="13-1-3-实现"><a href="#13-1-3-实现" class="headerlink" title="13.1.3 - 实现"></a>13.1.3 - 实现</h4><p>Shader：<strong>Chapter14-ToonShader</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Color (&quot;Color Tine&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _Ramp (&quot;Ramp Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Outline (&quot;Outline&quot;, Range(0, 1)) = 0.1</span><br><span class="line"> _OutlineColor (&quot;Outline Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _SpecularScale (&quot;Specular Scale&quot;, Range(0, 0.1)) = 0.1</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Ramp</strong>是用于控制漫反射色调的渐变纹理</p>
<p><strong>Outline</strong>用于控制轮廓线宽度</p>
<p><strong>_OutlineColor</strong>对应了轮廓线颜色</p>
<p><strong>Specular</strong> 是高光反射颜色</p>
<p><strong>SpecularScale</strong>用于控制计算高光反射时使用的阈值。</p>
</blockquote>
</li>
<li><p>定义渲染轮廓线需要的Pass，这个Pass只渲染背面的三角面，所以需要进行以下设置：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> NAME &quot;OUTLINE&quot;</span><br><span class="line"> Cull Front</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义描边需要的顶点着色器和片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//法线外扩</span><br><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line"> v2f o;</span><br><span class="line"></span><br><span class="line"> float4 pos = mul(UNITY_MATRIX_MV, v.vertex);</span><br><span class="line"> float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line"> normal.z = -0.5;</span><br><span class="line"> pos = pos + float4(normalize(normal), 0) * _Outline;</span><br><span class="line"> o.pos = mul(UNITY_MATRIX_P, pos);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> return fixed4(fixed4(_OutlineColor.rgb, 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在顶点着色器中我们首先把顶点和法线变换到视角空间下，这是为了让描边可以在观察空间达到最好的效果。</li>
<li>随后，我们设置法线的z分量，对其归一化后再将顶点沿其方向扩张，得到扩张后的顶点坐标。对法线的处理是为了尽可能避免背面扩张后的顶点挡住正面的面片。</li>
<li>最后，我们把顶点从视角空间变换到裁剪空间。</li>
<li>片元着色器只需要返回描线的颜色即可。</li>
</ul>
</blockquote>
</li>
<li><p>然后，我们要定义光照模型所在的Pass，以渲染模型的正面。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"> Cull Back</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment frag</span><br><span class="line"></span><br><span class="line"> #pragma multi_compile_fwdbase</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们将LightMode设置为ForwardBase，并且使用#pragma语句设置了编译指令，这些都是为了让 Shader中的光照变量可以被正确赋值。</p>
</blockquote>
</li>
<li><p>然后，我们定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct a2v</span><br><span class="line">&#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> float3 normal : NORMAL;</span><br><span class="line"> float4 texcoord : TEXCOORD0;</span><br><span class="line"> float4 tangent : TANGENT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line"> float4 pos : POSITION;</span><br><span class="line"> float2 uv : TEXCOORD0;</span><br><span class="line"> float3 worldNormal : TEXCOORD1;</span><br><span class="line"> float3 worldPos : TEXCOORD2;</span><br><span class="line"> SHADOW_COORDS(3)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"></span><br><span class="line"> o.pos = UnityObjectToClipPos( v.vertex);</span><br><span class="line"> o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);</span><br><span class="line"> o.worldNormal  = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们计算了世界空间下的法线方向和顶点位置，并使用Unity提供的内置宏<strong>SHADOW_COORDS</strong>和<strong>TRANSFER_SHADOW</strong>来计算阴影所需的各个变量。</p>
</blockquote>
</li>
<li><p>然后我们在片元着色器中计算光照模型</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"> fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"> fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"> fixed3 worldviewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line"> fixed3 halfDir = normalize(worldLightDir + worldviewDir);</span><br><span class="line"></span><br><span class="line"> fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line"> fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line"> UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line"> fixed diff =  dot(worldNormal, worldLightDir);</span><br><span class="line"> diff = (diff * 0.5 + 0.5) * atten;</span><br><span class="line"></span><br><span class="line"> fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> fixed spec = dot(worldNormal, halfDir);</span><br><span class="line"> fixed w = fwidth(spec) * 2.0;</span><br><span class="line"> fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.0001, _SpecularScale);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，我们计算了光照模型中需要的各个方向矢量，并对它们进行了归一化处理。</li>
<li>然后，我们计算了材质的<strong>反射率albedo</strong>和<strong>环境光照ambient</strong><br>接着，我们使用内置的<strong>UNITY_LIGHT_ATTENUATION</strong>宏来计算当前世界坐标下的阴影值。</li>
<li>随后，我们计算了半兰伯特漫反射系数，并和阴影值相乘得到最终的漫反射系数。我们使用这个漫反射系数对<strong>渐变纹理Ramp</strong>进行采样，并将结果和材质的反射率、光照颜色相乘，作为最后的漫反射光照。</li>
<li>高光反射的计算和14.1.2节中介绍的方法一致，我们使用<strong>fwidth</strong>对高光区域的边界进行抗锯齿处理，并将计算而得的高光反射系数和高光反射颜色相乘，得到高光反射的光照部分。</li>
<li>值得注意的是，我们在最后还使用了<code>step(0.0001,_SpecularScale)</code>，这是为了在**_SpecularScale**为0时，可以完全消除高光反射的光照。</li>
<li>最后，返回环境光照、漫反射光照和高光反射光照叠加的结果。</li>
</ul>
</blockquote>
</li>
<li><p>最后选择合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="13-2-素描风格的渲染"><a href="#13-2-素描风格的渲染" class="headerlink" title="13.2 - 素描风格的渲染"></a>13.2 - 素描风格的渲染</h3><p>Shader：<strong>Chapter14-ToonShader</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line"> _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _TileFactor (&quot;Tile Factor&quot;, Float) = 1</span><br><span class="line"> _Outline (&quot;Outline&quot;, Range(0, 1)) = 0.1</span><br><span class="line"> _Hatch0 (&quot;Hatch 0&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Hatch1 (&quot;Hatch 1&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Hatch2 (&quot;Hatch 2&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Hatch3 (&quot;Hatch 3&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Hatch4 (&quot;Hatch 4&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _Hatch5 (&quot;Hatch 5&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>Color</strong>是用于控制模型颜色的属性。**_TileFactor<strong>是纹理的平铺系数，</strong>_TileFactor<strong>越大，模型上的素描线条越密，在实现图14.5的过程中，我们把</strong>_TileFactor** 设置为8。<strong>Hatch0</strong>至**_Hatch5**对应了渲染时使用的6张素描纹理,它们的线条密度依次增大。</p>
</blockquote>
</li>
<li><p>由于素描风格也需要轮廓线，我们使用上一节中的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line"></span><br><span class="line"> UsePass &quot;Shader Learning/Chapter14/Chapter14-ToonShader/OUTLINE&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义光照模型所在的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment frag</span><br><span class="line"></span><br><span class="line"> #pragma multi_compile_fwdbase</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>声明参数，定义顶点着色器的输入输出结构体</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fixed4 _Color;</span><br><span class="line">float _TileFactor;</span><br><span class="line">sampler2D _Hatch0;</span><br><span class="line">sampler2D _Hatch1;</span><br><span class="line">sampler2D _Hatch2;</span><br><span class="line">sampler2D _Hatch3;</span><br><span class="line">sampler2D _Hatch4;</span><br><span class="line">sampler2D _Hatch5;</span><br><span class="line"></span><br><span class="line">struct a2v &#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> float4 tangent : TANGENT; </span><br><span class="line"> float3 normal : NORMAL; </span><br><span class="line"> float2 texcoord : TEXCOORD0; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line"> float4 pos : SV_POSITION;</span><br><span class="line"> float2 uv : TEXCOORD0;</span><br><span class="line"> fixed3 hatchWeights0 : TEXCOORD1;</span><br><span class="line"> fixed3 hatchWeights1 : TEXCOORD2;</span><br><span class="line"> float3 worldPos : TEXCOORD3;</span><br><span class="line"> SHADOW_COORDS(4)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于一共声明了6张纹理，这意味着需要6个混合权重，我们把它们存储在两个fixed3类型的变量(<strong>hatchWeights0</strong>和 <strong>hatchWeights1</strong>)中。为了添加阴影效果，我们还声明了<strong>worldPos</strong>变量，并使用<strong>SHADOW_COORDS</strong> 宏声明了阴影纹理的采样坐标。</p>
</blockquote>
</li>
<li><p>然后，我们定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"></span><br><span class="line"> o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> o.uv = v.texcoord.xy * _TileFactor;</span><br><span class="line"></span><br><span class="line"> fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));</span><br><span class="line"> fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"> fixed diff = max(0, dot(worldLightDir, worldNormal));</span><br><span class="line"></span><br><span class="line"> o.hatchWeights0 = fixed3(0, 0, 0);</span><br><span class="line"> o.hatchWeights1 = fixed3(0, 0, 0);</span><br><span class="line"></span><br><span class="line"> float hatchFactor = diff * 7.0;</span><br><span class="line"></span><br><span class="line"> if (hatchFactor &gt; 6.0) &#123;</span><br><span class="line">     // Pure white, do nothing</span><br><span class="line"> &#125; else if (hatchFactor &gt; 5.0) &#123;</span><br><span class="line">     o.hatchWeights0.x = hatchFactor - 5.0;</span><br><span class="line"> &#125; else if (hatchFactor &gt; 4.0) &#123;</span><br><span class="line">     o.hatchWeights0.x = hatchFactor - 4.0;</span><br><span class="line">     o.hatchWeights0.y = 1.0 - o.hatchWeights0.x;</span><br><span class="line"> &#125; else if (hatchFactor &gt; 3.0) &#123;</span><br><span class="line">     o.hatchWeights0.y = hatchFactor - 3.0;</span><br><span class="line">     o.hatchWeights0.z = 1.0 - o.hatchWeights0.y;</span><br><span class="line"> &#125; else if (hatchFactor &gt; 2.0) &#123;</span><br><span class="line">     o.hatchWeights0.z = hatchFactor - 2.0;</span><br><span class="line">     o.hatchWeights1.x = 1.0 - o.hatchWeights0.z;</span><br><span class="line"> &#125; else if (hatchFactor &gt; 1.0) &#123;</span><br><span class="line">     o.hatchWeights1.x = hatchFactor - 1.0;</span><br><span class="line">     o.hatchWeights1.y = 1.0 - o.hatchWeights1.x;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     o.hatchWeights1.y = hatchFactor;</span><br><span class="line">     o.hatchWeights1.z = 1.0 - o.hatchWeights1.y;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line"> return o; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先对顶点进行了基本的坐标变换。</li>
<li>然后，使用**_TileFactor** 得到了纹理采样坐标。</li>
<li>在计算6张纹理的混合权重之前，我们首先需要计算逐顶点光照。因此，我们使用世界空间下的光照方向和法线方向得到漫反射系数diff。</li>
<li>之后,我们把权重值初始化为0，并把diff缩放到[0,7]范围,得到 hatchFactor。我们把[0,7]的区间均匀划分为7个子区间，通过判断hatchFactor 所处的子区间来计算对应的纹理混合权重。</li>
<li>最后，我们计算了顶点的世界坐标，并使用<strong>TRANSFER_SHADOW</strong>宏来计算阴影纹理的采样坐标。</li>
</ul>
</blockquote>
</li>
<li><p>然后我们在片元着色器中计算光照模型</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;			</span><br><span class="line"> fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;</span><br><span class="line"> fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;</span><br><span class="line"> fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;</span><br><span class="line"> fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;</span><br><span class="line"> fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;</span><br><span class="line"> fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;</span><br><span class="line"> fixed4 whiteColor = fixed4(1, 1, 1, 1) * (1 - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - </span><br><span class="line">             i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);</span><br><span class="line"></span><br><span class="line"> fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;</span><br><span class="line"></span><br><span class="line"> UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line"> return fixed4(hatchColor.rgb * _Color.rgb * atten, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当得到了6六张纹理的混合权重后，我们对每张纹理进行采样并和它们对应的权重值相乘得到每张纹理的采样颜色。</li>
<li>我们还计算了纯白在渲染中的贡献度，这是通过从1中减去所有6张纹理的权重来得到的。这是因为素描中往往有留白的部分，因此我们希望在最后的渲染中光照最亮的部分是纯白色的。</li>
<li>最后，我们混合了各个颜色值，并和阴影值 atten、模型颜色_Color相乘后返回最终的渲染结果。</li>
</ul>
</blockquote>
</li>
<li><p>最后设置合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="13-3-拓展阅读"><a href="#13-3-拓展阅读" class="headerlink" title="13.3 - 拓展阅读"></a>13.3 - 拓展阅读</h3><blockquote>
<p>国际讨论会 NPAR(Non-Photorealistic Animation and Rendering）上可以找到许多关于非真实感渲染的论文。</p>
<p>浙江大学的耿卫东教授编纂的书籍《艺术化绘制的图形学原理与方法》(英文名:The Algorithms and Principlesof Non-photorealistic Graphics)。这本书概述了近年来非真实感渲染在各个领域的发展，并简述了许多有重要贡献的算法过程，是一本非常好的参考书籍。</p>
<p>在Unity 的资源商店中，也有许多优秀的非真实感渲染资源。例如，Toon Shader Free(<a target="_blank" rel="noopener" href="https://www.assetstore.unity3d.com/cn/#!/content/21288%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E5%8D%A1%E9%80%9A%E8%B5%84%E6%BA%90%E5%8C%85%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%8C%85%E6%8B%AC%E8%BD%AE%E5%BB%93%E7%BA%BF%E6%B8%B2%E6%9F%93%E7%AD%89%E5%8D%A1%E9%80%9A%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%82">https://www.assetstore.unity3d.com/cn/#!/content/21288）是一个免费的卡通资源包，里面实现了包括轮廓线渲染等卡通风格的渲染。</a></p>
<p>Toon Styles Shader Pack ( https:/<a target="_blank" rel="noopener" href="http://www.assetstore.unity3d.com/cn/#!/content/7212%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%81%E6%94%B6%E8%B4%B9%E7%9A%84%E5%8D%A1%E9%80%9A%E8%B5%84%E6%BA%90%E5%8C%85%EF%BC%8C%E5%AE%83%E5%8C%85%E5%90%AB%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%8D%A1%E9%80%9A%E9%A3%8E%E6%A0%BC%E7%9A%84">www.assetstore.unity3d.com/cn/#!/content/7212）是一个需要收费的卡通资源包，它包含了更多的卡通风格的</a> Unity Shader。</p>
<p>Hand-Drawn Shader Pack (<a target="_blank" rel="noopener" href="https://www.assetstore.unity3d.com/cn/#!/content/12465%EF%BC%89%E5%90%8C%E6%A0%B7%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%81%E6%94%B6%E8%B4%B9%E7%9A%84%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C%E5%8C%85%EF%BC%8C%E5%AE%83%E5%8C%85%E5%90%AB%E4%BA%86%E8%AF%B8%E5%A6%82%E9%93%85%E7%AC%94%E6%B8%B2%E6%9F%93%E3%80%81%E8%9C%A1%E7%AC%94%E6%B8%B2%E6%9F%93%E7%AD%89%E5%A4%9A%E7%A7%8D%E6%89%8B%E7%BB%98%E9%A3%8E%E6%A0%BC%E7%9A%84%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C%E3%80%82">https://www.assetstore.unity3d.com/cn/#!/content/12465）同样是一个需要收费的非真实感渲染效果包，它包含了诸如铅笔渲染、蜡笔渲染等多种手绘风格的非真实感渲染效果。</a></p>
</blockquote>
<h2 id="14-噪声"><a href="#14-噪声" class="headerlink" title="14 - 噪声"></a>14 - 噪声</h2><h3 id="14-1-消融效果"><a href="#14-1-消融效果" class="headerlink" title="14.1 - 消融效果"></a>14.1 - 消融效果</h3><p>Shader：<strong>Chapter15-Dissolve</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line"> _BurnAmount (&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0</span><br><span class="line"> _LineWidth(&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1</span><br><span class="line"> _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line"> _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (1, 0, 0, 1)</span><br><span class="line"> _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (1, 0, 0, 1)</span><br><span class="line"> _BurnMap(&quot;Burn Map&quot;, 2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BurnAmount</strong>属性用于控制消融程度，当值为0时，物体为正常效果，当值为1时，物体会完全消融。</p>
<p><strong>_LineWidth</strong>属性用于控制模拟烧焦效果时的线宽，它的值越大，火焰边缘的蔓延范围越广。</p>
<p><strong>_MainTex</strong>和 <strong>_BumpMap</strong>分别对应了物体原本的漫反射纹理和法线纹理。</p>
<p><strong>BurnFirstColor</strong>和<strong>BurnSecondColor</strong>对应了火焰边缘的两种颜色值。</p>
<p><strong>BurnMap</strong>则是关键的噪声纹理。</p>
</blockquote>
</li>
<li><p>为了得到正确的光照，设置以下渲染设置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"> Cull Off</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment frag</span><br><span class="line"></span><br><span class="line"> #pragma multi_compile_fwdbase</span><br></pre></td></tr></table></figure>

<p>值得注意的是，我们还使用Cull命令关闭了该Shader的面片剔除，也就是说，模型的正面和背面都会被渲染。这是因为，消融会导致裸露模型内部的构造，如果只渲染正面会出现错误的结果。</p>
</blockquote>
</li>
<li><p>定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct a2v &#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> float3 normal : NORMAL;</span><br><span class="line"> float4 tangent : TANGENT;</span><br><span class="line"> float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line"> float4 pos : SV_POSITION;</span><br><span class="line"> float2 uvMainTex : TEXCOORD0;</span><br><span class="line"> float2 uvBumpMap : TEXCOORD1;</span><br><span class="line"> float2 uvBurnMap : TEXCOORD2;</span><br><span class="line"> float3 lightDir : TEXCOORD3;</span><br><span class="line"> float3 worldPos : TEXCOORD4;</span><br><span class="line"> SHADOW_COORDS(5)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"> o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line"> o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line"></span><br><span class="line"> TANGENT_SPACE_ROTATION;</span><br><span class="line"> o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顶点着色器的代码很常规。我们使用宏<strong>TRANSFORM_TEX</strong>计算了三张纹理对应的纹理坐标，再把光源方向从模型空间变换到了切线空间。</li>
<li>最后,为了得到阴影信息，计算了世界空间下的顶点位置和阴影纹理的采样坐标（使用了 <strong>TRANSFER_SHADOW</strong> 宏)。</li>
</ul>
</blockquote>
</li>
<li><p>定义片元着色器来实现消融效果</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"> fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line"></span><br><span class="line"> clip(burn.r - _BurnAmount);</span><br><span class="line"></span><br><span class="line"> float3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line"> fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line"></span><br><span class="line"> fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line"></span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line"> fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line"> fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line"> fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);</span><br><span class="line"> burnColor = pow(burnColor, 5);</span><br><span class="line"></span><br><span class="line"> UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"> fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));</span><br><span class="line"></span><br><span class="line"> return fixed4(finalColor, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先对噪声纹理进行采样,并将采样结果和用于控制消融程度的属性 <strong>BurnAmount</strong>相减，传递给clip函数。当结果小于0时，该像素将会被剔除，从而不会显示到屏幕上。如果通过了测试，则进行正常的光照计算。</li>
<li>根据漫反射纹理得到材质的反射率 <strong>albedo</strong>，并由此计算得到环境光照，进而得到漫反射光照。</li>
<li>然后,我们计算了烧焦颜色 <strong>burnColor</strong>。</li>
<li>我们想要在宽度为**_LineWidth<strong>的范围内模拟一个烧焦的颜色变化，第一步就使用了</strong>smoothstep函数<strong>来计算混合系数<br>t。当t值为1时，表明该像素位于消融的边界处，当t值为0时，表明该像素为正常的模型颜色,而中间的插值则表示需要模拟一个烧焦效果。我们首先用t来混合两种火焰颜色</strong>_BurnFirstColor**和 <strong>BurnSecondColor</strong>，为了让效果更接近烧焦的痕迹，我们还使用pow函数对结果进行处理。</li>
<li>然后，我们再次使用t来混合正常的光照颜色(环境光+漫反射)和烧焦颜色。我们这里又使用了<strong>step函数</strong>来保证当<strong>BurnAmount</strong>为<strong>0</strong>时,不显示任何消融效果。</li>
<li>最后,返回混合后的颜色值 <strong>finalColor</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>然后，我们在本例中还定义了一个用于投射阴影的Pass，使用<strong>透明度测试</strong>的物体的阴影需要特别处理，如果仍然使用普通的<br>阴影Pass,那么被剔除的区域仍然会向其他物体投射阴影，造成“穿帮”。为了让物体的阴影也能配合透明度配合透明度<br>测试产生正确的效果，我们需要自定义一个投射阴影的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment frag</span><br><span class="line"></span><br><span class="line"> #pragma multi_compile_shadowcaster</span><br></pre></td></tr></table></figure>

<p><strong>顶点着色器的代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fixed _BurnAmount;</span><br><span class="line">sampler2D _BurnMap;</span><br><span class="line">float4 _BurnMap_ST;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line"> V2F_SHADOW_CASTER;</span><br><span class="line"> float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata_base v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line"> o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>片元着色器的代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">     fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line"></span><br><span class="line">     clip(burn.r - _BurnAmount);</span><br><span class="line"></span><br><span class="line">     SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line"> &#125;</span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中,我们首先在v2f结构体中利用 <strong>V2F_SHADOW_CASTER</strong>来定义阴影投射需要定义的变量。</li>
<li>随后，在顶点着色器中，我们使用 <strong>TRANSFER_SHADOW_CASTER_NORMALOFFSET</strong> 来填充 <strong>V2F_SHADOW_CASTER</strong>在背后声明的一些变量，这是由Unity在背后为我们完成的。我们需要在顶点着色器中关注自定义的计算部分，这里指的就是我们需要计算噪声纹理的采样坐标<strong>uvBurnMap</strong>。</li>
<li>在片元着色器中，我们首先按之前的处理方法使用噪声纹理的采样结果来剔除片元，最后再利用<strong>SHADOW_CASTER_FRAGMENT</strong>来让Unity为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</li>
</ul>
</blockquote>
</li>
<li><p>最后设置合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="14-2-水波效果"><a href="#14-2-水波效果" class="headerlink" title="14.2 - 水波效果"></a>14.2 - 水波效果</h3><p>模拟水波效果时，会将噪声作为一张高度图，用来修改水面的法线位置。为了进一步模拟水不断流动的效果，我们使用时间相关变量对噪声纹理进行采样，得到法线信息后再进行反射+折射的计算，最后得到水面波动效果。</p>
<p>Shader：<strong>Chapter15-WaterWave</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line"> _Color (&quot;Main Color&quot;, Color) = (0, 0.15, 0.115, 1)</span><br><span class="line"> _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _WaveMap (&quot;Wave Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line"> _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line"> _WaveXSpeed (&quot;Wave Horizontal Speed&quot;, Range(-0.1, 0.1)) = 0.01</span><br><span class="line"> _WaveYSpeed (&quot;Wave Vertical Speed&quot;, Range(-0.1, 0.1)) = 0.01</span><br><span class="line"> _Distortion (&quot;Distortion&quot;, Range(0, 100)) = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
<li><p>为了得到正确的光照，设置以下渲染设置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"> Cull Off</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment frag</span><br><span class="line"></span><br><span class="line"> #pragma multi_compile_fwdbase</span><br></pre></td></tr></table></figure>

<p>值得注意的是，我们还使用Cull命令关闭了该Shader的面片剔除，也就是说，模型的正面和背面都会被渲染。这是因为，消融会导致裸露模型内部的构造，如果只渲染正面会出现错误的结果。</p>
</blockquote>
</li>
<li><p>定义顶点着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct a2v &#123;</span><br><span class="line"> float4 vertex : POSITION;</span><br><span class="line"> float3 normal : NORMAL;</span><br><span class="line"> float4 tangent : TANGENT;</span><br><span class="line"> float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line"> float4 pos : SV_POSITION;</span><br><span class="line"> float2 uvMainTex : TEXCOORD0;</span><br><span class="line"> float2 uvBumpMap : TEXCOORD1;</span><br><span class="line"> float2 uvBurnMap : TEXCOORD2;</span><br><span class="line"> float3 lightDir : TEXCOORD3;</span><br><span class="line"> float3 worldPos : TEXCOORD4;</span><br><span class="line"> SHADOW_COORDS(5)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"> o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"> o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"> o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line"> o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line"></span><br><span class="line"> TANGENT_SPACE_ROTATION;</span><br><span class="line"> o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line"> o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顶点着色器的代码很常规。我们使用宏<strong>TRANSFORM_TEX</strong>计算了三张纹理对应的纹理坐标，再把光源方向从模型空间变换到了切线空间。</li>
<li>最后,为了得到阴影信息，计算了世界空间下的顶点位置和阴影纹理的采样坐标（使用了 <strong>TRANSFER_SHADOW</strong> 宏)。</li>
</ul>
</blockquote>
</li>
<li><p>定义片元着色器来实现消融效果</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"> fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line"></span><br><span class="line"> clip(burn.r - _BurnAmount);</span><br><span class="line"></span><br><span class="line"> float3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line"> fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line"></span><br><span class="line"> fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line"></span><br><span class="line"> fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line"> fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line"> fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line"> fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);</span><br><span class="line"> burnColor = pow(burnColor, 5);</span><br><span class="line"></span><br><span class="line"> UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"> fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));</span><br><span class="line"></span><br><span class="line"> return fixed4(finalColor, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先对噪声纹理进行采样,并将采样结果和用于控制消融程度的属性 <strong>BurnAmount</strong>相减，传递给clip函数。当结果小于0时，该像素将会被剔除，从而不会显示到屏幕上。如果通过了测试，则进行正常的光照计算。</li>
<li>根据漫反射纹理得到材质的反射率 <strong>albedo</strong>，并由此计算得到环境光照，进而得到漫反射光照。</li>
<li>然后,我们计算了烧焦颜色 <strong>burnColor</strong>。</li>
<li>我们想要在宽度为**_LineWidth<strong>的范围内模拟一个烧焦的颜色变化，第一步就使用了</strong>smoothstep函数<strong>来计算混合系数<br>t。当t值为1时，表明该像素位于消融的边界处，当t值为0时，表明该像素为正常的模型颜色,而中间的插值则表示需要模拟一个烧焦效果。我们首先用t来混合两种火焰颜色</strong>_BurnFirstColor**和 <strong>BurnSecondColor</strong>，为了让效果更接近烧焦的痕迹，我们还使用pow函数对结果进行处理。</li>
<li>然后，我们再次使用t来混合正常的光照颜色(环境光+漫反射)和烧焦颜色。我们这里又使用了<strong>step函数</strong>来保证当<strong>BurnAmount</strong>为<strong>0</strong>时,不显示任何消融效果。</li>
<li>最后,返回混合后的颜色值 <strong>finalColor</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>然后，我们在本例中还定义了一个用于投射阴影的Pass，使用<strong>透明度测试</strong>的物体的阴影需要特别处理，如果仍然使用普通的<br>阴影Pass,那么被剔除的区域仍然会向其他物体投射阴影，造成“穿帮”。为了让物体的阴影也能配合透明度配合透明度<br>测试产生正确的效果，我们需要自定义一个投射阴影的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line"> Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line"></span><br><span class="line"> CGPROGRAM</span><br><span class="line"></span><br><span class="line"> #pragma vertex vert</span><br><span class="line"> #pragma fragment frag</span><br><span class="line"></span><br><span class="line"> #pragma multi_compile_shadowcaster</span><br></pre></td></tr></table></figure>

<p><strong>顶点着色器的代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fixed _BurnAmount;</span><br><span class="line">sampler2D _BurnMap;</span><br><span class="line">float4 _BurnMap_ST;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line"> V2F_SHADOW_CASTER;</span><br><span class="line"> float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata_base v) &#123;</span><br><span class="line"> v2f o;</span><br><span class="line"></span><br><span class="line"> TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line"> o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line"></span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>片元着色器的代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">     fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line"></span><br><span class="line">     clip(burn.r - _BurnAmount);</span><br><span class="line"></span><br><span class="line">     SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line"> &#125;</span><br><span class="line"> ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中,我们首先在v2f结构体中利用 <strong>V2F_SHADOW_CASTER</strong>来定义阴影投射需要定义的变量。</li>
<li>随后，在顶点着色器中，我们使用 <strong>TRANSFER_SHADOW_CASTER_NORMALOFFSET</strong> 来填充 <strong>V2F_SHADOW_CASTER</strong>在背后声明的一些变量，这是由Unity在背后为我们完成的。我们需要在顶点着色器中关注自定义的计算部分，这里指的就是我们需要计算噪声纹理的采样坐标<strong>uvBurnMap</strong>。</li>
<li>在片元着色器中，我们首先按之前的处理方法使用噪声纹理的采样结果来剔除片元，最后再利用<strong>SHADOW_CASTER_FRAGMENT</strong>来让Unity为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</li>
</ul>
</blockquote>
</li>
<li><p>最后设置合适的FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="14-3-再谈全局雾效"><a href="#14-3-再谈全局雾效" class="headerlink" title="14.3 - 再谈全局雾效"></a>14.3 - 再谈全局雾效</h3><p>先前实现过的基于屏幕后处理的全局雾效。是由深纹理重建每个像素在世界空间下的位置，再使用一个基于高度的公式来计算雾效的混合系数,最后使用该系数来混合雾的颜色和原屏幕颜色。</p>
<p>在同一个高度上，雾的浓度是相同的。然而，一些时候我们希望可以模拟种不均匀的雾效，同时让雾不断飘动，使雾看起来更加飘渺，而这就可以i过使用一张噪声纹理来实现。</p>
<p>Script：<strong>FogWithNoise</strong></p>
<ol>
<li><p>继承基类：<strong>PostEffectsBase</strong></p>
</li>
<li><p>声明该效果需要的Shader，并创建相应的材质</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shader FogWithNoiseShader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Material FogWithNoiseMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Material material</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span></span><br><span class="line"> &#123;</span><br><span class="line">     FogWithNoiseMaterial = CheckShaderAndCreateMaterial(FogWithNoiseShader, FogWithNoiseMaterial);</span><br><span class="line">     <span class="keyword">return</span> FogWithNoiseMaterial;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在本节中，我们需要获取摄像机的相关参数，如<strong>近裁剪平面的距离</strong>、<strong>FOV</strong>等，同时还需要获取<strong>摄像机在世界空间下的前方、上方和右方等方向</strong>，因此我们用两个变量存储摄像机的<strong>Camera组件</strong>和 <strong>Transform 组件</strong></p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Camera myCamera;</span><br><span class="line"><span class="keyword">public</span> Camera camera</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">get</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">         myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> myCamera;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line"><span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line"> <span class="keyword">get</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">         myCameraTransform = camera.transform;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> myCameraTransform;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义模拟雾效时使用的各个参数</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.1f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Texture noiseTexture;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> fogXSpeed = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> fogYSpeed = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> noiseAmount = <span class="number">1.0f</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fogDensity</strong> 用于控制雾的浓度，<strong>fogColor</strong>用于控制雾的颜色。</li>
<li>我们使用的雾效模拟函数是基于高度的，因此参数<strong>fogStart</strong>用于控制雾效的<strong>起始高度</strong>，<strong>fogEnd</strong>用于控制雾效的<strong>终止高度</strong>。</li>
<li><strong>noiseTexture</strong>是我们使用的噪声纹理，<strong>fogXSpeed</strong>和<strong>fogYSpeed</strong>分别表示了噪声纹理在X和Y方向上的移动速度，以此来模拟雾的飘动效果。</li>
<li>最后，<strong>noiseAmount</strong>用于控制噪声程度，当<strong>noiseAmount</strong>为0时，代表不应用任何噪声。</li>
</ul>
</blockquote>
</li>
<li><p>本例需要获取摄像机的深度纹理，在<strong>OnEnable</strong>中设置摄像机的相应状态。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>定义<strong>OnRenderImage</strong>来进行特效处理</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">     Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">     <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">     <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">     Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">     Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line"></span><br><span class="line">     Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">     <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">     topLeft.Normalize();</span><br><span class="line">     topLeft *= scale;</span><br><span class="line"></span><br><span class="line">     Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">     topRight.Normalize();</span><br><span class="line">     topRight *= scale;</span><br><span class="line"></span><br><span class="line">     Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">     bottomLeft.Normalize();</span><br><span class="line">     bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">     Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">     bottomRight.Normalize();</span><br><span class="line">     bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">     frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">     frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">     frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">     frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">     material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">     material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">     material.SetTexture(<span class="string">&quot;_NoiseTex&quot;</span>, noiseTexture);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);</span><br><span class="line">     material.SetFloat(<span class="string">&quot;_NoiseAmount&quot;</span>, noiseAmount);</span><br><span class="line"></span><br><span class="line">     Graphics.Blit (src, dest, material);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     Graphics.Blit(src, dest);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>OnRenderImage</strong>首先计算了近裁剪平面的四个角对应的向量，并把它们存储在一个矩阵类型的变量(<strong>frustumCormers</strong>)中。</li>
<li>我们按一定顺序把这四个方向存储到了<strong>frustumCorners</strong>不同的行中，这个顺序是非常重要的,因为这决定了我们在顶点着色器中使用哪行作为该点的待插值向量。</li>
<li>随后，我们把结果和其他参数传递给材质，并调用<code>Graphics.Blit (src, dest, material)</code>把渲染结果显示在屏幕上。</li>
</ul>
</blockquote>
</li>
</ol>
<p>Shader：<strong>Chapter15-FogWithNoise</strong></p>
<ol>
<li><p>声明以下属性：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line"> _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _FogDensity (&quot;Fog Density&quot;, Float) = 1.0</span><br><span class="line"> _FogColor (&quot;Fog Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line"> _FogStart (&quot;Fog Start&quot;, Float) = 0.0</span><br><span class="line"> _FogEnd (&quot;Fog End&quot;, Float) = 1.0</span><br><span class="line"> _NoiseTex (&quot;Noise Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"> _FogXSpeed (&quot;Fog Horizontal Speed&quot;, Float) = 0.1</span><br><span class="line"> _FogYSpeed (&quot;Fog Vertical Speed&quot;, Float) = 0.1</span><br><span class="line"> _NoiseAmount (&quot;Noise Amount&quot;, Float) = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，**_Sensitivity**的xy分量分别对应了法线和深度的检测灵敏度，zw分量则没有实际用途。</p>
</blockquote>
</li>
<li><p>声明对应变量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">float4x4 _FrustumCornersRay;</span><br><span class="line"></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">sampler2D _CameraDepthTexture;</span><br><span class="line">half _FogDensity;</span><br><span class="line">fixed4 _FogColor;</span><br><span class="line">float _FogStart;</span><br><span class="line">float _FogEnd;</span><br><span class="line">sampler2D _NoiseTex;</span><br><span class="line">half _FogXSpeed;</span><br><span class="line">half _FogYSpeed;</span><br><span class="line">half _NoiseAmount;</span><br></pre></td></tr></table></figure>

<p>FrustumCornersRay虽然没有在 Properties中声明,但仍可由脚本传递给Shader。</p>
<p>除了在上面的代码中，我们还声明了需要获取的深度纹理**_CameraDepthNormalsTexture**。</p>
</blockquote>
</li>
<li><p>顶点着色器与先前的完全一致</p>
</li>
<li><p>定义片元着色器</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"> float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line"> float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line"></span><br><span class="line"> float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);</span><br><span class="line"> float noise = (tex2D(_NoiseTex, i.uv + speed).r - 0.5) * _NoiseAmount;</span><br><span class="line"></span><br><span class="line"> float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line"> fogDensity = saturate(fogDensity * _FogDensity * (1 + noise));</span><br><span class="line"></span><br><span class="line"> fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line"> finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line"></span><br><span class="line"> return finalColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先根据深度纹理来重建该像素在世界空间中的位置。</li>
<li>然后，我们利用内置的**_Time<strong>变量和</strong>FogXSpeed<strong>、 <strong>FogYSpeed</strong>属性计算出当前噪声纹理的偏移量，并据此对噪声纹理进行采样，得到噪声值。我们把该值减去 0.5，再乘以控制噪声程度的属性</strong>_NoiseAmount**，得到最终的噪声值。</li>
<li>随后，我们把该噪声值添加到雾效浓度的计算中，得到应用噪声后的雾效混合系数<strong>fogDensity</strong>。</li>
<li>最后，我们使用该系数将雾的颜色和原始颜色进行混合后返回</li>
</ul>
</blockquote>
</li>
<li><p>然后，我们定义雾效渲染需要用到的Pass</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line"> ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line"> CGPROGRAM  </span><br><span class="line"></span><br><span class="line"> #pragma vertex vert  </span><br><span class="line"> #pragma fragment frag  </span><br><span class="line"></span><br><span class="line"> ENDCG  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>最后关闭FallBack</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback Off</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="15-Unity-中的渲染优化技术"><a href="#15-Unity-中的渲染优化技术" class="headerlink" title="15 - Unity 中的渲染优化技术"></a>15 - Unity 中的渲染优化技术</h2><p>在本章，我们将会阐述一些Unity中常见的优化技术。这些优化技术都是和渲染相关的,例如，使用<strong>批处理</strong>、<strong>LOD (Level of Detail）技术等</strong>。</p>
<blockquote>
<p>游戏优化不仅是程序员的工作,更需要美工人员在游戏的美术上进行一定的权衡，</p>
<p>例如,<strong>避免使用全屏的屏幕特效</strong>，<strong>避免使用计算复杂的shader</strong>，<strong>减少透明混合造成的overdraw等</strong>。也就是说，这是由程序员和美工人员等各个部分人员共同参的工作。</p>
</blockquote>
<h3 id="15-1-移动平台的特点"><a href="#15-1-移动平台的特点" class="headerlink" title="15.1 - 移动平台的特点"></a>15.1 - 移动平台的特点</h3><p>为了尽可能移除那些隐藏的表面,减少**overdraw（即一个像素被绘制多次)**，PowerV芯片(通常用于iOS 设备和某些Android设备)使用了基于瓦片的延迟渲染(Tiled-based Deferrred Rendering,TBDR）架构，把所有的渲染图像装入一个个瓦片（tile)中，再由硬件找到可见的片元，而只有这些可见片元才会执行片元着色器。</p>
<p>另一些基于瓦片的GPU架构，如 Adreno高通的芯片)和 Mali (ARM的芯片)则会使用Early-Z或相似的技术进行一个低精度的的深度检测来剔除那些不需要渲染的片元,</p>
<p>还有一些 GPU,如 Tegra（英伟达的芯片)，则使用了传统的架构设计，因此在这些设备上，overdraw 更可能造成性能的瓶颈。</p>
<blockquote>
<p>相比与Android 平台，iOS平台硬件条件则相对统一。读者可以在 Unity手册的 iOS硬件指南（ http:/docs.unity3d.com/Manua.iphone-Hardware.html）中找到相关的资料。</p>
</blockquote>
<h3 id="15-2-影响性能的因素"><a href="#15-2-影响性能的因素" class="headerlink" title="15.2 - 影响性能的因素"></a>15.2 - 影响性能的因素</h3><p>对于一个游戏来说，他主要需要使用两种计算资源：<strong>CPU</strong>主要负责保证帧率,<strong>GPU</strong>主要负责分辨率相关的一些处理。</p>
<p>造成游戏性能瓶颈的主要原因分以下几类：</p>
<p><strong>CPU：</strong></p>
<ul>
<li>过多的draw call。</li>
<li>复杂的脚本或者物理模拟。</li>
</ul>
<p><strong>GPU：</strong></p>
<ul>
<li><strong>顶点处理</strong><ul>
<li>过多的顶点。</li>
<li>过多的逐顶点计算。</li>
</ul>
</li>
<li><strong>片元处理</strong><ul>
<li>过多的片元（既可能是由于分辨率造成的，也可能是由于overdraw造成的)。</li>
<li>过多的逐片元计算。</li>
</ul>
</li>
</ul>
<p><strong>带宽：</strong></p>
<ul>
<li>使用了尺寸很大且未压缩的纹理。</li>
<li>分辨率过高的帧缓存。</li>
</ul>
<p>对于 <strong>CPU</strong> 来说，限制它的主要是<strong>每一帧中 draw call的数目</strong></p>
<blockquote>
<p>当然，其他原因也可能造成CPU瓶颈，例物理、布料模拟、蒙皮、粒子模拟等，这些都是计算量很大的操作。</p>
</blockquote>
<p>而对于<strong>GPU</strong> 来说，它负责整个渲染流水线。它从处理 CPU 传递过来的模型数据开始，进行顶点着色器、片元着色器等一系列工作，最后输出屏幕上的每个像素。因此，GPU的性能瓶颈和<strong>需要处理的顶点数目</strong>、<strong>屏幕分辨率</strong>、<strong>显存</strong>等因素有关。</p>
<p>而相关的优化策略可以从<strong>减少处理的数据规模（包括顶点数目和片元数目)<strong>、</strong>减少运算复杂度</strong>等方面入手。</p>
<p><strong>本章涉及到的优化技术有：</strong></p>
<p><strong>CPU优化：</strong></p>
<ul>
<li>使用批处理技术减少draw call数目</li>
</ul>
<p><strong>GPU优化：</strong></p>
<ul>
<li><strong>减少需要处理的顶点数目</strong><ul>
<li>优化几何体</li>
<li>使用模型的LOD（Level of Detail）技术</li>
<li>使用遮挡剔除（Occlusion Culling）技术</li>
</ul>
</li>
<li><strong>减少需要处理的片元数目</strong><ul>
<li>控制绘制顺序</li>
<li>警惕透明物体</li>
<li>减少实时光照</li>
</ul>
</li>
<li><strong>减少计算复杂度</strong><ul>
<li>使用Shader的LOD（Level of Detail）技术</li>
<li>代码方面的优化</li>
</ul>
</li>
</ul>
<p><strong>节省内存带宽：</strong></p>
<ul>
<li>减少纹理大小</li>
<li>使用分辨率缩放</li>
</ul>
<h3 id="15-3-Unity中的渲染分析工具"><a href="#15-3-Unity中的渲染分析工具" class="headerlink" title="15.3 - Unity中的渲染分析工具"></a>15.3 - Unity中的渲染分析工具</h3><p>Unity中的渲染分析工具包括：</p>
<ul>
<li>渲染统计窗口（Rendering Statistics Window）</li>
<li>性能分析器（Profiler)</li>
<li>帧调试器（Frame Debugger）</li>
</ul>
<h4 id="15-3-1-渲染统计窗口"><a href="#15-3-1-渲染统计窗口" class="headerlink" title="15.3.1 - 渲染统计窗口"></a>15.3.1 - 渲染统计窗口</h4><blockquote>
<p>在Game窗口右上方菜单栏可以看到。渲染统计窗口中显示了很多重要的渲染数据,例如<strong>FPS</strong>、<strong>批处理数目</strong>、<strong>顶点和三角网格的数目等</strong>。下表列出了渲染统计窗口中显示的各个信息。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">信息名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">每帧的时间和 FPS</td>
<td>在 Graphic的右侧显示，给出了处理和渲染一帧所需的时间，以及FPS 数目</td>
</tr>
<tr>
<td align="left">Batches</td>
<td>一帧中需要进行的批处理数目</td>
</tr>
<tr>
<td align="left">Saved by batching</td>
<td>合并的批处理数目，这个数字表明了批处理为我们节省了多少draw call</td>
</tr>
<tr>
<td align="left">Tris 和 Verts</td>
<td>需要绘制的三角面片和顶点数目</td>
</tr>
<tr>
<td align="left">Screen</td>
<td>屏幕的大小，以及它占用的内存大小</td>
</tr>
<tr>
<td align="left">SetPass</td>
<td>渲染使用的Pass的数目，每个Pass都需要Unity的runtime来绑定一个新的 Shader，这可能成 CPU的瓶颈</td>
</tr>
<tr>
<td align="left">Visible Skinned Meshes</td>
<td>渲染的蒙皮网格的数目</td>
</tr>
<tr>
<td align="left">Animations</td>
<td>播放的动画数目</td>
</tr>
</tbody></table>
<h4 id="15-3-2-性能分析器"><a href="#15-3-2-性能分析器" class="headerlink" title="15.3.2 - 性能分析器"></a>15.3.2 - 性能分析器</h4><blockquote>
<p>我们可以通过单击<code>Window -&gt; Profiler</code>来打开 Unity 的性能分析器（Profiler）。</p>
</blockquote>
<p>性能分析器显示了绝大部分在渲染统计窗口中提供的信息，例如，绿线显示了批处理数目、蓝线显示了Pass数目等，同时还给出了许多其他非常有用的信息，例如，draw call 数目、动态批处理/静态批处理的数目、渲染纹理的数目和内存占用等。</p>
<h4 id="15-3-3-帧调试器"><a href="#15-3-3-帧调试器" class="headerlink" title="15.3.3 - 帧调试器"></a>15.3.3 - 帧调试器</h4><blockquote>
<p>我们可以通过<code>Window -&gt; Frame Debugge</code>r来打开</p>
</blockquote>
<h4 id="15-3-4-其他性能分析工具"><a href="#15-3-4-其他性能分析工具" class="headerlink" title="15.3.4 - 其他性能分析工具"></a>15.3.4 - 其他性能分析工具</h4><ul>
<li>对于Android平台来说，高通的Adreno分析工具可以对不同的测试机进行详细的性能分析。英伟达提供了NVPerfHUD 工具来帮助我们得到几乎所有需要的性能分析数据，例如，每个draw call的 GPU 时间，每个shader花费的cycle数目等。</li>
<li>对于 iOS平台来说，Unity内置的分析器可以得到整个场景花费的GPU时间。PowerVRAM的PVRUniSCo shader 分析器也可以给出一个大致的性能评估。Xcode 中的OpenGL ES Driver Instruments可以给出一些宏观上的性能信息,例如,设备利用率、渲染器利用率等。但相对于Android平台,对iOS 的性能分析更加困难（工具较少)。而且 PowerVR芯片采用了基于瓦片的延迟渲染器，因此，想要得到每个draw call 花费的GPU时间是几乎不可能的。这时，一些宏观上的统计数据可能更有参考价值。</li>
</ul>
<blockquote>
<p>一些其他的性能分析工具可以在Unit的官方手册（<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Manual/MobileProfiling.html%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E3%80%82%E5%BD%93%E6%89%BE%E5%88%B0%E4%BA%86%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%92%88%E5%AF%B9%E8%BF%99%E4%BA%9B%E6%96%B9%E9%9D%A2%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%AE%9A%E7%9A%84%E4%BC%98%E5%8C%96">http://docs.unity3d.com/Manual/MobileProfiling.html）中找到。当找到了性能瓶颈后，我们就可以针对这些方面进行特定的优化</a></p>
</blockquote>
<h3 id="15-4-减少Draw-Call-数目"><a href="#15-4-减少Draw-Call-数目" class="headerlink" title="15.4 - 减少Draw Call 数目"></a>15.4 - 减少Draw Call 数目</h3><p>最常见的优化技术大概就是批处理（batching）了。<strong>批处理的实现原理就是为了减每一帧需要的draw call数目，为此在每次面对draw call时尽可能多地处理多个物体。</strong></p>
<blockquote>
<p>一个极端的例子是，如果我们需要渲染一千个三角形，把它们按一千个单的网格进行渲染所花费的时间要远远大于渲染一个包含了一千个三角形的网格。在这两种情况下GPU 的性能消耗其实并没有多大的区别，但 CPU的draw call数目就会成为性能瓶颈。</p>
</blockquote>
<p><strong>使用同一个材质的物体可以一起处理</strong>。这是因为，对于用同一个材质的物体，它们之间的不同仅仅在于顶点数据的差别。我们可以把这些顶点数据合在一起，再一起发送给GPU,就可以完成一次批处理。</p>
<p>Unity 中支持两种批处理方式:一种是<strong>动态批处理</strong>，另一种是<strong>静态批处理</strong>。</p>
<ul>
<li>对于动态批处理来说，优点是一切处理都是Unity自动完成的,不需要我们自己做任何操作，而且物体是可以移动的，但缺点是，限制很多，可能一不小心就会破坏了这种机制，导致 Unity 无法动态批处理些使用了相同材质的物体。</li>
<li>而对于静态批处理来说，它的优点是自由度很高，限制很少;但缺点是可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了(即便在脚本中尝试改变物体的位置也是无效的)。</li>
</ul>
<h4 id="15-4-1-动态批处理"><a href="#15-4-1-动态批处理" class="headerlink" title="15.4.1 - 动态批处理"></a>15.4.1 - 动态批处理</h4><p>动态批处理的基本原理是，<strong>每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给GPU，然后使用同一个材质对其渲染</strong>。除了实现方便，动态批处理的另一个好处是，<strong>经过批处理的物体仍然可以移动</strong>，这是由于在处理每帧时Unity都会重新合并一次网格。</p>
<p>但是动态批处理有以下限制条件：</p>
<ul>
<li><p><strong>能够进行动态批处理的网格的顶点属性规模</strong>要小于900。例如，如果shader中需要使用顶点位置、法线和纹理坐标这3个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。需要注意的是，这个数字在未来有可能会发生变化，因此不要依赖这个数据。</p>
</li>
<li><p><strong>使用光照纹理（lightmap）的物体</strong>需要小心处理。这些物体需要额外的渲染参数,例如,在光照纹理上的索引、偏移量和缩放信息等。因此，为了让这些物体可以被动态批处理，我们需要保证它们指向光照纹理中的同一个位置</p>
</li>
<li><p><strong>多Pass 的shader会中断批处理。</strong>在前向渲染中,我们有时需要使用额外的Pass来为模型添加更多的光照效果，但这样一来模型就不会被动态批处理了。</p>
<blockquote>
<p>如果我们在只有平行光的场景下添加一个点光源，基于向前渲染的物体，即使用了多个Pass 的 shader在需要应用多个光照的情况下，破坏了动态批处理的机制，导致 Unity不能对这些物体进行动态批处理。</p>
</blockquote>
</li>
</ul>
<h4 id="15-4-2-静态批处理"><a href="#15-4-2-静态批处理" class="headerlink" title="15.4.2 - 静态批处理"></a>15.4.2 - 静态批处理</h4><p>静态批处理的实现原理是，只在运行开始阶段，把需要进行静态批处理的模型合并一个新的网格结构中。</p>
<blockquote>
<p>这意味着这些模型不可以在运行时刻被移动。但由于它只需要进行一次合并操作，因此，比动态批处理更加高效。</p>
<p>静态批处理的另一个缺点在于，它往往需要占用更多的内存来存储合并后的几何结构。这是因为，如果在静态批处理前一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品,即一个网格会变成多个网格再发送给GPU。如果这类使用同一网格的对象很多，那么这就会成为一个性能瓶颈了。</p>
</blockquote>
<p><strong>静态批处理的实现非常简单，只需要把物体面板上的Static复选框勾选上即可(实际上我们只需要勾选 Batching Static即可)</strong></p>
<p>在内部实现上，Unity首先把这些静态物体变换到世界空间下，然后为它们构建一个更大的顶点和索引缓存。</p>
<ul>
<li>对于使用了同一材质的物体，Unity 只需要调用一个draw call就可以绘制全部物体。</li>
<li>而对于使用了不同材质的物体，静态批处理同样可以提升渲染性能。尽管这些物体仍然需要调用多个draw call，但静态批处理可以减少这draw call之间的状态切换,而这些切换往往是费时的操作。从合并后的网格结构中我们还可以发现，尽管3个 Teapot对象使用了同一个网格，</li>
</ul>
<p>如果场景中包含了除了平行光以外的其他光源,并且在 shader 中定义了额外的Pass来处理它们，这些额外的Pass 部分是不会被批处理的。但是，处理平行光的Base Pass部分仍然会被静态批处理。因此，我们仍然可以节省Draw Call。</p>
<h4 id="15-4-3-共享材质"><a href="#15-4-3-共享材质" class="headerlink" title="15.4.3 - 共享材质"></a>15.4.3 - 共享材质</h4><p>无论是动态批处理还是静态批处理，都要求模型之间需要共享同个材质。但不同的模型之间总会需要有不同的渲染属性，例如，使用不同的纹理、颜色等。这时我们需要一些策略来尽可能地合并材质。</p>
<ul>
<li>如果两个材质之间只有使用的纹理不同，我们可以把这些纹理合并到一张更大的纹理中,张更大的纹理被称为是一张<strong>图集（atlas）</strong>。一旦使用了用一张纹理，我们可以使用同一个材质，在使用不同的采样坐标对纹理采样即可。</li>
<li>但有时，除了纹理不同外，不同的物体在材质上还有一些微小的参数变化，例如，颜色不同、某些浮点属性不同。一种常用的方法就是<strong>使用网格的顶点数据（最常见的就是顶点颜色数据）来存储这些参数。</strong></li>
</ul>
<p>前面说过，经过批处理后的物体会被处理成更大的**VBO(Vertex Buffer Object，顶点缓冲对象)**发送给 GPU,VBO中的数据可以为输入传递给顶点着色器，因此，我们可以巧妙地对 VBO 中的数据进行控制，从而达到不同效果的目的。一个例子是，森林场景中所有的树使用了同一种材质，我们希望它们可以通过批处理来减少draw call，但不同树的颜色可能不同。这时，我们可以利用网格的顶点的颜色数据来调整。</p>
<h4 id="15-4-4-批处理的注意事项"><a href="#15-4-4-批处理的注意事项" class="headerlink" title="15.4.4 - 批处理的注意事项"></a>15.4.4 - 批处理的注意事项</h4><ul>
<li>尽可能选择静态批处理，但得时刻小心对内存的消耗,并且记住经过静态批处理的物体不可以再被移动。</li>
<li>如果无法进行静态批处理，而要使用动态批处理的话，那么请小心上面提到的各种条件限制。例如，尽可能让这样的物体少并且尽可能让这些物体包含少量的顶点属性和顶点数目。</li>
<li>对于游戏中的小道具，例如可以捡拾的金币等,可以使用动态批处理。</li>
<li>对于包含动画的这类物体，我们无法全部使用静态批处理，但其中如果有不动的部分，可以把这部分标识成“Static”。</li>
</ul>
<p>除了上述提示外，在使用批处理时还有一些需要注意的地方。由于批处理需要把多个模型变换到世界空间下再合并它们，<strong>因此，如果shader中存在一些基于模型空间下的坐标的运算，那么往往会得到错误的结果</strong>。一个解决方法是，在 shader中使<strong>DisableBatching</strong>标签来强制使用该 Shader的材质不会被批处理。</p>
<p>另一个注意事项是，<strong>使用半透明材质的物体通常需要使用严格的从后往前的绘制顺序来保证透明混合的正确性。</strong>对于这些物体，Unity 会首先保证它们的绘制顺序，再尝试对它们进行批处理。这意味着，当绘制顺序无法满足时，批处理无法在这些物体上被成功应用。</p>
<h3 id="15-5-减少需要处理的顶点数目"><a href="#15-5-减少需要处理的顶点数目" class="headerlink" title="15.5 - 减少需要处理的顶点数目"></a>15.5 - 减少需要处理的顶点数目</h3><h4 id="15-5-1-优化几何体"><a href="#15-5-1-优化几何体" class="headerlink" title="15.5.1 - 优化几何体"></a>15.5.1 - 优化几何体</h4><blockquote>
<p>在GPU看来，有时需要把一个顶点拆分成两个或更多的顶点。这种将顶点一分为多的原因主要有两个:一个是为了**分离纹理坐标(uv splits)<strong>，另一个是为了</strong>产生平滑的边界（smoothingsplits)**。它们的本质，其实都是因为对于GPU来说，顶点的每一个属性和顶点之间必须是一对一的关系。而分离纹理坐标，是因为建模时一个顶点的纹理坐标有多个。例如，对于一个立方体,它的6个面之间虽然使用了一些相同的顶点，但在不同面上，同一个顶点的纹理坐标可能并不相同。对于GPU来说，这是不可理解的，因此，它必须把这个顶点拆分成多个具有不同纹理坐标的顶点。而平滑边界也是类似的,不同的是,此时这个顶点可能会对应多个法线信息或切线信息。<br>这通常是因为我们要决定一个边是一条硬边（hard edge）还是一条平滑边(smooth edge)。</p>
</blockquote>
<p>对于GPU来说，它本质上只关心有多少个顶点。因此，尽可能减少顶点的数目其实才是我们真正需要关心的事情。因此，最后一条几何体优化建议就是:<strong>移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离。</strong></p>
<h4 id="15-5-2-模型的LOD技术"><a href="#15-5-2-模型的LOD技术" class="headerlink" title="15.5.2 - 模型的LOD技术"></a>15.5.2 - 模型的LOD技术</h4><p>另一个减少顶点数目的方法是使用LOD(Level of Detail)技术。这种技术的原理是，当一个物体离摄像机很远时，模型上的很多细节是无法被察觉到的。因此，LOD 允许当对象逐渐远离摄像机时，减少模型上的面片数量,从而提高性能。</p>
<p>在Unity中，我们可以使用LOD Group组件来为一个物体构建一个LOD。我们需要为同一个对象准备多个包含不同细节程序的模型，然后把它们赋给LOD Group组件中的不同等级，Unity就会自动判断当前位置上需要使用哪个等级的模</p>
<h4 id="15-5-1-遮挡剔除技术"><a href="#15-5-1-遮挡剔除技术" class="headerlink" title="15.5.1 - 遮挡剔除技术"></a>15.5.1 - 遮挡剔除技术</h4><p>我们最后要介绍的顶点优化策略就是<strong>遮挡剔除（Occlusion culling）技术</strong>。遮挡剔除可以用来消除那些在其他物件后面看不到的物件，这意味着资源不会浪费在计算那些看不到的顶点上，进而提升性能。</p>
<p>我们需要把<strong>遮挡剔除</strong>和<strong>摄像机的视锥体剔除（Frustum Culling）</strong>区分开来。</p>
<ul>
<li>视锥体剔除只会剔除掉那些不在摄像机的视野范围内的对象，但不会判断视野中是否有物体被其他物体挡住。</li>
<li>而遮挡剔除会使用一个虚拟的摄像机来遍历场景，从而构建一个潜在可见的对象集合的层级结构。在运行时刻，每个摄像机将会使用这个数据来识别哪些物体是可见的，而哪些被其他物体挡住不可见。</li>
</ul>
<p>使用遮挡剔除技术，不仅可以减少处理的顶点数目，还可以减少overdraw，提高游戏性能。</p>
<p>要在 Unity 中使用遮挡剔除技术，我们需要进行一系列额外的处理工作。具体步骤可以参见Unity手册的相关内容(<a target="_blank" rel="noopener" href="http://ldocs.unity3d.com/ManualOcclusionCulling.html">http://ldocs.unity3d.com/ManualOcclusionCulling.html</a>)<br>模型的LOD技术和遮挡剔除技术可以同时减少CPU和 GPU的负荷。CPU可以提交更少的draw call，而 GPU需要处理的顶点和片元数目也减少了。</p>
<h3 id="15-6-减少需要处理的片元数目"><a href="#15-6-减少需要处理的片元数目" class="headerlink" title="15.6 - 减少需要处理的片元数目"></a>15.6 - 减少需要处理的片元数目</h3><p>另一个造成 GPU瓶颈的是需要处理过多的片元。这部分优化的重点在于减少ovrerdraw。简单来说，overdraw指的就是同一个像素被绘制了多次。</p>
<h4 id="15-6-1-控制绘制顺序"><a href="#15-6-1-控制绘制顺序" class="headerlink" title="15.6.1 - 控制绘制顺序"></a>15.6.1 - 控制绘制顺序</h4><blockquote>
<p>为了最大限度地避免overdraw，重要的优化策略就是控制绘制顺序。由于深度测试的存在，如果我们可以保证物体都是从前往后绘制的，那么就可以很大程度上减少overdraw。这是因为，在后面绘制的物体由于无法通过深度测试，因此，就不会再进行后面的渲染处理。</p>
</blockquote>
<p>在Unity中，那些渲染队列数目小于2500（如“Background””Geometry”和“AlphaTest” 的对象都被认为是不透明（opaque）的物<br>这些物体总体上是从前往后绘制的,而队列（如“Transparent””Overlay”等的物体，则是从后往前绘制的。<strong>这意味着，我们可以尽可能地把物体的队列设置为不透明物体的渲染队列,而尽量避免使用半透明队列。</strong></p>
<p>而且，我们还可以充分利用 Unity 的渲染队列来控制绘制顺序。例如，对于游戏中的主要人物角色来说，他们使用的shader 往往比较复杂，但是，由于他们通常会挡住屏幕的很大一部分区域，因此我们可以先绘制它们(使用更小的渲染队列)。</p>
<p>而对于一些敌方角色，它们通常会出现在各种掩体后面，因此，我们可以在所有常规的不透明物体后面渲染它们(使用更大的渲染队列)。而对于天空盒子来说，它几乎覆盖了所有的像素，而且我们知道它永远会出现在所有物体的后面，因此，它的队列可以设置为“Geometry+1”。这样，就可以保证不会因为它而造成overdraw。</p>
<h4 id="15-6-2-时刻警惕透明物体"><a href="#15-6-2-时刻警惕透明物体" class="headerlink" title="15.6.2 - 时刻警惕透明物体"></a>15.6.2 - 时刻警惕透明物体</h4><p>对于半透明对象来说，由于它们没有开启深度写入，因此，如果要得到正确的渲染效果，就必须从后往前渲染。这意味着，半透明物体几乎一定会造成 overdraw.如果我们不注意这一点,在一些机器上可能会造成严重的性能下降。例如,对于GUI对象来说，它们大多被设置成了半透明，如果屏幕中GUI占据的比例太多，而主摄像机又没有进行调整而是投影整个屏幕，那么GUI就会造成大量overdraw 。</p>
<p>对于上述GUI的这种情况，我们可以尽量减少窗口中GUI所占的面积。如果实在无能为力,我们可以把GUI的绘制和三维场景的绘制交给不同的摄像机,而其中负责三维场景的摄像机的视角范围尽量不要和 GUI的相互重叠。</p>
<p>在移动平台上，透明度测试也会影响游戏性能。虽然透明度测试没有关闭深度测试,但由于它的实现使用了discard 或 clip操作,而这些操作会导致一些硬件的优化策略失效。这种时候,使用透明度混合的性能往往比使用透明度测试更好。</p>
<h4 id="15-6-3-减少实时光照和阴影"><a href="#15-6-3-减少实时光照和阴影" class="headerlink" title="15.6.3 - 减少实时光照和阴影"></a>15.6.3 - 减少实时光照和阴影</h4><p>这些游戏的画面效果看起来好像包含了很多光源，但其实这都是骗人的，往往使用了烘焙技术，把光照提前烘焙到一张**光照纹理（lightmap)**中，然后在运行时刻只需要根据纹理采样得到光照结果即可。</p>
<p>另一个模拟光源的方法是使用 <strong>God Ray</strong>。场景中往很多小型光源的效果都是靠这种方法模拟的。它们一般并不是真的光源，很多情况是通过透明纹理模拟得到的。</p>
<blockquote>
<p>在游戏《ShadowGun》中，游戏角色看起来使用了非常复杂高级的光!照计算,但这实际上是优化后的结果。开发者们把复杂的光照计算存储到一张查找纹理（lookup texture,也被称为查找表，lookup table,LUT) 中。然后在运行时刻，我们只需要使用光源方向、视角方向、法线方向等参数，对LUT 采样得到光照结果即可。使用这样的查找纹理，不仅可以让我们使用更出色的光照模型，例如，更加复杂的 BRDF模型，还可以利用查找纹理的大小来进一步优化性能，例如,主要角色可以使用更大分辨率的LUT,而一些NPC就使用较小的LUT。《ShadowGun》的开发者还开发了一个LUT 烘焙工具，来帮助美工人员快速调整光照模型，并把结果存储到LUT 中。</p>
</blockquote>
<h3 id="15-7-节省带宽"><a href="#15-7-节省带宽" class="headerlink" title="15.7 - 节省带宽"></a>15.7 - 节省带宽</h3><p>大量使用未经压缩的纹理以及使用过大的分辨率都会造成由于带宽而引发的性能瓶颈。</p>
<h4 id="15-7-1-减少纹理大小"><a href="#15-7-1-减少纹理大小" class="headerlink" title="15.7.1 - 减少纹理大小"></a>15.7.1 - 减少纹理大小</h4><p>之前提到过，使用纹理图集可以帮助我们减少draw call的数目，而这些纹理的大小同样是个需要考虑的问题。需要注意的是，所有纹理的长宽比最好是正方形，<strong>而且长宽值最好是2的整数幂</strong>。这是因为有很多优化策略只有在这种时候才可以发挥最大效用。</p>
<p>除此之外，我们还应该尽可能使用<strong>多级渐远纹理技术(mipmapping）</strong>和<strong>纹理压缩</strong>。</p>
<h4 id="15-7-2-利用分辨率缩放"><a href="#15-7-2-利用分辨率缩放" class="headerlink" title="15.7.2 - 利用分辨率缩放"></a>15.7.2 - 利用分辨率缩放</h4><p>在 Unity 中设置屏幕分辨率可以直接调用Screen.SetResolution。</p>
<p>实际使用中可能会遇到一些情况，雨松MOMO有一篇文章(<a target="_blank" rel="noopener" href="http://www.xuanyusong.com/archives/3205%EF%BC%89%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E4%BA%86%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%8A%80%E6%9C%AF,%E8%AF%BB%E8%80%85%E5%8F%AF%E5%8F%82%E8%80%83%E3%80%82">http://www.xuanyusong.com/archives/3205）详细讲解了如何使用这种技术,读者可参考。</a></p>
<h3 id="15-8-减少计算复杂度"><a href="#15-8-减少计算复杂度" class="headerlink" title="15.8 - 减少计算复杂度"></a>15.8 - 减少计算复杂度</h3><h4 id="15-8-1-Shader的LOD技术"><a href="#15-8-1-Shader的LOD技术" class="headerlink" title="15.8.1 - Shader的LOD技术"></a>15.8.1 - Shader的LOD技术</h4><p>它的原理是，只有Shader的LOD值小于某个设定的值，这个Shader 才会被使用，而使用了那些超过设定值的Shader 的物体将不会被渲染。</p>
<blockquote>
<p>我们也可以在Unity Shader的导入面板上看到该Shader使用的LOD值。在默认情况下，允许的LOD等级是无限大的。这意味着，任何被当前显卡支持的Shader都可以被使用。但是，在某些情况下我们可能需要去掉一些使用了复杂计算的Shader渲染。这时,我们可以使用<code>Shader.maximumLOD</code>或<code>Shader.globalMaximumLOD</code>来设置允许的最大LOD值。<br>Unity内置的Shader使用了不同的LOD值,例如,Diffuse 的 LOD 为200，而 Bumped Specular的LOD为400。</p>
</blockquote>
<h4 id="15-8-2-代码方面的优化"><a href="#15-8-2-代码方面的优化" class="headerlink" title="15.8.2 - 代码方面的优化"></a>15.8.2 - 代码方面的优化</h4><p>在实现游戏效果时，我们可以选择在哪里进行某些特定的运算。通常来讲，游戏需要计算的对象、顶点和像素的数目排序是对象数&lt;顶点数像素数。因此，<strong>我们应该尽可能地把计算放在每个对象或逐顶点上。</strong></p>
<p>首先第一点是，尽可能使用低精度的浮点值进行运算。</p>
<ul>
<li>最高精度的<strong>float/highp</strong>适用于存储诸如<strong>顶点坐标等变量</strong>，但它的计算速度是最慢的，我们应该尽量避免在片元着色器中使用这种精度进行计算。</li>
<li>而 <strong>half/mediump</strong>适用于一些<strong>标量、纹理坐标</strong>等变量</li>
<li>而<strong>fixed/lowp</strong>适用于绝大多数<strong>颜色变量和归一化后的方向矢量</strong>，在进行一些对精度要求不高的计算时，我们应该尽量使用这种精度的变量。</li>
</ul>
<blockquote>
<p>要避免对这些低精度变量进行频繁的<strong>swizzle</strong>操作（如color.xwxW)。<br>还需要注意的是，我们应当尽量避免在不同精度之间的转换，这有可能会造成一定的性能下降。</p>
</blockquote>
<p>对于绝大多数GPU来说，在使用插值寄存器把数据从顶点着色器传递给下一个阶段时，我们应该使用尽可能少的插值变量。例如，<strong>如果需要对两个纹理坐标进行插值，我们通常会把它们打包在同一个float4类型的变量中,两个纹理坐标分别对应了xy分量和zw分量</strong>。然而,对于<strong>PowerVR</strong>平台来说，这种插值变量是非常廉价的,直接把不同的纹理坐标存储在不同的插值变量中，有时反而性能更好。尤其是，如果在PowerVR上使用类似tex2D(_MainTex,uv.zw)这样的语句来进行纹理采样，GPU就无法进行一些纹理的预读取，因为它会认为这些纹理采样是需要依赖其他数据的。因此，<strong>如果我们特别关心游戏在PowerVR 上的性能，就不应该把两个纹理坐标打包在同一个四维变量中。</strong></p>
<p><strong>尽可能不要使用全屏的屏幕后处理效果</strong>。如果美术风格实在是需要使用类似 <strong>Bloom</strong>、<strong>热扰动</strong>这样的屏幕特效，我们应该尽量使用<strong>fixed/lowp</strong>进行低精度运算（纹理坐标除外，可以使用half/mediump)。</p>
<p>那些高精度的运算可以使用查找表（LUT）或者转移到顶点着色器中进行处理。除此之外，尽量把多个特效合并到一个 Shader中。例如，我们可以把颜色校正和添加噪声等屏幕特效在Bloom特效的最后一个Pass中进行合成。还有一个方法就是使用16.8.3节中介绍的缩放思想，来选择性地开启特效。</p>
<p>还有一些常见的代码优化规则。</p>
<ul>
<li>尽可能不要使用分支语句和循环语句。</li>
<li>尽可能避免使用类似sin、tan、pow、log等较为复杂的数学运算。我们可以使用查找表来作为替代。</li>
<li>尽可能不要使用 discard操作，因为这会影响硬件的某些优化。</li>
</ul>
<h4 id="15-8-3-根据硬件条件进行缩放"><a href="#15-8-3-根据硬件条件进行缩放" class="headerlink" title="15.8.3 - 根据硬件条件进行缩放"></a>15.8.3 - 根据硬件条件进行缩放</h4><p>如何确保游戏可以同时流畅地运行在不同性能的移动设备上呢?一个非常简单且实用的方式是使用所谓的放缩（scaling）思想。</p>
<p>我们首先保证游戏最基本的配置可以在所有的平台上运行良好，而对于一些具有更高表现能力的设备，我们可以开启一些更“养眼”的效果，比如使用更高的分辨率，开启屏幕后处理特效，开启粒子效果等。</p>
<h3 id="15-9-拓展阅读"><a href="#15-9-拓展阅读" class="headerlink" title="15.9 - 拓展阅读"></a>15.9 - 拓展阅读</h3><p>Unity 官方手册的移动平台优化实践指南（<a target="_blank" rel="noopener" href="http://ldocs.unity3d.com/Manual/MobileOptimizationPracticalGuide.html%EF%BC%89%E4%B8%80%E6%96%87%E7%BB%99%E5%87%BA%E4%BA%86%E4%B8%80%E4%BA%9B%E9%92%88%E5%AF%B9%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%B8%B2%E6%9F%93%E5%92%8C%E5%9B%BE%E5%BD%A2%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96%E7%AD%89%E3%80%82">http://ldocs.unity3d.com/Manual/MobileOptimizationPracticalGuide.html）一文给出了一些针对移动平台的优化技术，包括渲染和图形方面的优化，以及脚本优化等。</a></p>
<p>手册中另一个针对图像性能优化的文档是优化图像性能(<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)%E4%B8%80%E6%96%87%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%A3%E4%B8%AD%EF%BC%8CUnity%E7%BB%99%E5%87%BA%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E3%80%82%E9%99%A4%E6%AD%A4%E4%B9%8B%E5%A4%96%EF%BC%8C%E6%96%87%E6%A1%A3%E5%88%97%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%B8%85%E5%8D%95%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BA%86%E4%BC%98%E5%8C%96%E6%B8%B8%E6%88%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95%E5%92%8C%E7%BA%A6%E6%9D%9F%E3%80%82">http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)一文，在这个文档中，Unity给出了常见的性能瓶颈以及一些相应的优化技术。除此之外，文档列出了一个清单，包含了优化游戏性能的常见做法和约束。</a></p>
<p>在SIGGRAPH 2011上,Unity进行了一个关于移动平台上 Shader 优化的演讲（<a target="_blank" rel="noopener" href="http://blogs.unity3d.com/2011/08/18/fast-mobile-shaders-talk-at-siggraph/%EF%BC%89%E3%80%82%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%BC%94%E8%AE%B2%E4%B8%AD%EF%BC%8C%E4%BD%9C%E8%80%85%E7%BB%99%E5%87%BA%E4%BA%86%E5%90%84%E4%B8%AA%E4%B8%BB%E6%B5%81%E7%A7%BB%E5%8A%A8GPU%E7%9A%84%E6%9E%B6%E6%9E%84%E7%89%B9%E7%82%B9%EF%BC%8C%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BA%86%E7%9B%B8%E5%BA%94%E7%9A%84shader%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82%EF%BC%8C%E8%BF%98%E7%BB%93%E5%90%88%E4%BA%86%E7%9C%9F%E5%AE%9E%E7%9A%84Unity%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0%E3%80%82">http://blogs.unity3d.com/2011/08/18/fast-mobile-shaders-talk-at-siggraph/）。在这个演讲中，作者给出了各个主流移动GPU的架构特点，并给出了相应的shader优化细节，还结合了真实的Unity游戏项目来进行实例学习。</a></p>
<p>在Unite 2013 会议上，Unity呈现了一个名为针对移动平台优化Unity游戏的演讲，在这个简短的演讲中，作者对造成性能瓶颈的原因进行了分类，并给出了一些常见的优化技术。</p>
<p>在GDC 2014 上,Unity 展示了如何使用内置的分析器分析移动平台的游戏性能,读者可以在Youtube上找到相应的视频。</p>
<p>在SIGGRAPH 2015会议上，Unity进行了一系列演讲和课程。</p>
<p>在Uni和来自高通、ARM等公司的开发人员共同呈现的名为Moving Mobile Graphics 的课程中，来Unity的 Renaldas Zioma 讲解了移动平台上PBR的优化技术。更多Unity在 SIGGRAPH 2015上的演讲，读者可以参见Unity的博客。</p>
<p>除了手册和演讲资料外,成功的移动平台中的游戏同样是非常好的学习资料。《ShadowGun)是由 MadFinger在2011年发布的一款移动平台的第三人称射击游戏,使用的开发工具正是 Unity在Unite 2011上，该游戏的开发者给出了《ShadowGun》中使用的渲染和优化技术，读者可以在Youtube上面找到这个视频。</p>
<p>更难能可贵的是，在2012年，《ShadowGun》的开发者放出了示例场景，来让更多的开发者学习如何优化移动平台上的 shader。</p>
<p>另一个非常好的游戏优化实例是Unity自带的项目《Angry Bots》，读者可以直接在Unity资源商店下载到完整的项目源代码。</p>
<h2 id="16-Unity-表面着色器实现"><a href="#16-Unity-表面着色器实现" class="headerlink" title="16 - Unity 表面着色器实现"></a>16 - Unity 表面着色器实现</h2><p>Aras认为，渲染流程的抽象应该划分成<strong>表面着色器</strong>、<strong>光照模型</strong>和<strong>光照着色器</strong>这样的层面其中，<strong>表面着色器</strong>定义了模型表面的反射率、法线和高光等，<strong>光照模型</strong>则选择是使用兰伯特还是Blinn-Phong等模型。而<strong>光照着色器</strong>负责计算光照衰减、阴影等。这样，绝大部分时间我们只需要利<strong>表面着色器</strong>打交道，例如，混合纹理和颜色等。光照模型可以是提前定义好的，我们只需要选择叨种预定义的光照模型即可。而光照着色器一旦由系统实现后，更不会被轻易改动，从而大大减轻了Shader编写者的工作量。</p>
<p>表面着色器本质上就是包含了很多Pass的顶点/片元着色器。</p>
<h3 id="16-1-表面着色器的一个例子"><a href="#16-1-表面着色器的一个例子" class="headerlink" title="16.1 - 表面着色器的一个例子"></a>16.1 - 表面着色器的一个例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter 17/Bumped Diffuse&quot; &#123;</span><br><span class="line">   Properties &#123;</span><br><span class="line">      _Color (&quot;Main Color&quot;, Color) = (1,1,1,1)</span><br><span class="line">      _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">      _BumpMap (&quot;Normalmap&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   SubShader &#123;</span><br><span class="line">      Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">      LOD 300</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">      #pragma surface surf Lambert</span><br><span class="line">      #pragma target 3.0</span><br><span class="line"></span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      sampler2D _BumpMap;</span><br><span class="line">      fixed4 _Color;</span><br><span class="line"></span><br><span class="line">      struct Input &#123;</span><br><span class="line">         float2 uv_MainTex;</span><br><span class="line">         float2 uv_BumpMap;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">         fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);</span><br><span class="line">         o.Albedo = tex.rgb * _Color.rgb;</span><br><span class="line">         o.Alpha = tex.a * _Color.a;</span><br><span class="line">         o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      ENDCG</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   FallBack &quot;Legacy Shaders/Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以轻松地实现常见的光照模型，甚至不需要和任何光照变量打交道。</p>
<p>表面着色器的CG代码必须写在SubShader块中，不能写在Pass中，Unity会在背后为我们生成多个Pass。</p>
<h3 id="16-2-编译指令"><a href="#16-2-编译指令" class="headerlink" title="16.2 - 编译指令"></a>16.2 - 编译指令</h3><p>其中，**#pragma surface<strong>用于指明该编译指令是用于定义表面着色器的，在它的后面需要指明使用的</strong>表面函数(surfaceFunction)<strong>和</strong>光照模型（lightModel)**，同时，还可以使用一些可选参数来控制表面着色器的一些行为。</p>
<p>在编译指令的背后，我们还能设置一些可选参数：</p>
<ul>
<li><strong>自定义的修改函数。</strong>除了表面函数和光照模型外，表面着色器还可以支持其他两种自定义的函数:<strong>顶点修改函数(vertex:VertexFunction</strong>)和**最后的颜色修改函数(finalcolor:ColorFunction)**。</li>
<li><strong>阴影</strong><ul>
<li><strong>addshadow</strong> 参数会为表面着色器生成一个阴影投射的Pass。</li>
<li><strong>fullforwardshadows</strong>参数则可以在前向渲染路径中支持所有光源类型的阴影。</li>
<li>如果我们不想对使用这个Shader 的物体进行任何阴影计算,就可以使用<strong>noshadow</strong>参数来禁用阴影。</li>
</ul>
</li>
<li><strong>透明度混合和透明度测试</strong><ul>
<li>我们可以通过alpha和 alphatest指令来控制透明度混合和透明度测试</li>
<li>alphatest:VariableName指令会使用名为VariableName的变量来剔除不满足条件的片元。此时，我们可能还需要使用上面提到的<strong>addshadow</strong> 参数来生成正确的阴影投射的Pass。</li>
</ul>
</li>
<li><strong>光照</strong>，一些指令可以控制光照对物体的影响<ul>
<li><strong>noambient</strong>参数会告诉Unity不要应用任何环境光照或光照探针(light probe)。</li>
<li><strong>novertexlights</strong>参数告诉Unity不要应用任何逐顶点光照。</li>
<li><strong>noforwardadd</strong> 会去掉所有前向渲染中的额外的Pass。也就是说，这个 Shader只会支持一个逐像素的平行光，而其他的光源会按照逐顶点或SH的方法来计算光照影响。这个参数通常会用于移动平台版本的表面着色器中。</li>
<li>还有一些用于控制光照烘焙、雾效模拟的参数,如<strong>nolightmap</strong>、 <strong>nofog</strong>等。</li>
</ul>
</li>
<li><strong>控制代码的生成。</strong><ul>
<li>一些指令还可以控制由表面着色器自动生成的代码，默认情况下，Unity会为一个表面着色器生成相应的前向渲染路径、延迟渲染路径使用的 Pass，这会导致生成的Shader文件比较大。如果我们确定该表面着色器只会在某些渲染路径中使用，就可以<code>exclude_path:deferred</code>、<code>exclude_path:forward</code>和 <code>exclude_path:prepass</code>来告诉Unity不需要为某些渲染路径生成代码。</li>
</ul>
</li>
</ul>
<h3 id="16-3-两个结构体"><a href="#16-3-两个结构体" class="headerlink" title="16.3 - 两个结构体"></a>16.3 - 两个结构体</h3><h4 id="16-3-1-Input结构体"><a href="#16-3-1-Input结构体" class="headerlink" title="16.3.1 - Input结构体"></a>16.3.1 - Input结构体</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>float3 viewDir</td>
<td>包含了视角方向，可用于计算边缘光照等</td>
</tr>
<tr>
<td>使用COLOR 语义定义的float4变量</td>
<td>包含了插值后的逐顶点颜色</td>
</tr>
<tr>
<td>float4 screenPos</td>
<td>包含了屏幕空间的坐标,可以用于反射或屏幕特效</td>
</tr>
<tr>
<td>float3 worldPos</td>
<td>包含了世界空间下的位置</td>
</tr>
<tr>
<td>float3 worldRefl</td>
<td>包含了世界空间下的反射方向。前提是没有修改表面法线o.Normal</td>
</tr>
<tr>
<td>float3 worldRefl; INTERNAL DATA</td>
<td>如果修改了表面法线o.Normal，需要使用该变量告诉 Unity 要基于修改后的法线计算世界空间下的反射方向。在表面函数中，我们需要使用 WorldReflectionVector(IN,o.Normal)来得到世界空间下的反射方向</td>
</tr>
<tr>
<td>float3 worldNormal</td>
<td>包含了世界空间的法线方向。前提是没有修改表面法线o.Normal</td>
</tr>
<tr>
<td>float3 worldNormal; INTERNAL DATA</td>
<td>如果修改了表面法线o.Normal，需要使用该变量告诉 Unity 要基于修改后的法线计算世界空间下的法线方向。在表面函数中，我们需要使用WorldNormalVector(IN, o.Normal)来得到世界空间下的法线方向</td>
</tr>
</tbody></table>
<p>需要注意的是,我们并不需要自己计算上述的各个变量，而只需要在Input结构体中按上述名称严格声明这些变量即可，Unity 会在背后为我们准备好这些数据，而我们只需要在表面函数中直接使用它们即可。</p>
<blockquote>
<p>一个例外情况是，我们自定义了顶点修改函数，并需要向表面函数中传递一些自定义的数据。例如，为了自定义雾效，我们可能需要在顶点修改函数中根据顶点在视角空间下的位置信息计算雾效混合系数，这样我们就可以在 Input结构体中定义一个名为half fog 的变量，把计算结果存储在该变量后进行输出。</p>
</blockquote>
<h4 id="16-3-2-SurfaceOutput结构体"><a href="#16-3-2-SurfaceOutput结构体" class="headerlink" title="16.3.2 - SurfaceOutput结构体"></a>16.3.2 - SurfaceOutput结构体</h4><p><strong>SurfaceOutput结构体中的变量和含义：</strong></p>
<ul>
<li><p><strong>fixed3 Albedo：</strong>对光源的反射率。通常由纹理采样和颜色属性的乘积计算而得。</p>
</li>
<li><p><strong>fixed3 Normal：</strong>表面法线方向。</p>
</li>
<li><p><strong>fixed3 Emission：</strong>自发光。Unity通常会在片元着色器最后输出前(并在最后的顶点函数被调用前，如果定义了的话)，使用类似下面的语句进行简单的颜色叠加:</p>
<blockquote>
<p>c.rgb+= o.Emission;</p>
</blockquote>
</li>
<li><p><strong>half Specular：</strong>高光反射中的指数部分的系数，影响高光反射的计算。例如，如果使用了内置的BlinnPhong光照函数，它会使用如下语句计算高光反射的强度:</p>
<blockquote>
<p>float spec = pow (nh, s.Specular*128.0) * s.Gloss;</p>
</blockquote>
</li>
<li><p><strong>fixed Gloss：</strong>高光反射中的强度系数。和上面的Specular类似，计算公式见上面的代码。一般在包含了高光反射的光照模型里使用。</p>
</li>
<li><p><strong>fixed Alpha：</strong>透明通道。如果开启了透明度的话，会使用该值进行颜色混合。</p>
</li>
</ul>
<h4 id="16-3-3-Unity在背后做了什么"><a href="#16-3-3-Unity在背后做了什么" class="headerlink" title="16.3.3 - Unity在背后做了什么"></a>16.3.3 - Unity在背后做了什么</h4><p>Unity会在背后为表面着色器生成真正的顶点/片元着色器。</p>
<p>Unity 对该Pass的自动生成过程大致如下。</p>
<ol>
<li>直接将表面着色器中CGPROGRAM 和 ENDCG之间的代码复制过来，这些代码包括了我们对Input结构体、表面函数、光照函数（如果自定了的话）等变量和函数的定义。这些函数和变量会在之后的处理过程中被当成正常的结构体和函数进行调用。</li>
<li>Unity会分析上述代码，并据此生成顶点着色器的输出：v2f_surf结构体</li>
<li>接着生成顶点着色器</li>
<li>最后生成片元着色器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter 17/Normal Extrusion&quot; &#123;</span><br><span class="line">   Properties &#123;</span><br><span class="line">      _ColorTint (&quot;Color Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">      _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">      _BumpMap (&quot;Normalmap&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">      _Amount (&quot;Extrusion Amount&quot;, Range(-0.5, 0.5)) = 0.1</span><br><span class="line">   &#125;</span><br><span class="line">   SubShader &#123;</span><br><span class="line">      Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">      LOD 300</span><br><span class="line">      </span><br><span class="line">      CGPROGRAM</span><br><span class="line">      </span><br><span class="line">      // surf - which surface function.</span><br><span class="line">      // CustomLambert - which lighting model to use.</span><br><span class="line">      // vertex:myvert - use custom vertex modification function.</span><br><span class="line">      // finalcolor:mycolor - use custom final color modification function.</span><br><span class="line">      // addshadow - generate a shadow caster pass. Because we modify the vertex position, the shder needs special shadows handling.</span><br><span class="line">      // exclude_path:deferred/exclude_path:prepas - do not generate passes for deferred/legacy deferred rendering path.</span><br><span class="line">      // nometa - do not generate a “meta” pass (that’s used by lightmapping &amp; dynamic global illumination to extract surface information).</span><br><span class="line">      #pragma surface surf CustomLambert vertex:myvert finalcolor:mycolor addshadow exclude_path:deferred exclude_path:prepass nometa</span><br><span class="line">      #pragma target 3.0</span><br><span class="line">      </span><br><span class="line">      fixed4 _ColorTint;</span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      sampler2D _BumpMap;</span><br><span class="line">      half _Amount;</span><br><span class="line">      </span><br><span class="line">      struct Input &#123;</span><br><span class="line">         float2 uv_MainTex;</span><br><span class="line">         float2 uv_BumpMap;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      void myvert (inout appdata_full v) &#123;</span><br><span class="line">         v.vertex.xyz += v.normal * _Amount;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">         fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);</span><br><span class="line">         o.Albedo = tex.rgb;</span><br><span class="line">         o.Alpha = tex.a;</span><br><span class="line">         o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      half4 LightingCustomLambert (SurfaceOutput s, half3 lightDir, half atten) &#123;</span><br><span class="line">         half NdotL = dot(s.Normal, lightDir);</span><br><span class="line">         half4 c;</span><br><span class="line">         c.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten);</span><br><span class="line">         c.a = s.Alpha;</span><br><span class="line">         return c;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      void mycolor (Input IN, SurfaceOutput o, inout fixed4 color) &#123;</span><br><span class="line">         color *= _ColorTint;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      ENDCG</span><br><span class="line">   &#125;</span><br><span class="line">   FallBack &quot;Legacy Shaders/Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16-4-Surface-Shader的缺点"><a href="#16-4-Surface-Shader的缺点" class="headerlink" title="16.4 - Surface Shader的缺点"></a>16.4 - Surface Shader的缺点</h3><p>除了性能比较差以外，表面着色器还无法完成一些自定义的渲染效果，例如10.2.2节中透明玻璃的效果。表面着色器的这些缺点让很多人更愿意使用自由的顶点/片元着色器来实现各种效果,尽管处理光照时这可能难度更大些。</p>
<ul>
<li>如果你需要和各种光源打交道，尤其是想要使用Unity 中的全局光照的话，你可能更喜欢使用表面着色器,但要时刻小心它的性能</li>
<li>如果你需要处理的光源数目非常少，例如只有一个平行光，那么使用顶点/片元着色器是一个更好的选择;</li>
<li>最重要的是，如果你有很多自定义的渲染效果，那么请选择顶点/片元着色器。</li>
</ul>
<h2 id="17-基于物理的渲染"><a href="#17-基于物理的渲染" class="headerlink" title="17 - 基于物理的渲染"></a>17 - 基于物理的渲染</h2><blockquote>
<p>本节主要参考了Naty Hoffman在SIGGRAPH 2013上做的名为 Background: Physics and Math of Shading 的演讲。</p>
</blockquote>
<p>PBS 的优点在于，我们只需要一个万能的shader就可以渲染相当一大部分类型的材质，而不是使用传统的做法为每种材质写一个特定的 shader。同时，PBS可以保证在各种光照条件下，材质都可以自然地和光源进行交互，而不需要我们反复地调整材质参数。</p>
<h3 id="17-1-光"><a href="#17-1-光" class="headerlink" title="17.1 - 光"></a>17.1 - 光</h3><p>在物理学中，光是一种电磁波。首先,光由太阳或其他光源中被发射出来，然后与场景中的对象相交，一些光线被吸收(absorption)，而另一些则被散射（scattering)，最后光线被一个感应器(例如我们的眼睛)吸收成像。</p>
<p>材质和光相交会产生两种物理现象：<strong>散射</strong>和<strong>吸收</strong></p>
<ul>
<li>光线被吸收是因为转换成了其他的能量，但是吸收不会改变传播方向。</li>
<li>相反，散射不会改变光的能量，但是会改变光线的传播方向。</li>
</ul>
<p><strong>金属材质</strong>和<strong>非金属材质</strong>的区别：</p>
<ul>
<li>金属材质具有很高的吸收系数，因此，所有被折射的光往往会被立刻吸收,被金属内部的自由电子转化成其他形式的能量。</li>
<li>而非金属材质则会同时表现出吸收和散射两种现象，这些被散射出去的光又被称为次表面散射光（subsurface-scattered light)</li>
</ul>
<h4 id="17-1-2-双向反射分布函数-BRDF"><a href="#17-1-2-双向反射分布函数-BRDF" class="headerlink" title="17.1.2 - 双向反射分布函数(BRDF)"></a>17.1.2 - 双向反射分布函数(BRDF)</h4><p>我们可以用<strong>辐射率（radiance）</strong>来量化光，在渲染中，我们通常会基于表面的入射光线的入射辐射率来计算出射辐射率，这个过程也被称作着色。</p>
<blockquote>
<p>而要得到出射辐射率L，我们需要知道物体表面一点是如何和光进行交互的。而这个过程就可以使用 **BRDF(Bidirectional Reflectance Distribution Function,中文名称为双向反射分布函数)**来定量分析。</p>
<p>大多数情况下，BRDF可以用f(I,v)来表示，其中<strong>I</strong>为入射方向和<strong>v</strong>为观察方向(双向的含义)。这种情况下,绕着表面法线旋转入射方向或观察方向并不会影响BRDF 的结果,这种 BRDF被称为是各项同性(isotropic）的 BRDF。与之对应的则是各向异性（anisotropic）的BRDF。</p>
</blockquote>
<p><strong>BRDF</strong> 可以用于描述两种不同的物理现象:表面反射和次表面散射。</p>
<p>针对每种现象,BRDF通常会包含一个单独的部分来描述它们,一用于描述<strong>表面反射</strong>的部分被称为<strong>高光反射项（specular term)<strong>，以及用于描述</strong>次表面散射</strong>的<strong>漫反射项（diffuse term)</strong>,</p>
<h4 id="17-1-3-漫反射项"><a href="#17-1-3-漫反射项" class="headerlink" title="17.1.3 - 漫反射项"></a>17.1.3 - 漫反射项</h4><h4 id="17-1-4-高光反射项"><a href="#17-1-4-高光反射项" class="headerlink" title="17.1.4 - 高光反射项"></a>17.1.4 - 高光反射项</h4><h4 id="17-1-5-Unity中的PBS实现"><a href="#17-1-5-Unity中的PBS实现" class="headerlink" title="17.1.5 - Unity中的PBS实现"></a>17.1.5 - Unity中的PBS实现</h4><p><strong>Unity使用的BRDF漫反射项：</strong><br>$$<br>f_{diff}(I,v) = \frac{baseColor}{\pi}(1 + (F_{D90} - 1)(1-n \cdot I)^5)(1 + (F_{D90} - 1)(1-n \cdot I)^5)<br>$$</p>
<p>其中：<br>$$<br>F_{D90} = 0.5 + 2roughness(h \cdot I)^2<br>$$</p>
<p><strong>Unity使用的高光反射项分布函数D(h)：</strong><br>$$<br>D_{GGX} = \frac {a^2}{\pi(a^2 - 1)(n \cdot h)_2 + 1)^2}<br>$$</p>
<p>其中：<br>$$<br>a = roughness^2<br>$$</p>
<p><strong>阴影-遮掩函数 G(I,v,h)<strong>则使用了一种由GGX衍生出的</strong>Smith-Schlick</strong>模型:<br>$$<br>G(I,v,h) = \frac{1}{((n \cdot l)(1-k)+k)((n \cdot v)(1-k)+k)}<br>$$</p>
<p>而<strong>菲涅耳反射 F(I,h)<strong>则使用了图形学中经常使用的</strong>Schlick菲涅耳近似等式:</strong><br>$$<br>F(I,h) = F_0 + (1 - F_0)(1 - l \cdot h)^5<br>$$<br>其中<strong>F0</strong>表示高光反射系数，在Unity中指高光反射颜色。</p>
<h3 id="17-2-Unity5的Standard-Shader"><a href="#17-2-Unity5的Standard-Shader" class="headerlink" title="17.2 - Unity5的Standard Shader"></a>17.2 - Unity5的Standard Shader</h3><p>Unity支持两种流行的基于物理的工作流程:<strong>金属工作流（Metallic workflow）</strong>和<strong>高光反射工作流（Specular workflow）</strong>。</p>
<p>其中，金属工作流是默认的工作流程，对应的 Shader为 <strong>StandardShader</strong>。而如果想要使用高光反射工作流,就需要在材质的Shader下拉框中选择**Standard( Specular setup)**。</p>
<p>需要注意的是，通常来讲，使用不同的工作流可以实现相同的效果，只是它们使用的参数不同。</p>
<p><strong>金属材质</strong></p>
<ul>
<li><p>几乎没有漫反射，因为所有被吸收的光都会被自由电子立刻转化为其他形式的能量;</p>
</li>
<li><p>有非常强烈的高光反射;</p>
</li>
<li><p>高光反射通常是有颜色的,例如金子的反光颜色为黄色。</p>
</li>
</ul>
<p><strong>非金属材质</strong></p>
<ul>
<li>大多数角度高光反射的强度比较弱，但在掠射角时高光反射强度反而会增强，即菲涅耳现象;</li>
<li>高光反射的颜色比较单一;</li>
<li>漫反射的颜色多种多样。</li>
</ul>
<blockquote>
<p>基于物理的渲染需要使用线性空间来进行相关计算。</p>
</blockquote>
<p>示例项目 Shader Calibration Scene (<a target="_blank" rel="noopener" href="https://www.assetstore.unity3d.com/en/#!/content/25422)%E4%B8%AD">https://www.assetstore.unity3d.com/en/#!/content/25422)中</a>, Unity提供了两种工作量的参考</p>
<p><img src="/image/UnityShaderLearning/UnityMetallicChart.png" alt="UnityMetallicChart"></p>
<p><img src="/image/UnityShaderLearning/UnitySpecularChart.png" alt="UnitySpecularChart"></p>
<p>除了上述属性，我们还可以为 Standard Shader选择它使用的渲染模式，即材质面板上的Render Mode选项。Standard Shader支持4<br>种渲染模式,分别是<strong>Opaque</strong>、 <strong>Cutout</strong>、<strong>Fade</strong>和 <strong>Transparent</strong>。</p>
<ul>
<li>其中，<strong>Opaque</strong>用于渲染最常见的不透明物体，这也是默认的渲染模式。</li>
<li>对于像玻璃这样的材质,我们可以选择<strong>Transparent</strong>模式，在这个渲染模式下，Albedo属性的A通道用于控制材质的透明度。</li>
<li>而在 <strong>Cutout</strong>渲染模式下，Albedo属性中纹理的A通道会成为一个掩码纹理而它的子属性Alpha Cutoff将是透明度测试时使用的阈值。</li>
<li><strong>Fade</strong>模式和 Transparent模式是类似的，不同的是,在Transparent模式下，当材质的透明值不断降低时，它的反射仍然能被保留，而在Fade模式下,该材质的所有渲染效果都会逐渐从屏幕上淡出。</li>
</ul>
<p>要想得到可信度更高的渲染结果，我们需要对不同材质使用合适的属性值,尤其是一些重要的属性值,例如<strong>Albedo</strong>、 <strong>Metallic</strong>和 <strong>Specular</strong>。当然,想要让整个场景的渲染结果令人满意，尤其包含了复杂光照的场景，仅仅有这些使用了PBS的材质是不够的，需要使用Unity提供的其他一些重要的技术，例如<strong>HDR格式的Skybox</strong>、<strong>全局光照</strong>、<strong>反射探针</strong>、<strong>光照探针</strong>、<strong>HDR</strong>和<strong>屏幕后处理</strong>等。</p>
<h3 id="17-3-基于物理渲染的实例"><a href="#17-3-基于物理渲染的实例" class="headerlink" title="17.3 - 基于物理渲染的实例"></a>17.3 - 基于物理渲染的实例</h3><h4 id="17-3-1-设置光照环境"><a href="#17-3-1-设置光照环境" class="headerlink" title="17.3.1 - 设置光照环境"></a>17.3.1 - 设置光照环境</h4><ol>
<li><p>本例的<strong>Skybox</strong>使用了一个<strong>HDR格式的Cubemap</strong>，可以让场景中的物体的反射更加真实。</p>
</li>
<li><p>我们还可以设置场景使用的<strong>环境光照</strong>，这些环境光照可以对场景中所有的物体表面产生影响。</p>
<blockquote>
<p>在<strong>Lighting</strong>中可以选择环境光照的来源：来自场景使用的<strong>Skybox</strong>、使用渐变值或者是某个固定的颜色。</p>
</blockquote>
</li>
<li><p>设置场景中的直接光照：一个平行光。保证平行光的方向和颜色与Skybox吻合。</p>
<blockquote>
<p>在平行光面板的<strong>烘焙选项(即 Baking)<strong>中，我们选择了</strong>Realtime模式</strong>，这意味着，场景中受平行光影响的所有物体都会进行实时的光照计算。当光源或场景中其他物体的位置、旋转角度等发生变化时，场景中的光照结果也会随之变化。</p>
<p>然而，实时光照往往需要较大的性能消耗，对于移动平台这样资源比较短缺的平台，我们可以选择<strong>Baked模式</strong>，此时，Unity 会把该光源的光照效果烘焙到一张<strong>光照纹理（lightmap）</strong>中，这样我们就不用实时为物体计算复杂的光照，而只需要通过纹理采样来得到光照结果。选择烘焙模式的缺点在于，如果场景中的物体发生了移动，但是它的阴影等光照效果并不会发生变化。</p>
<p>烘焙选项中的<strong>Mix模式</strong>则允许我们混合使用实时模式和烘焙模式，它会<strong>把场景中的静态物体（即那些被标识为 Static的物体)的光照烘焙到光照纹理中</strong>,但仍然会对动态物体产生实时光照。</p>
</blockquote>
</li>
<li><p>计算间接光照</p>
<blockquote>
<p> 除了 Standard Shader 外，Unity 还引入了一个重要的流水线实时<strong>全局光照（GlobeI Illumination,GI）流水线</strong>。使用GI，场景中的物体不仅可以受直接光照的影响，还可以接受间接光照的影响。在 Unity 中，间接光照指的就是那些被场景中其他物体反弹的光，这些间接光照会受反弹光的表面的颜色影响。</p>
</blockquote>
</li>
</ol>
<h4 id="17-3-2-放置反射探针"><a href="#17-3-2-放置反射探针" class="headerlink" title="17.3.2 - 放置反射探针"></a>17.3.2 - 放置反射探针</h4><blockquote>
<p>在赛车游戏中，我们需要对车身或车窗使用反射映射的技术来模拟它们的反光材质。然而，如果我们永远使用同一个 Cubemap，那么，当赛车周围的场景发生较大变化时，就很容易出现“穿帮镜头”，因为车身或车窗的环境反射并没有随着环境变化而发生变化。一种解决办法是可以在脚本中控制何时生成从当前位置观察到的 Cubemap，而 Unity 5为我们提供了一种更加方便的途径，就是反射探针(Reflection Probes)。</p>
</blockquote>
<p>反射探针的工作原理和光照探针(Light Probes）类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity 会把从这些邻近探针存储的反射结果传递给物体使用的反射纹理。如果物体周围存在多个反射探针，Unity还会在这些反射结果之间进行插值，来得到平滑渐变的反射效果。</p>
<p>反射探针同样有3种类型:</p>
<ul>
<li><strong>Baked</strong>，这种类型的反射探针是通过提前烘焙来得到该位置使用的 Cubemap 的，在游戏运行时反射探针中存的Cubemap并不会发生变化。需要注意的是，这种类型的反射探针在烘焙时同样<strong>只会处理那些静态物体(即那些被标识为Reflection Probe Static的物体);</strong></li>
<li><strong>Realtime</strong>，这种类型则会实时更新当前的Cubemap，并且不受静态物体还是动态物体的影响。当然，这种类型的反射探针需要花费更多的处理时间，因此，在使用时应当非常小心它们的性能。幸运的是，Unity 允许我们从脚本中通过触发来精确控制反射探针的更新;</li>
<li>最后一种类型是<strong>Custom</strong>，这种类型的探针既可以让我们从编辑器中烘焙它，也可以让我们使用一个自定义的Cubemap来作为反射映射，但自定义的 Cubemap不会被实时更新。</li>
</ul>
<p>需要注意的是，在放置反射探针时，我们选取的位置并不是任意的。通常来说，反射探针该被放置在那些具有明显反射现象的物体的旁边，或是一些墙角等容易发生遮挡的物体周围。</p>
<blockquote>
<p>使用反射探针往往会需要更多的计算时间。这些探针实际上也是通过在它的位置上放置一个摄像机,来渲染得到一个 Cubemap。如果我们把反弹次数设置的很大,或是使用实时渲染，那么这些探针很可能会造成性能瓶颈。</p>
<p>更多关于如何优化反射探针以及它的高级用法，参见Unity的官方手册(<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Manual/ReflectionProbes.html)%E3%80%82">http://docs.unity3d.com/Manual/ReflectionProbes.html)。</a></p>
</blockquote>
<h4 id="17-3-3-调整材质"><a href="#17-3-3-调整材质" class="headerlink" title="17.3.3 - 调整材质"></a>17.3.3 - 调整材质</h4><blockquote>
<p>要得到真实可信的渲染效果，我们需要为场景中的物体指定合适的材质。需要再次提醒读者的是基于物理的渲染并不意味着一定要模拟像照片真实的效果。基于物理的渲染更多的好处在于，可以我们的场景在各种光照条件下都能得到令人满意的效果，同时不需要频繁地调整材质参数。</p>
</blockquote>
<p>根据官方的示例项目Viking Village。这些材质可以为读者制作自己的材质提供一些参考，例如，场景中所有物体都使用了高光反射纹理(Specular Texture)、遮挡纹理(Occlusion Texture)、法线纹理(Normal Texture)，一些材质还使用了细节纹理来提供更多的细节表现。</p>
<p>此外还可以在18.2.2节中复习如何针对不同类别的物体来调整他们使用的材质属性。</p>
<h4 id="17-3-4-线性空间"><a href="#17-3-4-线性空间" class="headerlink" title="17.3.4 - 线性空间"></a>17.3.4 - 线性空间</h4><p>在使用基于物理的渲染方法渲染整个场景时，我们应该使用线性空间（Linear Space)来得到最好的渲染效果。</p>
<h3 id="17-4-答疑解惑"><a href="#17-4-答疑解惑" class="headerlink" title="17.4 - 答疑解惑"></a>17.4 - 答疑解惑</h3><h4 id="17-4-1-什么是全局光照"><a href="#17-4-1-什么是全局光照" class="headerlink" title="17.4.1 - 什么是全局光照"></a>17.4.1 - 什么是全局光照</h4><h4 id="17-4-2-什么是伽马矫正"><a href="#17-4-2-什么是伽马矫正" class="headerlink" title="17.4.2 - 什么是伽马矫正"></a>17.4.2 - 什么是伽马矫正</h4><h4 id="17-4-3-什么是HDR"><a href="#17-4-3-什么是HDR" class="headerlink" title="17.4.3 - 什么是HDR"></a>17.4.3 - 什么是HDR</h4><h4 id="17-4-4-PBS适合什么样的游戏"><a href="#17-4-4-PBS适合什么样的游戏" class="headerlink" title="17.4.4 - PBS适合什么样的游戏"></a>17.4.4 - PBS适合什么样的游戏</h4><h3 id="17-5-拓展阅读"><a href="#17-5-拓展阅读" class="headerlink" title="17.5 - 拓展阅读"></a>17.5 - 拓展阅读</h3><p><strong>Unity官方提供了很多学习PBS的资料。</strong></p>
<ul>
<li>在 Unity官方博客中的全局光照一文（global-illumination-in-unity-5）中，简明地阐述了全局光照的解决方案。</li>
<li>在另外两篇博客（working-with-physically-based-Shading-a-practical-approach/、physically-based-shading-in-unity- 5-a-primer/）中,介绍了Standard Shader的用法和注意事项。</li>
</ul>
<p><strong>官方项目也是很好的学习资料。</strong></p>
<ul>
<li>Unity 开放了基于物理着色器的示例项目 Viking Village </li>
<li>以及两个更小的示例项目Shader Calibration Seene 和Corridor Lighting Example来着重介绍如何使用Unity 5全新的Standard Shader和全局光照系统。</li>
</ul>
<p>看过Unity 5宣传视频的读者想必对Unity 5制作出来的电影短片The Blacksmith 印象深刻,尽管Unity 没有开放出完整的工程，但把许多关键的技术实现放到了资源商店里，例如，人物角色使用的Shader、头发使用的Shader、人物阴影、大气次散射等,这些都是非常好的学习资料。</p>
<p>除此之外，Unity还提供了一些相关教程供新手学习，读者可以在图形的教程板块(<a target="_blank" rel="noopener" href="http://unity3d.com/cn/learn/tutorials/topics/graphics%EF%BC%89%E4%B8%8B%E6%89%BE%E5%88%B0%E5%BE%88%E5%A4%9A%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B%E3%80%82">http://unity3d.com/cn/learn/tutorials/topics/graphics）下找到很多相关教程。</a></p>
<ul>
<li>例如，在 Unity的光照概览(<a target="_blank" rel="noopener" href="http://unity3d.com/cn/learn/tutorials/modules/beginner/unity-5/unity5-lighting-overview)%E4%B8%AD,%E4%BB%8B%E7%BB%8D%E4%BA%86Unity">http://unity3d.com/cn/learn/tutorials/modules/beginner/unity-5/unity5-lighting-overview)中,介绍了Unity</a> 5中使用的各种全局光照技术;</li>
<li>光照和渲染(<a target="_blank" rel="noopener" href="https://unity3d.com/cn/learn/tutorials/modules/beginner/graphics/lighting-and-rendering)%E4%B8%80%E6%96%87%E6%9B%B4%E5%8A%A0%E8%AF%A6%E7%BB%86%E5%9C%B0%E4%BB%8B%E7%BB%8D%E4%BA%86Unity">https://unity3d.com/cn/learn/tutorials/modules/beginner/graphics/lighting-and-rendering)一文更加详细地介绍了Unity</a> 5中各种光照的实现细节</li>
<li>以及一些设置场景光照时的注意事项;在 Standard Shader的视频教程<br>(<a target="_blank" rel="noopener" href="http://unity3d.com/cn/learn/tutorials/modules/beginner/5-tutorials/standard-shader)%E4%B8%AD%EF%BC%8CUnity">http://unity3d.com/cn/learn/tutorials/modules/beginner/5-tutorials/standard-shader)中，Unity</a><br>介绍了Standard Shader的基本用法以及和光照之间的配合。</li>
</ul>
<p><strong>近年来,Unity官方在Unite、SIGGRAPH等大会上也分享不少关于PBS的技术资料。</strong></p>
<ul>
<li>在Unite2014会议上，Anton Hand在他的演讲中给出了很多关于如何创建PBS中使用的资源的最佳实践;</li>
<li>Renaldas Zioma和 Erland Korner讲解了如何在Unity 5中更加有效地使用PBS.</li>
<li>在SIGGRPAH 2015会议上，来自 Unity的技术人员分享了The Blacksmith的环境制作过程。</li>
</ul>
<p>如果读者希望更深入地学习PBS的理论和实践，可以在近年来的<strong>SIGGRAPH 课程</strong>上找到非常丰富的资料。</p>
<ul>
<li>SIGGRAPH自2006年起开始出现与PBS相关的课程，更是连续4年(2012’2015)由来自各大游戏公司和影视公司的技术人员分享他们在PBS上的实践。例如在2012年的课程上，Disney 公布了他们在离线渲染时使用的 BRDF模型，这也是 Unity 等很多游戏引擎使用的PBR的理论基础。</li>
<li>Kostas Anagnostou在他的文章中列出了非常多的关于PBR的相关文章,包括我们上面提到的SIGGRAPH课程,强烈建议有兴趣的读者去浏览一番。</li>
</ul>
<p>国内的相关资料则相对较少。</p>
<ul>
<li>龚敏敏在他的KlayGE引擎中引入了PBS,并写了系列博文来简明地阐述其中的理论基础。在知乎专栏<strong>Behind the Pixels</strong> ( <a target="_blank" rel="noopener" href="http://zhuanlan.zhihu.com/graphics%EF%BC%89%E4%B8%AD%EF%BC%8C%E4%BD%9C%E8%80%85%E7%BB%99%E5%87%BA%E4%BA%863%E7%AF%87%E5%85%B3%E4%BA%8E%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9D%80%E8%89%B2%E7%9A%84%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E3%80%82">http://zhuanlan.zhihu.com/graphics）中，作者给出了3篇关于基于物理着色的系列文章。</a></li>
</ul>
<h2 id="18-额外内容"><a href="#18-额外内容" class="headerlink" title="18 - 额外内容"></a>18 - 额外内容</h2><h3 id="18-1-深入了解渲染"><a href="#18-1-深入了解渲染" class="headerlink" title="18.1 - 深入了解渲染"></a>18.1 - 深入了解渲染</h3><p>Unity Shader实际是建立在<strong>OpenGL</strong>、<strong>DirectX</strong>这样更加基础的图像编程按口上的。这样的封装可以为我们节省很多工作，但可能会影响我们对底层工作方式的理解。这些图像编程按口都有各自非常出色的学习资料，</p>
<ul>
<li>例如OpenGL有非常有名的红宝书<strong>《OpenGL 编程指南》</strong>和蓝宝书<strong>《OpenGL超级宝典》</strong>。</li>
<li>更多的参考书可以在<strong>叶劲峰(网名Milo Yip</strong> 的豆列计算机图形:入门/API 类（<a target="_blank" rel="noopener" href="http://www.douban.com/doulist/1445744/%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E3%80%82">http://www.douban.com/doulist/1445744/）中找到。</a></li>
</ul>
<p>这些内容相对比较高深，大都来源于行业内的精英对各种渲染技术的总结，希望深入了解渲染各个方面的读者一定不可以错过。</p>
<ul>
<li>叶劲峰在他的豆列<strong>计算机图形:Gems类</strong>(<a target="_blank" rel="noopener" href="http://www.douban.com/doulist/1445745/)%E4%B8%AD%E6%80%BB%E7%BB%93%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AD%97%E7%B2%BE%E7%B2%B9%E7%B3%BB%E5%88%97%E4%B9%A6%E7%B1%8D%E3%80%82">http://www.douban.com/doulist/1445745/)中总结了更多的图形字精粹系列书籍。</a></li>
<li><strong>GPU 精粹系列书籍</strong>中包含许多游戏和其他实时渲染中便用的高级框架技木。</li>
<li>与之类似的还有 <strong>GPU Pro系列书籍</strong>和 <strong>ShaderX系列书籍</strong>。</li>
</ul>
<p>尽管本书关注的是游戏中使用的实时渲染技术，但一些基于光线追踪等方式的渲染方法同样是图形学中的重点。</p>
<ul>
<li>在<strong>《Physically based rendering: From theory to implementation》</strong>一书中，作者介绍并实现了基于物理渲染的框架，这是学习光线追踪和PBS的非常好的资料。</li>
</ul>
<p>最后，我们不得不提起被誉为图形程序员专著的<strong>《Real-time Rendering, third Edition》</strong>一书。在该书出版时，几乎涵盖了实时渲染中的所有相关技术，作者在书中给出了大量的参考又献，开在网上维护了一个专门的页面来总结实时渲染中使用的各个技术和资料。</p>
<p>在学术方面，图形学相关的会议和论坛是开阔视野、学习前沿渲染技术的绝佳途径。</p>
<ul>
<li><strong>SIGGRAPH 会议</strong>是图形学领域最顶级的会议，每年来自世界各地的顶尖学者和行业精英都会汇聚一堂，展示这一年中他们在图形学领域的工作和进展。</li>
<li>与之类似的会议还有，<strong>SIGGRAPH Asia,Eurographics</strong>、<strong>Symposium on Interactive 3D Graphics and Games 等会议</strong>，可以在Ke-Sen Huang的主页中找到历年在这些会议上发表的论文。</li>
</ul>
<p>需要特别提出的是，每年<strong>SIGGRAPH上的SIGGRAPH Course</strong>中都会有很多来自游戏行业的技术人员分享他们在游戏图像方面的进展</p>
<ul>
<li>在第17章中提到的课程<strong>Physically Based Shading in Theory and Practice</strong></li>
<li><strong>Advances in Real-Time Rendering系列课程</strong>同样是非常出色的学习资料。在这个课程中，来自艺电、育碧、Epic等知名游戏公司的技术人员将阐述他们是如何在游戏中使用各种复杂的渲染技术来实现次世代游戏画面的。自2006年起，该课程已经在SIGGRAPH Course上连续举办了十届。</li>
<li>另一个与游年的<strong>GDC 会议</strong>都戏息息相关的会议是游戏开发者会议(Game Developers Conference,GDC),每会汇集全世界的游戏开发者。自2009年，中国也迎来了GDC China，给中国的游戏开发者提供了更多的行业交流机会。</li>
</ul>
<p>除了上述提到的书籍和会议外，一些非常有趣的网站也可以帮助开阔我们的视野。</p>
<ul>
<li>在<strong>Shadertoy网站</strong>上，你可以看到来自全世界的人们是如何只用一个片元着色器来实现各种或恢弘壮丽、或经典怀旧的场景的。</li>
<li>与之类似的还有<strong>GLSL Sandbox Gallery网站</strong>。我们相信,在浏览了这些网站后,你会再一次被 Shader能实现的效果所震撼。</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>LiKira</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://li-kira.github.io/2023/07/03/Unity-Shader-Learning/">https://li-kira.github.io/2023/07/03/Unity-Shader-Learning/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Unity-Shader/"># Unity Shader</a>
                    
                        <a href="/tags/Unity/"># Unity</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/07/31/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/">GAMES101-现代计算机图形学笔记</a>
            
            
            <a class="next" rel="next" href="/2023/06/25/VFX-Particle-System-Learning/">VFX - Particle System Learning</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© LiKira | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>